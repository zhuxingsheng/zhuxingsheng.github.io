<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






  <meta name="baidu-site-verification" content="MXFRoVpC6c" />







  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="彪悍的人生需要书写">
<meta property="og:type" content="website">
<meta property="og:title" content="码农戏码">
<meta property="og:url" content="https://zhuxingsheng.github.io/index.html">
<meta property="og:site_name" content="码农戏码">
<meta property="og:description" content="彪悍的人生需要书写">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="码农戏码">
<meta name="twitter:description" content="彪悍的人生需要书写">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 'undefined',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zhuxingsheng.github.io/"/>





  <title> 码农戏码 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?48897be5dd7a377cc247d8870a476fb8";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">码农戏码</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zhuxingsheng.github.io/2018/01/25/常识五配置中心/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="朱兴生">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/6222636?v=3&s=460">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="码农戏码">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="码农戏码" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/25/常识五配置中心/" itemprop="url">
                  常识五配置中心
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-25T20:25:59+08:00">
                2018-01-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/互联网研发/" itemprop="url" rel="index">
                    <span itemprop="name">互联网研发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          
	
	  
	  <span class="post-letters-count">
	    &nbsp; | &nbsp;
	    <span>2,614 字</span>
	    &nbsp; | &nbsp;
	    <span>9 min</span>
	  </span>
	  

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>常识系列,作为一名互联网门外汉的科普系列</p>
</blockquote>
<p>本来这篇文章想谈一下zookeeper，现在已经家喻户晓了。结果看到江南白衣的文章</p>
<blockquote>
<p>提到配置中心就跟你讲zk,etcd的，可能是个空想玩家，或者他家系统很小；</p>
</blockquote>
<p>不由得冒了两滴冷汗，高人总是一针见血。</p>
<p>所以还是多关注一下互联网的架构，而不是技术的细枝末节</p>
<p>本篇涉及到的内容包括：</p>
<blockquote>
<ol>
<li>游戏中配置中心的进化</li>
<li>什么样的配置中心才叫好</li>
<li>流行架构</li>
<li>zookeeper</li>
</ol>
</blockquote>
<h1 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h1><p>什么是配置中心？简单来说，就是一种统一管理各种应用配置的基础服务组件</p>
<p>服务一般有很多依赖配置，例如访问数据库有连接字符串配置，连接池大小和连接超时配置，这些配置在不同环境(开发/测试/生产)一般不同，比如生产环境需要配连接池，而开发测试环境可能不配，另外有些参数配置在运行期可能还要动态调整，例如，运行时根据流量状况动态调整限流和熔断阀值。</p>
<p>传统配置文件方式虽然把配置项分离到单独的配置文件，但是修改一个配置项，需要提交版本管理，发布，重启。整个过程比较麻烦，特别是发布多台机器。整个配置上线流程跟修改代码没有太大区别。不利于集中式管理和动态调整。</p>
<p>现在一般架构中都有个配置中心了，不管是独立还是集成，都有这么一块空间，尤其在微服务流行之后，服务之间有着错综复杂的依赖关系，更是必不可少。</p>
<h1 id="配置中心进化史"><a href="#配置中心进化史" class="headerlink" title="配置中心进化史"></a>配置中心进化史</h1><p>这儿谈的进化史，是一款月流水过亿的游戏配置中心填坑的过程。当然，那时我们还不叫配置中心，也不知这世上还有个配置中心的术语。不要笑，我们那时就是这么的无知无敌。</p>
<p>游戏开发中，除了基础的技术配置文件，如数据库连接配置，连接池配置；有很多的业务配置文件，如各个道具信息，怪物信息，活动信息</p>
<p>这此配置信息，可能是动态的，也有些是静态的。</p>
<blockquote>
<p>动态配置和静态配置的区别</p>
<p>曾经我也傻傻分不清楚其区别是啥，这很正常。动态和静态这是一个相对的概念，海枯石烂，永远不变的那不叫配置，可能是撩妹的鬼话,即使这个配置可能是放在一个看起来很像配置文件的文本里，配置一定是可能修改其值的，而是否是动态配置主要是看这个配置是不是跟应用的版本构建发布(build-deploy lifetime)强绑定的。如果一个配置项，跟软件的版本构建是不耦合的，在应用进程运行时，可能需要变更配置值的就是动态配置，哪怕是变更频率可能非常低，也许你设计了一个配置项，发现最后下来3年也没变更过一次，那也是动态配置，相反，配置变更只发生在软件版本构建和发布的那个点，那么就是静态配置，哪怕你构建很频繁，1个小时就来一回，那也是个静态配置，举个简单的例子:</p>
<p>build-version = 3.4.6-1569965<br>这个配置项，永远只在某个软件版本被构建出来时会变更其值，一旦这个版本被构建出来，并且在程序运行时，是一定没有变更诉求的，这就是一个跟构建绑定的静态配置。而文章开始时举得logLevel的例子，则是一个动态配置的例子。</p>
<p>所以看一下你的系统的配置项，你会发现动态配置其实更多，而跟行为演进相关的几乎都是动态配置。</p>
</blockquote>
<h2 id="第一版本"><a href="#第一版本" class="headerlink" title="第一版本"></a>第一版本</h2><p>大体的架构如下：<br><img src="http://oirwmbp4e.bkt.clouddn.com/config-center/configserver-pull.png" alt="pull"></p>
<p>这是一个pull模型</p>
<p>组成部分：</p>
<ol>
<li>配置服务器</li>
<li>游戏服务器</li>
</ol>
<p>首先配置服务器提供上传文件功能，以及被配置文件下载的能力。</p>
<p>比如寻宝活动 xunbaoconfig<br>上传时会选择对应的游戏区服，会产生两个文件</p>
<ol>
<li><p>xunbaoconfig，配置参数文件</p>
<p>文件中保持了文件md5值，游戏区服与文件对应关系<br>[gameserver1,md5,xunbaocinfig-xxxx.conf]</p>
</li>
<li><p>xunbaoconfig-xxxx.conf  配置文件</p>
<p>这就是上传的最新配置文件</p>
</li>
</ol>
<p>其次，游戏服务器需要提供支持动态配置的能力。并且定时去拉取远程配置文件，比对远程文件与当前内存中的是否一致，若不一致，重新加载配置文件</p>
<p>伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//配置文件MD5值与配置的对应关系</div><div class="line">configMap&lt;cofingFileMd5,Config&gt;</div></pre></td></tr></table></figure></p>
<p>游戏服务器定时去拉取相应的配置参数文件，xunbaoconfig，获取当前区服配置文件的md5值以及文件名。</p>
<p>若md5值与缓存数据不一致，就拉取真实的xunbaoconfig-xxx.conf文件</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>此版本，看似一切正常。</p>
<p>在韩服开到十几个区的时候，出现了一个问题</p>
<p><strong>文件下载不完整</strong></p>
<h4 id="更换tomcat"><a href="#更换tomcat" class="headerlink" title="更换tomcat"></a>更换tomcat</h4><p>这儿使用的web容器是tomcat，其中的原因当时没有细究了。后来让运维换成了ngnix，静态资源一律走ngnix就没有问题了</p>
<p>国服开到几百个区时，也出现了类似问题，每次维护后，几百个区一起开启，会有部分区，启动失败，因为加载不到配置文件；或者是没有加载到新配置，使用了老的配置。</p>
<p>分析下来，几百个区服几乎在同一时刻去配置服务器拉取文件，配置服务器压力即大，这也就是单点瓶颈故障。</p>
<p>就算没有这次的故障，后面开到几千个区服时，也会出现带宽瓶颈。大一点配置如果有5M，那一千个服就是5G，不仅是单台服务器的带宽，可能会严重阻塞整个机架的带宽。</p>
<h4 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h4><p>为了解决这个问题，不能把所有文件都放在配置中心了，需要分离，把静态的配置文件直接放到区服上，不用再去拉取。</p>
<p>虽然动静分离，但也只是减轻了这种状况，并没有彻底解决。</p>
<h2 id="第二版本"><a href="#第二版本" class="headerlink" title="第二版本"></a>第二版本</h2><p><img src="http://oirwmbp4e.bkt.clouddn.com/config-center/configserver-push.png" alt="push"></p>
<p>这是push模型</p>
<p>第一版本，每个区服都去拉取配置，给配置服务器带来了很大的压力</p>
<p>现在配置不再以每个区服为单位，而是以物理服务器为单位推送配置文件。</p>
<p>首先，上传配置文件，与pull模型一致。</p>
<p>再使用rsync同步到每个区服的物理机上，原先一台物理机上会开设八台逻辑服，现在以物理机为单位，配置中心的压力大大的下降。</p>
<p>而且rsync不再是定时去同步，而是当配置变动时，再去主动触发</p>
<h1 id="配置中心标准"><a href="#配置中心标准" class="headerlink" title="配置中心标准"></a>配置中心标准</h1><p>什么样的配置中心才是好的配置中心</p>
<ol>
<li>不能单点，以上面的进化实例，明显如果配置中心挂了，那整个游戏就失去了动态能力，如果本地没有动态配置文件备份，就完全丧失服务能力</li>
<li>支持web界面，可视化操作；这是很多技术人员的通病，直接上个shell命令，多专业，其实这降低真个系统的可用性，可维护性</li>
<li>权限管理、发布审核、操作审计；1、应用和配置的管理都有完善的权限管理机制，对配置的管理还分为了编辑和发布两个环节，从而减少人为的错误，2、所有的操作都有审计日志，可以方便地追踪问题，回滚也方便</li>
<li>灰度发布</li>
<li>版本发布管理；所有的配置发布都有版本概念，从而可以方便地支持配置的回滚</li>
<li>实时推送；现在很多配置中心使用zk之类框架，主要就是用它的发布订阅实现实时推送能力</li>
</ol>
<h2 id="客户端支持"><a href="#客户端支持" class="headerlink" title="客户端支持"></a>客户端支持</h2><p>配置中心拥有这些能力，还需要客户端的支持</p>
<ol>
<li><p>配合配置中心的实时/灰度推送，在参数变化时调用客户端自行实现的回调接口，不需要重启应用。</p>
</li>
<li><p>支持环境变量，JVM启动参数，配置文件，配置中心等多种来源按优先级互相覆盖，并有接口暴露最后的参数选择。</p>
</li>
<li><p>配置文件中支持多套profile，如开发，单元测试，集成测试，生产。</p>
</li>
</ol>
<h1 id="流行框架"><a href="#流行框架" class="headerlink" title="流行框架"></a>流行框架</h1><p>配置中心，这么重要的组件，众目聚集，也就诞生了很多开源产品</p>
<p>业界也有很多比较成熟的开源项目：</p>
<ul>
<li>disconf: 百度开源的分布式配置管理平台。项目文档上说百度、滴滴打车、银联、网易、拉勾网等知名互联网公司在使用。挺新的项目，并且目前只支持Java语言。</li>
<li>QConf: 360开源的分布式配置管理平台。跟disconf一样使用了zookeeper做配置存储，不同在于QConf使用了agent和共享内存的方式，并且支持多种语言。</li>
<li>Diamond 淘宝开源的持久配置的管理系统，支持各种持久信息（比如各种规则，数据库配置等）的发布和订阅。特点是简单，存储是MySQL，并且是拉模式。</li>
<li>Spring Cloud Config: 特点就是与Spring完美结合</li>
</ul>
<p>不管是何产品，架构都可以简化为：<br><img src="http://oirwmbp4e.bkt.clouddn.com/config-center/config-server.png" alt="pull-push"></p>
<h1 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h1><p>Zookeeper有两篇论文：</p>
<p>一篇是Zab，就是介绍Zookeeper背后使用的一致性协议的(Zookeeper atomic broadcast protocol)</p>
<p>一篇就是介绍Zookeeper本身的。在这两篇论文里都提到Zookeeper是一个分布式协调服务(a service for coordinating processes of distributed applications)。</p>
<p>这下次再开一篇，内容不少！</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://calvin1978.blogcn.com/articles/serviceconfig.html" target="_blank" rel="external">服务化体系之－配置中心，在ZK或etcd之外</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      
      <! -- 添加微信图标 -->
    
    
    
    

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zhuxingsheng.github.io/2017/12/31/常识四堆外内存/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="朱兴生">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/6222636?v=3&s=460">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="码农戏码">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="码农戏码" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/31/常识四堆外内存/" itemprop="url">
                  常识四堆外内存
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-31T13:26:22+08:00">
                2017-12-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/互联网研发/" itemprop="url" rel="index">
                    <span itemprop="name">互联网研发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          
	
	  
	  <span class="post-letters-count">
	    &nbsp; | &nbsp;
	    <span>7,372 字</span>
	    &nbsp; | &nbsp;
	    <span>30 min</span>
	  </span>
	  

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>常识系列,作为一名互联网门外汉的科普系列</p>
</blockquote>
<p>堆外内存除了在像netty开源框架中，在平常项目中使用的比较少，在现前的项目中，QPS要求高的系统中，堆外内存作为其中一级缓存是相当有成效的。所以来学习一下，文中主要涉及到这三分部内容</p>
<blockquote>
<ol>
<li>堆外内存是什么？与堆内内存的区别</li>
<li>怎么分配，与GC的影响</li>
<li>开源框架使用</li>
</ol>
</blockquote>
<p>这篇文章写到最后，发现还只是回答了开源框架OHC的<a href="#OHC">Why not use ByteBuffer.allocateDirect()?</a></p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="堆内内存"><a href="#堆内内存" class="headerlink" title="堆内内存"></a>堆内内存</h2><p>现在流行的还是使用分代管理方式</p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/off-heap/on-heap.jpg" alt="image"></p>
<p>之前写过相关文章<a href="https://zhuxingsheng.github.io/2017/02/27/gc-and-jvm-parameters/">GC及JVM参数</a></p>
<p>在jvm参数中只要使用-Xms，-Xmx等参数就可以设置堆的大小和最大值</p>
<h2 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h2><p>和堆内内存相对应，堆外内存就是把内存对象分配在Java虚拟机的堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机）</p>
<p>堆外内存有以下特点：</p>
<ul>
<li>对于大内存有良好的伸缩性</li>
<li>对垃圾回收停顿的改善可以明显感觉到</li>
<li>在进程间可以共享，减少虚拟机间的复制</li>
</ul>
<h1 id="堆外内存分配与回收"><a href="#堆外内存分配与回收" class="headerlink" title="堆外内存分配与回收"></a>堆外内存分配与回收</h1><p>其实堆外内存一直在使用,却没有真正关注过。最常见的nio,Netty，里面大量使用了堆外内存</p>
<p>这儿会涉及到很多知识点，一步步来，抽丝剥茧</p>
<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>这儿回顾下io知识，java提供了两种io处理方式，一种是io，另一种是nio</p>
<p>Java NIO和IO之间最大的区别是IO是面向流（Stream）的，NIO是面向块（buffer）的，所以，这意味着什么？</p>
<p>面向流意味着从流中一次可以读取一个或多个字节，拿到读取的这些做什么你说了算，这里没有任何缓存（这里指的是使用流没有任何缓存，接收或者发送的数据是缓存到操作系统中的，流就像一根水管从操作系统的缓存中读取数据）而且只能顺序从流中读取数据，如果需要跳过一些字节或者再读取已经读过的字节，你必须将从流中读取的数据先缓存起来。<br>面向块的处理方式有些不同，数据是先被 读/写到buffer中的，根据需要你可以控制读取什么位置的数据。这在处理的过程中给用户多了一些灵活性，然而，你需要额外做的工作是检查你需要的数据是否已经全部到了buffer中，你还需要保证当有更多的数据进入buffer中时，buffer中未处理的数据不会被覆盖</p>
<p>对于stream流来讲，一个一个字节处理效率太差了，所以还提供了带buffer的bufferedStream</p>
<p>对就到api，就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">read()</div><div class="line">read(byte b[])</div><div class="line"></div><div class="line">write()</div><div class="line">write(byte b[])</div></pre></td></tr></table></figure></p>
<p>nio是面向buffer的，所以有专门抽象了Buffer</p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/java/buffer.png" alt="buffer"></p>
<h2 id="zero-copy"><a href="#zero-copy" class="headerlink" title="zero copy"></a>zero copy</h2><p>虽然通过调节buffer的大小，使用bufferedstream可以提升性能，但还不够</p>
<p>还可以通过Zero-Copy大大提高了应用程序的性能，并且减少了kernel和user模式上下文的切换</p>
<p>这儿需要再深入底层机制，来看系统内核与应用程序的交互过程</p>
<h3 id="linux科普"><a href="#linux科普" class="headerlink" title="linux科普"></a>linux科普</h3><p>这儿再回顾一下linux相关知识点</p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/linux/linux-user-kernel.png" alt="linux的内核态和用户态"></p>
<ul>
<li>内核态：控制计算机的硬件资源，并提供上层应用程序运行的环境。比如socket I/0操作或者文件的读写操作等</li>
<li>用户态：上层应用程序的活动空间，应用程序的执行必须依托于内核提供的资源。</li>
<li>系统调用：为了使上层应用能够访问到这些资源，内核为上层应用提供访问的接口。</li>
</ul>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/linux/linux-invoke.png" alt="关系"></p>
<p>因此我们可以得知当我们通过JNI调用的native方法实际上就是从用户态切换到了内核态的一种方式。并且通过该系统调用使用操作系统所提供的功能。</p>
<p>Q：为什么需要用户进程(位于用户态中)要通过系统调用(Java中即使JNI)来调用内核态中的资源，或者说调用操作系统的服务了？<br>A：intel cpu提供Ring0-Ring3四种级别的运行模式，Ring0级别最高，Ring3最低。Linux使用了Ring3级别运行用户态，Ring0作为内核态。Ring3状态不能访问Ring0的地址空间，包括代码和数据。因此用户态是没有权限去操作内核态的资源的，它只能通过系统调用外完成用户态到内核态的切换，然后在完成相关操作后再有内核态切换回用户态。</p>
<p>鉴于linux系统的特性，IO之流程就如下图</p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/linux/io-buffer.jpg" alt="IO之流程与buffer概览"></p>
<h3 id="copy过程"><a href="#copy过程" class="headerlink" title="copy过程"></a>copy过程</h3><p>大部分web服务器都要处理大量的静态内容，而其中大部分都是从磁盘文件中读取数据然后写到socket中。这种操作对cpu的消耗是比较小的，但也是十分低效的：内核首先从磁盘文件读取数据，然后从内核空间将数据传到用户空间，应用程序又将数据从用户空间返回到内核空间然后传输给socket(如果好奇数据为何如此来回传输，请继续看下文)。实际上，应用程序就相当于是个低效的中间者，从磁盘拿数据放到socket。</p>
<h4 id="read-write模式"><a href="#read-write模式" class="headerlink" title="read/write模式"></a>read/write模式</h4><p>代码抽象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">read(file, tmp_buf, len);</div><div class="line">write(socket, tmp_buf, len);</div></pre></td></tr></table></figure></p>
<p>首先调用read将静态内容，这里假设为文件A，读取到tmp_buf, 然后调用write将tmp_buf写入到socket中</p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/linux/copy-steps.png" alt="read/write copy steps"></p>
<p>1、当调用 read 系统调用时，通过 DMA（Direct Memory Access）将数据 copy 到内核模式</p>
<p>2、然后由 CPU 控制将内核模式数据 copy 到用户模式下的 buffer 中</p>
<p>3、read 调用完成后，write 调用首先将用户模式下 buffer 中的数据 copy 到内核模式下的 socket buffer 中</p>
<p>4、最后通过 DMA copy 将内核模式下的 socket buffer 中的数据 copy 到网卡设备中传送。</p>
<p>从上面的过程可以看出，数据白白从内核模式到用户模式走了一圈，浪费了两次 copy(第一次，从kernel模式拷贝到user模式；第二次从user模式再拷贝回kernel模式，即上面4次过程的第2和3步骤。)，而这两次 copy 都是 CPU copy，即占用CPU资源</p>
<h4 id="sendfile模式"><a href="#sendfile模式" class="headerlink" title="sendfile模式"></a>sendfile模式</h4><p><img src="http://oirwmbp4e.bkt.clouddn.com/linux/sendfile-copy-steps.jpeg" alt="sendfile copy steps"></p>
<p>通过 sendfile 传送文件只需要一次系统调用，当调用 sendfile 时：</p>
<p>1、首先通过 DMA copy 将数据从磁盘读取到 kernel buffer 中</p>
<p>2、然后通过 CPU copy 将数据从 kernel buffer copy 到 sokcet buffer 中</p>
<p>3、最终通过 DMA copy 将 socket buffer 中数据 copy 到网卡 buffer 中发送</p>
<p>sendfile 与 read/write 方式相比，少了 一次模式切换一次 CPU copy。但是从上述过程中也可以发现从 kernel buffer 中将数据 copy 到socket buffer 是没必要的。</p>
<h4 id="sendfile模式改进"><a href="#sendfile模式改进" class="headerlink" title="sendfile模式改进"></a>sendfile模式改进</h4><p>Linux2.4 内核对 sendfile 做了改进，下图所示</p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/linux/sendfilev2-copy-steps.jpeg" alt="sendfilev2 copy steps"></p>
<p>改进后的处理过程如下：</p>
<p>1、DMA copy 将磁盘数据 copy 到 kernel buffer 中</p>
<p>2、向 socket buffer 中追加当前要发送的数据在 kernel buffer 中的位置和偏移量</p>
<p>3、DMA gather copy 根据 socket buffer 中的位置和偏移量直接将 kernel buffer 中的数据 copy 到网卡上。</p>
<p>经过上述过程，数据只经过了 2 次 copy 就从磁盘传送出去了。（事实上这个 Zero copy 是针对内核来讲的，数据在内核模式下是 Zero－copy 的）。</p>
<p>当前许多高性能 http server 都引入了 sendfile 机制，如 nginx，lighttpd 等。</p>
<h3 id="java-zero-copy"><a href="#java-zero-copy" class="headerlink" title="java zero copy"></a>java zero copy</h3><p>Zero-Copy技术省去了将操作系统的read buffer拷贝到程序的buffer，以及从程序buffer拷贝到socket buffer的步骤，直接将read buffer拷贝到socket buffer. Java NIO中的FileChannal.transferTo()方法就是这样的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void transferTo(long position,long count,WritableByteChannel target);</div></pre></td></tr></table></figure>
<p>transferTo()方法将数据从一个channel传输到另一个可写的channel上，其内部实现依赖于操作系统对zero copy技术的支持。在unix操作系统和各种linux的发型版本中，这种功能最终是通过sendfile()系统调用实现。下边就是这个方法的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line">ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);</div></pre></td></tr></table></figure></p>
<p>可以通过调用transferTo()方法来替代上边的File.read()、Socket.send()</p>
<p>通过transferTo实现数据传输的路径：</p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/java/transferTo.gif" alt="transferTo"></p>
<p>展示了内核态、用户态的切换情况:</p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/java/transferTo-contextSwitch.gif" alt="transferTo-contextSwitch"></p>
<p>使用transferTo()方式所经历的步骤：</p>
<p>1、transferTo调用会引起DMA将文件内容复制到读缓冲区(内核空间的缓冲区)，然后数据从这个缓冲区复制到另一个与socket输出相关的内核缓冲区中。</p>
<p>2、第三次数据复制就是DMA把socket关联的缓冲区中的数据复制到协议引擎上发送到网络上。</p>
<p>这次改善，我们是通过将内核、用户态切换的次数从四次减少到两次，将数据的复制次数从四次减少到三次(只有一次用到cpu资源)。但这并没有达到我们零复制的目标。如果底层网络适配器支持收集操作的话，我们可以进一步减少内核对数据的复制次数。</p>
<p>在内核为2.4或者以上版本的linux系统上，socket缓冲区描述符将被用来满足这个需求。这个方式不仅减少了内核用户态间的切换，而且也省去了那次需要cpu参与的复制过程。<br>从用户角度来看依旧是调用transferTo()方法，但是其本质发生了变化：</p>
<p>1、调用transferTo方法后数据被DMA从文件复制到了内核的一个缓冲区中。</p>
<p>2、数据不再被复制到socket关联的缓冲区中了，仅仅是将一个描述符（包含了数据的位置和长度等信息）追加到socket关联的缓冲区中。DMA直接将内核中的缓冲区中的数据传输给协议引擎，消除了仅剩的一次需要cpu周期的数据复制。</p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/java/transferTov2.gif" alt="transferTo"></p>
<h2 id="ByteBuffer创建"><a href="#ByteBuffer创建" class="headerlink" title="ByteBuffer创建"></a>ByteBuffer创建</h2><p>以上的知识点都是点缀，真正的主角上场了,看下java中是如何抽象上述理论的</p>
<p>ByteBuffer有两种分配buffer的方式：</p>
<p><em>分配HeapByteBuffer</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ByteBuffer buffer = ByteBuffer.allocate(int capacity);</div></pre></td></tr></table></figure></p>
<p><em>分配DirectByteBuffer</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ByteBuffer buffer = ByteBuffer.allocateDirect(int capacity);</div></pre></td></tr></table></figure></p>
<p>两者的区别，JDK里面说得很清楚</p>
<blockquote>
<p>A byte buffer is either direct or non-direct. Given a direct byte buffer, the Java virtual machine will make a best effort to perform native I/O operations directly upon it. That is, it will attempt to avoid copying the buffer’s content to (or from) an intermediate buffer before (or after) each invocation of one of the underlying operating system’s native I/O operations.<br>A direct byte buffer may be created by invoking the allocateDirect factory method of this class. The buffers returned by this method typically have somewhat higher allocation and deallocation costs than non-direct buffers. The contents of direct buffers may reside outside of the normal garbage-collected heap, and so their impact upon the memory footprint of an application might not be obvious. It is therefore recommended that direct buffers be allocated primarily for large, long-lived buffers that are subject to the underlying system’s native I/O operations. In general it is best to allocate direct buffers only when they yield a measureable gain in program performance.<br>A direct byte buffer may also be created by mapping a region of a file directly into memory. An implementation of the Java platform may optionally support the creation of direct byte buffers from native code via JNI. If an instance of one of these kinds of buffers refers to an inaccessible region of memory then an attempt to access that region will not change the buffer’s content and will cause an unspecified exception to be thrown either at the time of the access or at some later time. </p>
</blockquote>
<p>从文中大致可以看到DirectByteBuffer的特点如下：</p>
<ul>
<li>对于native IO operation，JVM会有最佳的性能效果(它不需要一个中间缓冲区，而是可以直接使用，避免了将buffer中的数据再复制到中间缓冲区)。</li>
<li>由于DirectByteBuffer分配与native memory中，不在heap区，不会受到heap区的gc影响。（一般在old gen的full gc才会收集。）</li>
<li>分配和释放需要更多的成本。<br><img src="http://oirwmbp4e.bkt.clouddn.com/java/bytebuffer-choise.jpg" alt="bytebuffer"></li>
</ul>
<p>从上可以总结DirectByteBuffer大致的应用场景如下（socket通信和大文件处理还是比较适用的）：</p>
<ul>
<li>频繁的native IO操作。</li>
<li>系统的要求处理响应速度快和稳定，即高吞吐和低延迟。</li>
<li>ByteBuffer的生命周期长且容量需求较大，会占用较多的内存空间。<br><img src="http://oirwmbp4e.bkt.clouddn.com/java/bytebuffer-choise1.jpg" alt="bytebuffer"></li>
</ul>
<p>看下代码，更直观一些</p>
<h3 id="HeapByteBuffer"><a href="#HeapByteBuffer" class="headerlink" title="HeapByteBuffer"></a>HeapByteBuffer</h3><p>分配在堆上的，直接由Java虚拟机负责垃圾收集，你可以把它想象成一个字节数组的包装类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">class HeapByteBuffer</div><div class="line">    extends ByteBuffer</div><div class="line">&#123;</div><div class="line">    HeapByteBuffer(int cap, int lim) &#123;            // package-private</div><div class="line"></div><div class="line">        super(-1, 0, lim, cap, new byte[cap], 0);</div><div class="line">        /*</div><div class="line">        hb = new byte[cap];</div><div class="line">        offset = 0;</div><div class="line">        */</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line">public abstract class ByteBuffer</div><div class="line">    extends Buffer</div><div class="line">    implements Comparable&lt;ByteBuffer&gt;</div><div class="line">&#123;</div><div class="line"></div><div class="line">    // These fields are declared here rather than in Heap-X-Buffer in order to</div><div class="line">    // reduce the number of virtual method invocations needed to access these</div><div class="line">    // values, which is especially costly when coding small buffers.</div><div class="line">    //</div><div class="line">    final byte[] hb;                  // Non-null only for heap buffers</div><div class="line">    final int offset;</div><div class="line">    boolean isReadOnly;                 // Valid only for heap buffers</div><div class="line"></div><div class="line">    // Creates a new buffer with the given mark, position, limit, capacity,</div><div class="line">    // backing array, and array offset</div><div class="line">    //</div><div class="line">    ByteBuffer(int mark, int pos, int lim, int cap,   // package-private</div><div class="line">                 byte[] hb, int offset)</div><div class="line">    &#123;</div><div class="line">        super(mark, pos, lim, cap);</div><div class="line">        this.hb = hb;</div><div class="line">        this.offset = offset;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="DirectByteBuffer"><a href="#DirectByteBuffer" class="headerlink" title="DirectByteBuffer"></a>DirectByteBuffer</h3><p>这个类就没有HeapByteBuffer简单了</p>
<p><strong>DirectByteBuffer结构</strong></p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/java/directbyebuffer-struts.png" alt="DirectByteBuffer结构"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">DirectByteBuffer(int cap) &#123;                   // package-private</div><div class="line"></div><div class="line">        super(-1, 0, cap, cap);</div><div class="line">        boolean pa = VM.isDirectMemoryPageAligned();</div><div class="line">        int ps = Bits.pageSize();</div><div class="line">        long size = Math.max(1L, (long)cap + (pa ? ps : 0));</div><div class="line">        Bits.reserveMemory(size, cap);</div><div class="line"></div><div class="line">        long base = 0;</div><div class="line">        try &#123;</div><div class="line">            base = unsafe.allocateMemory(size);</div><div class="line">        &#125; catch (OutOfMemoryError x) &#123;</div><div class="line">            Bits.unreserveMemory(size, cap);</div><div class="line">            throw x;</div><div class="line">        &#125;</div><div class="line">        unsafe.setMemory(base, size, (byte) 0);</div><div class="line">        if (pa &amp;&amp; (base % ps != 0)) &#123;</div><div class="line">            // Round up to page boundary</div><div class="line">            address = base + ps - (base &amp; (ps - 1));</div><div class="line">        &#125; else &#123;</div><div class="line">            address = base;</div><div class="line">        &#125;</div><div class="line">        cleaner = Cleaner.create(this, new Deallocator(base, size, cap));</div><div class="line">        att = null;</div></pre></td></tr></table></figure>
<p><strong>Bits.reserveMemory(size, cap) 方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">static void reserveMemory(long size, int cap) &#123;</div><div class="line">        synchronized (Bits.class) &#123;</div><div class="line">            if (!memoryLimitSet &amp;&amp; VM.isBooted()) &#123;</div><div class="line">                maxMemory = VM.maxDirectMemory();</div><div class="line">                memoryLimitSet = true;</div><div class="line">            &#125;</div><div class="line">            // -XX:MaxDirectMemorySize limits the total capacity rather than the</div><div class="line">            // actual memory usage, which will differ when buffers are page</div><div class="line">            // aligned.</div><div class="line">            if (cap &lt;= maxMemory - totalCapacity) &#123;</div><div class="line">                reservedMemory += size;</div><div class="line">                totalCapacity += cap;</div><div class="line">                count++;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.gc();</div><div class="line">        try &#123;</div><div class="line">            Thread.sleep(100);</div><div class="line">        &#125; catch (InterruptedException x) &#123;</div><div class="line">            // Restore interrupt status</div><div class="line">            Thread.currentThread().interrupt();</div><div class="line">        &#125;</div><div class="line">        synchronized (Bits.class) &#123;</div><div class="line">            if (totalCapacity + cap &gt; maxMemory)</div><div class="line">                throw new OutOfMemoryError(&quot;Direct buffer memory&quot;);</div><div class="line">            reservedMemory += size;</div><div class="line">            totalCapacity += cap;</div><div class="line">            count++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在DirectByteBuffer中，首先向Bits类申请额度，Bits类有一个全局的totalCapacity变量，记录着全部DirectByteBuffer的总大小，每次申请，都先看看是否超限,堆外内存的限额默认与堆内内存(由-Xmx 设定)相仿，可用 -XX:MaxDirectMemorySize 重新设定。</p>
<p>如果不指定，该参数的默认值为Xmx的值减去1个Survior区的值。</p>
<blockquote>
<p>如设置启动参数-Xmx20M -Xmn10M -XX：SurvivorRatio=8,那么申请20M-1M=19M的DirectMemory</p>
</blockquote>
<p>如果已经超限，会主动执行Sytem.gc()，期待能主动回收一点堆外内存。</p>
<blockquote>
<p>System.gc()会触发一个full gc，当然前提是你没有显示的设置-XX:+DisableExplicitGC来禁用显式GC。并且你需要知道，调用System.gc()并不能够保证full gc马上就能被执行。</p>
<p>所以在使用netty这类框架时，一定要注意JVM优化，如果DisableExplicitGC那就可能会OOM了</p>
</blockquote>
<p>然后休眠一百毫秒，看看totalCapacity降下来没有，如果内存还是不足，就抛出OOM异常。如果额度被批准，就调用大名鼎鼎的sun.misc.Unsafe去分配内存,返回内存基地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// Used only by direct buffers</div><div class="line">// NOTE: hoisted here for speed in JNI GetDirectBufferAddress</div><div class="line">long address;</div></pre></td></tr></table></figure></p>
<p>这样我们后面通过JNI对这个堆外内存操作时都是通过这个address来实现的了。</p>
<p>Unsafe的<a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/prims/unsafe.cpp#l583" target="_blank" rel="external">C++实现在此</a>，标准的malloc。然后再调一次Unsafe把这段内存给清零。跑个题，Unsafe的名字是提醒大家这个类只给Sun自家用的</p>
<p>JDK7开始，DirectByteBuffer分配内存时默认已不做分页对齐，不会再每次分配并清零实际需要＋分页大小(4k)的内存，这对性能应有较大提升，所以Oracle专门写在了<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/io/enhancements.html#jdk7" target="_blank" rel="external">Enhancements in Java I/O</a>里。</p>
<p>最后，创建一个Cleaner，并把代表清理动作的Deallocator类绑定 – 降低Bits里的totalCapacity，并调用Unsafe调free去释放内存。Cleaner的触发机制后面再说。</p>
<p>DirectByteBuffer中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">byte _get(int i) &#123;                          // package-private</div><div class="line">        return unsafe.getByte(address + i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">void _put(int i, byte b) &#123;                  // package-private</div><div class="line"></div><div class="line">    unsafe.putByte(address + i, b);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在前面我们说过，在linux中内核态的权限是最高的，那么在内核态的场景下，操作系统是可以访问任何一个内存区域的，所以操作系统是可以访问到Java堆的这个内存区域的。</p>
<p>Q：那为什么操作系统不直接访问Java堆内的内存区域了？</p>
<p>A：这是因为JNI方法访问的内存区域是一个已经确定了的内存区域地质，那么该内存地址指向的是Java堆内内存的话，那么如果在操作系统正在访问这个内存地址的时候，Java在这个时候进行了GC操作，而GC操作会涉及到数据的移动操作[GC经常会进行先标志在压缩的操作。即，将可回收的空间做标志，然后清空标志位置的内存，然后会进行一个压缩，压缩就会涉及到对象的移动，移动的目的是为了腾出一块更加完整、连续的内存空间，以容纳更大的新对象]，数据的移动会使JNI调用的数据错乱。所以JNI调用的内存是不能进行GC操作的，JNI不能直接访问Java堆内的内存区域</p>
<p>Q：如上面所说，JNI不能直接访问Java堆内的内存区域，那该如何解决了？</p>
<p>A：①堆内内存与堆外内存之间数据拷贝的方式(并且在将堆内内存拷贝到堆外内存的过程JVM会保证不会进行GC操作)：</p>
<p>比如我们要完成一个从文件中读数据到堆内内存的操作，即FileChannelImpl.read(HeapByteBuffer)。这里实际上File I/O会将数据读到堆外内存中，然后堆外内存再讲数据拷贝到堆内内存，这样我们就读到了文件中的内存。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public int read(ByteBuffer var1) throws IOException &#123;</div><div class="line">        this.ensureOpen();</div><div class="line">        if(!this.readable) &#123;</div><div class="line">            throw new NonReadableChannelException();</div><div class="line">        &#125; else &#123;</div><div class="line">            Object var2 = this.positionLock;</div><div class="line">            synchronized(this.positionLock) &#123;</div><div class="line">                int var3 = 0;</div><div class="line">                int var4 = -1;</div><div class="line"></div><div class="line">                try &#123;</div><div class="line">                    this.begin();</div><div class="line">                    var4 = this.threads.add();</div><div class="line">                    if(!this.isOpen()) &#123;</div><div class="line">                        byte var12 = 0;</div><div class="line">                        return var12;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        do &#123;</div><div class="line">                            //关键点在这行</div><div class="line">                            var3 = IOUtil.read(this.fd, var1, -1L, this.nd);</div><div class="line">                        &#125; while(var3 == -3 &amp;&amp; this.isOpen());</div><div class="line"></div><div class="line">                        int var5 = IOStatus.normalize(var3);</div><div class="line">                        return var5;</div><div class="line">                    &#125;</div><div class="line">                &#125; finally &#123;</div><div class="line">                    this.threads.remove(var4);</div><div class="line">                    this.end(var3 &gt; 0);</div><div class="line"></div><div class="line">                    assert IOStatus.check(var3);</div><div class="line"></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><em>IOUtil</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">static int read(FileDescriptor var0, ByteBuffer var1, long var2, NativeDispatcher var4) throws IOException &#123;</div><div class="line">        if (var1.isReadOnly()) &#123;</div><div class="line">            throw new IllegalArgumentException(&quot;Read-only buffer&quot;);</div><div class="line">        &#125; else if (var1 instanceof DirectBuffer) &#123;</div><div class="line">            return readIntoNativeBuffer(var0, var1, var2, var4);</div><div class="line">        &#125; else &#123;</div><div class="line">            // 分配临时的堆外内存</div><div class="line">            ByteBuffer var5 = Util.getTemporaryDirectBuffer(var1.remaining());</div><div class="line"> </div><div class="line">            int var7;</div><div class="line">            try &#123;</div><div class="line">                // File I/O 操作会将数据读入到堆外内存中</div><div class="line">                int var6 = readIntoNativeBuffer(var0, var5, var2, var4);</div><div class="line">                var5.flip();</div><div class="line">                if (var6 &gt; 0) &#123;</div><div class="line">                    // 将堆外内存的数据拷贝到堆内内存中</div><div class="line">                    var1.put(var5);</div><div class="line">                &#125;</div><div class="line"> </div><div class="line">                var7 = var6;</div><div class="line">            &#125; finally &#123;</div><div class="line">                // 里面会调用DirectBuffer.cleaner().clean()来释放临时的堆外内存</div><div class="line">                Util.offerFirstTemporaryDirectBuffer(var5);</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            return var7;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>而写操作则反之，我们会将堆内内存的数据线写到对堆外内存中，然后操作系统会将堆外内存的数据写入到文件中。</p>
<p>假设我们要从网络中读入一段数据，再把这段数据发送出去的话，采用Non-direct ByteBuffer的流程是这样的：</p>
<blockquote>
<p>网络 –&gt; 临时的Direct ByteBuffer –&gt; 应用 Non-direct ByteBuffer –&gt; 临时的Direct ByteBuffer –&gt; 网络</p>
</blockquote>
<p>② 直接使用堆外内存，如DirectByteBuffer：</p>
<p>这种方式是直接在堆外分配一个内存(即，native memory)来存储数据，<br>程序通过JNI直接将数据读/写到堆外内存中。因为数据直接写入到了堆外内存中，所以这种方式就不会再在JVM管控的堆内再分配内存来存储数据了，也就不存在堆内内存和堆外内存数据拷贝的操作了。这样在进行I/O操作时，只需要将这个堆外内存地址传给JNI的I/O的函数就好了。</p>
<p>采用Direct ByteBuffer的流程是这样的：</p>
<blockquote>
<p>网络 –&gt; 应用 Direct ByteBuffer –&gt; 网络</p>
</blockquote>
<p>可以看到，除开构造和析构临时Direct ByteBuffer的时间外，起码还能节约两次内存拷贝的时间。那么是否在任何情况下都采用Direct Buffer呢？</p>
<p>不是。对于大部分应用而言，两次内存拷贝的时间几乎可以忽略不计，而构造和析构DirectBuffer的时间却相对较长。在JVM的实现当中，某些方法会缓存一部分临时Direct ByteBuffer，意味着如果采用Direct ByteBuffer仅仅能节约掉两次内存拷贝的时间，<br>而无法节约构造和析构的时间。就用Sun的实现来说，write(ByteBuffer)和read(ByteBuffer)方法都会缓存临时Direct ByteBuffer，而write(ByteBuffer[])和read(ByteBuffer[])每次都生成新的临时Direct ByteBuffer。</p>
<p>根据这些区别，如下的建议：</p>
<ul>
<li>如果你做中小规模的应用（在这里，应用大小是按照使用ByteBuffer的次数和规模来做划分的），而且并不在乎这该死的细节问题，请选择Non-direct ByteBuffer</li>
<li>如果采用Direct ByteBuffer后性能并没有出现你所期待的变化，请选择Non-direct ByteBuffer</li>
<li>如果没有Direct ByteBuffer Pool，尽量不要使用Direct ByteBuffer</li>
<li>除非你确定该ByteBuffer会长时间存在，并且和外界有频繁交互，可采用Direct ByteBuffer</li>
<li>如果采用Non-direct ByteBuffer，那么采用非聚集(gather)的write/read(ByteBuffer)效果反而可能超出聚集的write/read(ByteBuffer[])，因为聚集的write/read的临时Direct ByteBuffer是非缓存的</li>
</ul>
<p>基本上，采用Non-direct ByteBuffer总是对的！因为内存拷贝需要的开销对大部分应用而言都可以忽略不计。</p>
<h2 id="ByteBuffer回收"><a href="#ByteBuffer回收" class="headerlink" title="ByteBuffer回收"></a>ByteBuffer回收</h2><p>HeapByteBuffer就不要说了，GC就帮忙处理了。这儿主要说下DirectByteBuffer</p>
<h3 id="基于GC回收DirectByteBuffer"><a href="#基于GC回收DirectByteBuffer" class="headerlink" title="基于GC回收DirectByteBuffer"></a>基于GC回收DirectByteBuffer</h3><p>存在于堆内的DirectByteBuffer对象很小，只存着基地址和大小等几个属性，和一个Cleaner，但它代表着后面所分配的一大段内存，是所谓的冰山对象。</p>
<p>在内存中基本是这样子<br><img src="http://oirwmbp4e.bkt.clouddn.com/java/off-heap-memory-before.png" alt="off-heap-memory"><br>其中first是Cleaner类的静态变量，Cleaner对象在初始化时会被添加到Clener链表中，和first形成引用关系，ReferenceQueue是用来保存需要回收的Cleaner对象。</p>
<p>如果该DirectByteBuffer对象在一次GC中被回收了<br><img src="http://oirwmbp4e.bkt.clouddn.com/java/off-heap-memory.png" alt="off-heap-memory"><br>此时，只有Cleaner对象唯一保存了堆外内存的数据（开始地址、大小和容量），在下一次Full GC时，把该Cleaner对象放入到ReferenceQueue中，并触发clean方法。</p>
<p>快速回顾一下堆内的GC机制，当新生代满了，就会发生young gc；如果此时对象还没失效，就不会被回收；撑过几次young gc后，对象被迁移到老生代；当老生代也满了，就会发生full gc。</p>
<p>这里可以看到一种尴尬的情况，因为DirectByteBuffer本身的个头很小，只要熬过了young gc，即使已经失效了也能在老生代里舒服的呆着，不容易把老生代撑爆触发full gc，如果没有别的大块头进入老生代触发full gc，就一直在那耗着，占着一大片堆外内存不释放。</p>
<p>这时，就只能靠前面提到的申请额度超限时触发的system.gc()来救场了。但这道最后的保险其实也不很好，首先它会中断整个进程，然后它让当前线程睡了整整一百毫秒，而且如果gc没在一百毫秒内完成，它仍然会无情的抛出OOM异常。还有，万一，万一大家迷信某个调优指南设置了-DisableExplicitGC禁止了system.gc()，那就不好玩了。</p>
<p>所以，堆外内存还是自己主动点回收更好，比如Netty就是这么做的</p>
<h3 id="主动回收DirectByteBuffer"><a href="#主动回收DirectByteBuffer" class="headerlink" title="主动回收DirectByteBuffer"></a>主动回收DirectByteBuffer</h3><p>对于Sun的JDK这其实很简单，只要从DirectByteBuffer里取出那个sun.misc.Cleaner，然后调用它的clean()就行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ByteBuffer byteBuffer = ByteBuffer.allocateDirect(1024 * 1024 * 500);</div><div class="line">((DirectBuffer)byteBuffer).cleaner().clean();</div></pre></td></tr></table></figure>
<p>前面说的，clean()执行时实际调用的是被绑定的Deallocator类，这个类可被重复执行，释放过了就不再释放。所以GC时再被动执行一次clean()也没所谓。</p>
<p>在Netty里，因为不确定跑在Sun的JDK里(比如安卓)，所以多废了些功夫来确定Cleaner的存在</p>
<h3 id="Cleaner类"><a href="#Cleaner类" class="headerlink" title="Cleaner类"></a>Cleaner类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class Cleaner extends PhantomReference&lt;Object&gt; &#123;</div><div class="line">    private static final ReferenceQueue&lt;Object&gt; dummyQueue = new ReferenceQueue();</div><div class="line">    private static Cleaner first = null;</div><div class="line">    private Cleaner next = null;</div><div class="line">    private Cleaner prev = null;</div><div class="line">    private final Runnable thunk;</div></pre></td></tr></table></figure>
<p>PhantomReference 这个虚引用类很少见，它是java中最弱的引用类型</p>
<blockquote>
<p>PhantomReference 类只能用于跟踪对被引用对象即将进行的收集。</p>
<p>同样，它还能用于执行 pre-mortem 清除操作。 PhantomReference 必须与 ReferenceQueue 类一起使用。需要 ReferenceQueue 是因为它能够充当通知机制。当垃圾收集器确定了某个对象是虚可及对象时， PhantomReference 对象就被放在它的 ReferenceQueue 上。将 PhantomReference 对象放在 ReferenceQueue 上也就是一个通知，表明 PhantomReference 对象引用的对象已经结束，可供收集了。这使您能够刚好在对象占用的内存被回收之前采取行动。</p>
</blockquote>
<p>当GC时发现它除了PhantomReference外已不可达（持有它的DirectByteBuffer失效了），就会把它放进 Reference类pending list静态变量里。然后另有一条ReferenceHandler线程，名字叫 “Reference Handler”的，关注着这个pending list，如果看到有对象类型是Cleaner，就会执行它的clean()，其他类型就放入应用构造Reference时传入的ReferenceQueue中，这样应用的代码可以从Queue里拖出这些理论上已死的对象，做爱做的事情——这是一种比finalizer更轻量更好的机制。</p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/java/cleaner.png" alt="cleaner"><br>比如创建DirectByteBuffer，会新建Cleaner对象，该对象添加到Cleaner链表中。<br>对象被GC，如果是Cleaner对象，则会执行该对象的clean方法,<br>Clean方法会将对应的cleaner对象从链表中移除，同时会回收DirectByteBuffer申请的资源</p>
<p>看下ReferenceHandler源码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">/* High-priority thread to enqueue pending References</div><div class="line">     */</div><div class="line">    private static class ReferenceHandler extends Thread &#123;</div><div class="line"></div><div class="line">        ReferenceHandler(ThreadGroup g, String name) &#123;</div><div class="line">            super(g, name);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void run() &#123;</div><div class="line">            for (;;) &#123;</div><div class="line">                Reference&lt;Object&gt; r;</div><div class="line">                synchronized (lock) &#123;</div><div class="line">                    if (pending != null) &#123;</div><div class="line">                        r = pending;</div><div class="line">                        pending = r.discovered;</div><div class="line">                        r.discovered = null;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        // The waiting on the lock may cause an OOME because it may try to allocate</div><div class="line">                        // exception objects, so also catch OOME here to avoid silent exit of the</div><div class="line">                        // reference handler thread.</div><div class="line">                        //</div><div class="line">                        // Explicitly define the order of the two exceptions we catch here</div><div class="line">                        // when waiting for the lock.</div><div class="line">                        //</div><div class="line">                        // We do not want to try to potentially load the InterruptedException class</div><div class="line">                        // (which would be done if this was its first use, and InterruptedException</div><div class="line">                        // were checked first) in this situation.</div><div class="line">                        //</div><div class="line">                        // This may lead to the VM not ever trying to load the InterruptedException</div><div class="line">                        // class again.</div><div class="line">                        try &#123;</div><div class="line">                            try &#123;</div><div class="line">                                lock.wait();</div><div class="line">                            &#125; catch (OutOfMemoryError x) &#123; &#125;</div><div class="line">                        &#125; catch (InterruptedException x) &#123; &#125;</div><div class="line">                        continue;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // Fast path for cleaners</div><div class="line">                if (r instanceof Cleaner) &#123;</div><div class="line">                    ((Cleaner)r).clean();</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                ReferenceQueue&lt;Object&gt; q = r.queue;</div><div class="line">                if (q != ReferenceQueue.NULL) q.enqueue(r);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><strong>回顾下Finalize回收</strong></p>
<p>sun不推荐实现finalize，实际上JDK内部很多类都实现了finalize。</p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/java/finalize.png" alt="finalize"></p>
<p>如果对象实现了finalize，在对象初始化后,会封装成Finalizer对象添加到 Finalizer链表中。</p>
<p>对象被GC时，如果是Finalizer对象，会将对象赋值到pending对象。Reference Handler线程会将pending对象push到queue中。</p>
<p>Finalizer线程poll到对象，先删除掉Finalizer链表中对应的对象，然后再执行对象的finalize方法(一般为资源的销毁)</p>
<p>方案的缺点：</p>
<ol>
<li>对象至少跨越2个GC，垃圾对象无法及时被GC掉，并且存在多次拷贝。影响YGC和FGC</li>
<li>Finalizer线程优先级较低，会导致finalize方法延迟执行</li>
</ol>
<h1 id="开源堆外缓存框架"><a href="#开源堆外缓存框架" class="headerlink" title="开源堆外缓存框架"></a>开源堆外缓存框架</h1><ul>
<li>Ehcache 3.0：3.0基于其商业公司一个非开源的堆外组件的实现。</li>
<li>Chronical Map：OpenHFT包括很多类库，使用这些类库很少产生垃圾，并且应用程序使用这些类库后也很少发生Minor GC。类库主要包括：Chronicle Map，Chronicle Queue等等。</li>
<li>OHC：来源于Cassandra 3.0， Apache v2。</li>
<li>Ignite: 一个规模宏大的内存计算框架，属于Apache项目。</li>
</ul>
<h2 id="OHC"><a href="#OHC" class="headerlink" title="OHC"></a>OHC</h2><p>DirectByteBuffer是使用unsafe(JNI)申请堆外空间(unsafe.allocateMemory(size))。还有一种申请堆外空间的手段：JNA。</p>
<p>JNA的描述(<a href="https://github.com/java-native-access/jna" target="_blank" rel="external">https://github.com/java-native-access/jna</a>)</p>
<p>JNA provides Java programs easy access to native shared libraries without writing anything but Java code - no JNI or native code is required</p>
<p>堆外缓存OHC便是使用JNA来申请堆外空间。</p>
<p>线下测试：JNA内存申请的性能是unsafe（JNI）的2倍。</p>
<h3 id="Why-not-use-ByteBuffer-allocateDirect"><a href="#Why-not-use-ByteBuffer-allocateDirect" class="headerlink" title="Why not use ByteBuffer.allocateDirect()?"></a>Why not use ByteBuffer.allocateDirect()?</h3><blockquote>
<p>TL;DR allocating off-heap memory directly and bypassing ByteBuffer.allocateDirect is very gentle to the GC and we have explicit control over memory allocation and, more importantly, free. The stock implementation in Java frees off-heap memory during a garbage collection - also: if no more off-heap memory is available, it likely triggers a Full-GC, which is problematic if multiple threads run into that situation concurrently since it means lots of Full-GCs sequentially. Further, the stock implementation uses a global, synchronized linked list to track off-heap memory allocations.</p>
<p>This is why OHC allocates off-heap memory directly and recommends to preload jemalloc on Linux systems to improve memory managment performance.</p>
</blockquote>
<p>这是OHC的wiki说明</p>
<p>其实OHC实现了JNI(malloc),JNA(jemalloc)两种方式，默认使用了JNA(jemalloc),性能的提升最关键的是malloc与jemalloc的区别了</p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/off-heap/allocator.png" alt="ohc-allocator"></p>
<p>在org.caffinitas.ohc.chunked.Uns类中，创建IAllocator类片段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">private static final String __ALLOCATOR = System.getProperty(OHCacheBuilder.SYSTEM_PROPERTY_PREFIX + &quot;allocator&quot;);</div><div class="line"></div><div class="line">IAllocator alloc;</div><div class="line">            String allocType = __ALLOCATOR != null ? __ALLOCATOR : &quot;jna&quot;;</div><div class="line">            switch (allocType)</div><div class="line">            &#123;</div><div class="line">                case &quot;unsafe&quot;:</div><div class="line">                    alloc = new UnsafeAllocator();</div><div class="line">                    LOGGER.info(&quot;OHC using sun.misc.Unsafe memory allocation&quot;);</div><div class="line">                    break;</div><div class="line">                case &quot;jna&quot;:</div><div class="line">                default:</div><div class="line">                    alloc = new JNANativeAllocator();</div><div class="line">                    LOGGER.info(&quot;OHC using JNA OS native malloc/free&quot;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            allocator = alloc;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>UnsafeAllocator<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Field field = sun.misc.Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</div><div class="line">field.setAccessible(true);</div><div class="line">unsafe = (sun.misc.Unsafe) field.get(null);</div><div class="line">            </div><div class="line">            </div><div class="line">public long allocate(long size)</div><div class="line">    &#123;</div><div class="line">        try</div><div class="line">        &#123;</div><div class="line">            return unsafe.allocateMemory(size);</div><div class="line">        &#125;</div><div class="line">        catch (OutOfMemoryError oom)</div><div class="line">        &#123;</div><div class="line">            return 0L;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>JNANativeAllocator<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public long allocate(long size)</div><div class="line">    &#123;</div><div class="line">        try</div><div class="line">        &#123;</div><div class="line">            return Native.malloc(size);</div><div class="line">        &#125;</div><div class="line">        catch (OutOfMemoryError oom)</div><div class="line">        &#123;</div><div class="line">            return 0L;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>OHC这只是一个开端，只是分配内存部分，它还有淘汰策略等等，之后说缓存时，再谈了</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://calvin1978.blogcn.com/articles/directbytebuffer.html" target="_blank" rel="external">Netty之Java堆外内存扫盲贴</a></p>
<p><a href="https://yq.aliyun.com/articles/66875" target="_blank" rel="external">千丝万缕的FGC与Buffer pool</a></p>
<p><a href="https://yq.aliyun.com/articles/2948" target="_blank" rel="external">JVM源码分析之堆外内存完全解读</a></p>
<p><a href="http://www.infoq.com/cn/articles/jvm-source-code-analysis-finalreference" target="_blank" rel="external">JVM源码分析之FinalReference完全解读</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      
      <! -- 添加微信图标 -->
    
    
    
    

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zhuxingsheng.github.io/2017/12/17/kung-fu-is-outside-the-poem/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="朱兴生">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/6222636?v=3&s=460">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="码农戏码">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="码农戏码" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/17/kung-fu-is-outside-the-poem/" itemprop="url">
                  功夫在诗外
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-17T21:00:17+08:00">
                2017-12-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/书/" itemprop="url" rel="index">
                    <span itemprop="name">书</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          
	
	  
	  <span class="post-letters-count">
	    &nbsp; | &nbsp;
	    <span>1,584 字</span>
	    &nbsp; | &nbsp;
	    <span>5 min</span>
	  </span>
	  

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="功夫在诗外"><a href="#功夫在诗外" class="headerlink" title="功夫在诗外"></a>功夫在诗外</h1><p>算是对今年，以及去年这两年的读书的一点思考，总结</p>
<p>为什么会有去年，因为今年读书过程中，让人不自然地想起了去年的类似内容。说的书类型不重复，但出现了很多相同的内容</p>
<p>可能与这些内容有缘分</p>
<h1 id="迷思"><a href="#迷思" class="headerlink" title="迷思"></a>迷思</h1><p>每次跳槽的时候，都会去思考我的核心竞争力到底是什么？这个问题代表了两个对立的思想一方面代表了不自知，迷茫，对未来的焦虑；另一方面代表了自不知，三人有我师，前进的动力。</p>
<p>职场规划一片迷茫，股票所学也是一无长进，甚是苦恼。<br>想起了陆游的这句话，《汝果欲学诗，功夫在诗外》；所以去年开始读了很多与专业不相关的书籍。</p>
<p>名人传记，历史书籍，小说，这类书的价值在于引导成长；</p>
<p>心智，心理类也是所好，可惜所得甚少。一些书籍还得多读，多思</p>
<p>如《乌合之众》，知了很多年，却没读得很少，也没读懂。</p>
<p>路漫漫其修远兮</p>
<h1 id="所得"><a href="#所得" class="headerlink" title="所得"></a>所得</h1><p>在读《超级交易者》上半段时，突然有了一细细恍惚。好些内容都似曾相识，让人不得不想起一句老话，失败者的失败各有各的不同，而成功者的成功却具有惊人的相似之处。</p>
<h2 id="责任"><a href="#责任" class="headerlink" title="责任"></a>责任</h2><p>这个词就像是个空词，人人都会把这个词挂在嘴边，但何为责任，责任有何妙处</p>
<p>这在《人生五章》诗中也有体现</p>
<p>《人生五章》 </p>
<p>1、 </p>
<p>我走上街， </p>
<p>人行道上有一个深洞， </p>
<p>我掉了进去。 </p>
<p>我迷失了……我绝望了。 </p>
<p>这不是我的错， </p>
<p>费了好大的劲才爬出来。 </p>
<p>2、 </p>
<p>我走上同一条街。 </p>
<p>人行道上有一个深洞， </p>
<p>我假装没看到， </p>
<p>还是掉了进去。 </p>
<p>我不能相信我居然会掉在同样的地方。 </p>
<p>但这不是我的错。 </p>
<p>还是花了很长的时间才爬出来。 </p>
<p>3、 </p>
<p>我走上同一条街。 </p>
<p>人行道上有一个深洞， </p>
<p>我看到它在那儿， </p>
<p>但还是掉了进去…… </p>
<p>这是一种习惯。 </p>
<p>我的眼睛张开着， </p>
<p>我知道我在那儿。 </p>
<p>这是我的错。 </p>
<p>我立刻爬了出来。 </p>
<p>4、 </p>
<p>我走上同一条街， </p>
<p>人行道上有一个深洞， </p>
<p>我绕道而过。 </p>
<p>5、 </p>
<p>我走上另一条街。</p>
<p>这首诗的内容在读《股票作手加快录》时，就有体会，大意就是一个人从意识到自身问题，到要改变，再到彻底改变的过程是相当艰辛的，习惯上升到性格再到内质的人性，是相当难以改变的。</p>
<p>这一切的改变，自省的起始就在于责任两字，无责任怎么会想到自身问题。</p>
<p>自己永无过错，一切都是别人的问题；代码没问题，是环境问题，自己买卖没问题，是庄家问题。</p>
<h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><p>为什么写作？其实有各种理由</p>
<ul>
<li>文字可以重塑人</li>
<li>写作是与自己的对话，引人思考</li>
<li>输出倒逼输入</li>
<li>形成闭环，输入输出完整的IO系统</li>
<li>写作是睡后收入</li>
</ul>
<p>我算是写作的践行者，有什么意义呢？写作了很多年，有什么益处呢？</p>
<p>之前我是记录时间日志，是在看《时间就是朋友》这本书得来的。</p>
<p>后来李笑来又说要记注意力日志。还没有太多的实践，从时间开销日志来讲，只是发现了自我的浪费时间，这也算是所得之一吧。</p>
<p>从去年开始写博客，为什么要写呢？关键是“形成有效的输入输出系统，以输出倒逼输入”，“写作也记录下学习过程，防止狗咬尾巴”。</p>
<p>现在的博客目标是每篇文章写尽一个知识点，有广度，也得有深度。但任何知识都不是单点，‘台上一分钟，台下十年功’，‘冰山理论’。</p>
<p>晨写也没有以前的质量和数量了，上次交易玫瑰讲了量化：一是两张A4纸，二是得有三十分钟。</p>
<p>还有关键一点，我也疏忽的一点，<strong>没有及时回顾日记。需要温故知新。</strong></p>
<h2 id="冥想"><a href="#冥想" class="headerlink" title="冥想"></a>冥想</h2><p>这个之前实践了几天，后来也没有坚持。这以后还是得有空多练习，看看效果了</p>
<h2 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h2><p>很多人的理想生活就是 读万卷书，行万里路</p>
<p>我现在的读书方法，以及读书效果还是很差，不让人满意。关键是缺少总结，一本书，至少要自己组织语言总结其主旨。</p>
<p>不然读再多的书，还是一无所得，浪费时间，自我心理满足。不能学以致用。</p>
<p>上次读李笑来的财富自由之路，一个读书亮点：慢读。</p>
<p>现在很多的书籍都教人快速阅读以应对当代快速膨胀的知识，以快致胜。而李笑来提出，要慢读。</p>
<p>快速膨胀的是信息，而不是知识。知识的出现需要很久的时间积累。所以要慢读，要有深度，现在流行快餐文化，让世人缺少了深度思考的过程，以致人浮于思，任何事都没有深度，人云亦云。</p>
<h1 id="导图"><a href="#导图" class="headerlink" title="导图"></a>导图</h1><p>对于以上所得共同点，画了张思维导图更能一目了然</p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/book/%E5%8A%9F%E5%A4%AB%E5%9C%A8%E8%AF%97%E5%A4%96.png" alt="image"></p>
<h1 id="书单"><a href="#书单" class="headerlink" title="书单"></a>书单</h1><p>这些书单是今年看过超出一半内容的书籍，有几本是年初读的，现在都已经忘记内容了。主要就是没有写一段自己理解的总结。这些书，明年还会再读，重读。吸取知识的能力实在是差。</p>
<p>《西藏生死书》</p>
<p>《刻意练习》</p>
<p>《简单思考》</p>
<p>《自卑与超越》</p>
<p>《超级交易员》</p>
<p>《我做散户这十年：三万赚到千万》</p>
<p>《走进我的交易室》</p>
<p>《炒股的智慧》</p>
<p>《红尘天幕》</p>
<p>今年没有达到目标，计划是一个月一本的，不找客观原因，明年还得继续努力。育儿方面的内容也得加强。</p>
<p>今年的博客也是打算一月一篇的，也没有正常发布。</p>
<p>计划是用来执行的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      
      <! -- 添加微信图标 -->
    
    
    
    

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zhuxingsheng.github.io/2017/12/17/git-multi-acount-management-sh-key/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="朱兴生">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/6222636?v=3&s=460">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="码农戏码">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="码农戏码" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/17/git-multi-acount-management-sh-key/" itemprop="url">
                  git多账户管理SSH Key
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-17T10:06:01+08:00">
                2017-12-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tools/" itemprop="url" rel="index">
                    <span itemprop="name">tools</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          
	
	  
	  <span class="post-letters-count">
	    &nbsp; | &nbsp;
	    <span>731 字</span>
	    &nbsp; | &nbsp;
	    <span>3 min</span>
	  </span>
	  

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>由于公司团队使用 GitLab 来托管代码，同时，个人在 Github 上还有一些代码仓库，可公司邮箱与个人邮箱是不同的，由此产生的 SSH key 也是不同的，这就造成了冲突 ，文章提供此类问题的解决方案：如何在一台机器上面同时使用 Github 与 Gitlab 的服务？</p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>原理上就是对 SSH 协议配置 config 文件，对不同的域名采用不同的认证密钥</p>
<ol>
<li>生成 ssh key 上传到 Github/Gitlab<br>ssh key 默认生成后保存在 ~/.ssh/目录下 ，默认为 id_rsa 和 id_rsa.pub 两个文件，由于我们需要分开配置，所以这么做：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 生成公钥、密钥的同时指定文件名，Gitlab使用</div><div class="line">ssh-keygen -t rsa -f ~/.ssh/id_rsa.gitlab -C &quot;xirong.liu@corp.xxx.com&quot;</div><div class="line"># 生成默认，Github使用</div><div class="line">ssh-keygen -t rsa -C &quot;ixirong.liu@gmail.com&quot;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>命令执行完成后，这时~/.ssh目录下会多出id_rsa.gitlab和id_rsa.gitlab.pub两个文件，id_rsa.gitlab.pub 里保存的就是我们要使用的key，这个key就是用来上传到 Gitlab上的。</p>
<p><strong>以Github为例，过程如下：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">登录github</div><div class="line">点击右上方的Accounting settings图标</div><div class="line">选择 SSH key</div><div class="line">点击 Add SSH key</div><div class="line">在出现的界面中填写SSH key的名称，填一个你自己喜欢的名称即可，然后将上面拷贝的~/.ssh/id_rsa.pub文件内容粘帖到key一栏，在点击“add key”按钮就可以了。</div></pre></td></tr></table></figure></p>
<p>添加过程github会提示你输入一次你的github密码 ，确认后即添加完毕。 </p>
<ol>
<li>配置 config 文件<br>在 ~/.ssh目录下，如果不存在，则新建 touch ~/.ssh/config文件</li>
</ol>
<p>配置文件说明：<br>每个账号单独配置一个Host，每个Host要取一个别名，每个Host主要配置HostName和IdentityFile两个属性即可<br>Host的名字可以取为自己喜欢的名字，不过这个会影响git相关命令<br>例如：<br>Host mygithub 这样定义的话，命令如下，即git@后面紧跟的名字改为mygithub<br>git clone git@mygithub:PopFisher/AndroidRotateAnim.git<br>就相当于你配置的HostName真正的域名，映射成了Host后面的配置的名字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HostName                      #这个是真实的域名地址</div><div class="line">IdentityFile                  #这里是id_rsa的地址</div><div class="line">PreferredAuthentications      #配置登录时用什么权限认证--可设置publickey,password publickey,keyboard-interactive等</div><div class="line">User                          #配置使用用户名</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># gitlab</div><div class="line">Host gitool.glanway.com</div><div class="line">HostName gitool.glanway.com</div><div class="line">PreferredAuthentications publickey</div><div class="line">IdentityFile ~/.ssh/id_rsa_gitlab</div><div class="line">User yangjie</div><div class="line"></div><div class="line"># github</div><div class="line">Host github.com</div><div class="line">HostName github.com</div><div class="line">PreferredAuthentications publickey</div><div class="line">IdentityFile ~/.ssh/id_rsa_github</div><div class="line">User yangjie</div></pre></td></tr></table></figure>
<p>也可以使用适配符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Host *.corp.xxx.com</div><div class="line">     IdentityFile ~/.ssh/id_rsa.gitlab</div><div class="line">     User xirong.liu</div></pre></td></tr></table></figure></p>
<p>配置完成后，符合 *.corp.xxx.com后缀的 Git 仓库，均采取~/.ssh/id_rsa.gitlab 密钥进行验证，其它的采取默认的。</p>
<ol>
<li>验证是否OK<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜  ~  ssh -T git@github.com</div><div class="line">Hi xirong! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</div><div class="line">➜  ~  ssh -T git@gitlab.dev</div><div class="line">Welcome to GitLab, xirong.liu!</div></pre></td></tr></table></figure>
</li>
</ol>
<p>看到这些 Welcome 信息，说明就是 OK的了。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.ixirong.com/2015/07/29/how-to-use-github-gitlab-together/" target="_blank" rel="external">http://www.ixirong.com/2015/07/29/how-to-use-github-gitlab-together/</a></p>
<p><a href="http://www.jianshu.com/p/a3b4f61d4747" target="_blank" rel="external">http://www.jianshu.com/p/a3b4f61d4747</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      
      <! -- 添加微信图标 -->
    
    
    
    

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zhuxingsheng.github.io/2017/11/15/monitoring-of-micro-service/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="朱兴生">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/6222636?v=3&s=460">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="码农戏码">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="码农戏码" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/15/monitoring-of-micro-service/" itemprop="url">
                  微服务之监控
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-15T20:56:08+08:00">
                2017-11-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/微服务/" itemprop="url" rel="index">
                    <span itemprop="name">微服务</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          
	
	  
	  <span class="post-letters-count">
	    &nbsp; | &nbsp;
	    <span>1,857 字</span>
	    &nbsp; | &nbsp;
	    <span>6 min</span>
	  </span>
	  

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇其实本来也打算放在《常识》系列中的，介绍一下分布式日志追踪系统，这在互联网界理论，技术，产品已经很成熟，国内外各大厂都有自己成熟的产品。是个不错的互联网门外汉科普知识点</p>
<p>微服务，已经火了多年，也已经落地实施。对服务的监控需求顺理成章。监控系统的本质其实也就是分布式日志追踪系统。就归类到《微服务》系列中吧</p>
<p>本篇大体内容</p>
<ol>
<li>《微服务设计》第八章监控</li>
<li>监控理念Dapper</li>
<li>流行监控框架架构</li>
<li>aspectj</li>
</ol>
<h1 id="《微服务》之监控"><a href="#《微服务》之监控" class="headerlink" title="《微服务》之监控"></a>《微服务》之监控</h1><p>本来是说，要写个读书笔记的，但没有那么多完整的时间，正好学习监控，就把书拿出来，一并读了。理论结合实践，效果更好。</p>
<h2 id="监控模型"><a href="#监控模型" class="headerlink" title="监控模型"></a>监控模型</h2><p>三种监控模型</p>
<ol>
<li>单一服务，单一服务器</li>
<li>单一服务，多个服务器</li>
<li>多个服务，多个服务器</li>
</ol>
          <!--noindex-->
          <div class="post-more-link text-center">
            <a class="btn" href="/2017/11/15/monitoring-of-micro-service/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      
      <! -- 添加微信图标 -->
    
    
    
    

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zhuxingsheng.github.io/2017/10/10/spring-transaction/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="朱兴生">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/6222636?v=3&s=460">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="码农戏码">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="码农戏码" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/10/spring-transaction/" itemprop="url">
                  Spring事务
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-10T21:31:30+08:00">
                2017-10-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码解读/" itemprop="url" rel="index">
                    <span itemprop="name">源码解读</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          
	
	  
	  <span class="post-letters-count">
	    &nbsp; | &nbsp;
	    <span>9,010 字</span>
	    &nbsp; | &nbsp;
	    <span>35 min</span>
	  </span>
	  

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇其实也要归纳到《常识》系列中，但这重点又是spring的介绍，故归档在spring系列中。</p>
<p>工作很多年，除了学生时代学过，事务还真没有用过。过去开发游戏时，完全不用事务；现在互联网开发，也没有使用事务的场景，不要见怪。</p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>对于事务(Transaction)的概念，网上有各种版本，大同小异，</p>
<p>事务就是是由一系列对系统中数据进行读写的操作组成的一个程序执行单元，狭义上的事务特指数据库事务。</p>
<p>事务是一系列的动作，它们综合在一起才是一个完整的工作单元，这些动作必须全部完成，如果有一个失败的话，那么事务就会回滚到最开始的状态，仿佛什么都没发生过一样。 </p>
<p>在企业级应用程序开发中，事务管理必不可少的技术，用来确保数据的完整性和一致性。 </p>
<p>比如你去ATM机取1000块钱，大体有两个步骤：首先输入密码金额，银行卡扣掉1000元钱；然后ATM出1000元钱。这两个步骤必须是要么都执行要么都不执行。如果银行卡扣除了1000块但是ATM出钱失败的话，你将会损失1000元；如果银行卡扣钱失败但是ATM却出了1000块，那么银行将损失1000元。所以，如果一个步骤成功另一个步骤失败对双方都不是好事，如果不管哪一个步骤失败了以后，整个取钱过程都能回滚，也就是完全取消所有操作的话，这对双方都是极好的。 </p>
<h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><p>大名鼎鼎的ACID</p>
<ol>
<li>原子性（Atomicity），事务必须是一个原子的操作序列单元，一次事务只允许存在两种状态，全部成功或全部失败，任何一个操作失败都将导致整个事务失败</li>
<li>一致性（Consistency），事务的执行不能破坏系统数据的完整性和一致性，如果未完成的事务对系统数据的修改有一部分已经写入物理数据库，这时系统数据就处于不一致状态</li>
<li>隔离性（Isolation），在并发环境中，不同的事务操作相同的数据时，虚相互隔离不能相互干扰</li>
<li>持久性（Durability），事务一旦提交，对系统数据的变更就应该是永久的，必须被永久保存下来，即使服务器宕机了，只要数据库能够重新启动，就一定能够恢复到事务成功结束时的状态</li>
</ol>
<h2 id="事务并发处理问题"><a href="#事务并发处理问题" class="headerlink" title="事务并发处理问题"></a>事务并发处理问题</h2><p>如果没有锁定且多个用户同时访问一个数据库，则当他们的事务同时使用相同的数据时可能会发生问题。由于并发操作带来的数据不一致性包括：丢失数据修改、读”脏”数据（脏读）、不可重复读、产生幽灵数据：</p>
<p>假设数据库中有如下一张表：</p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/transaction/data.png" alt="image"></p>
<h3 id="第一类丢失更新-lost-update"><a href="#第一类丢失更新-lost-update" class="headerlink" title="第一类丢失更新(lost update)"></a>第一类丢失更新(lost update)</h3><p><strong>回滚丢失</strong></p>
<p>在完全未隔离事务的情况下，两个事物更新同一条数据资源，某一事物异常终止，回滚造成第一个完成的更新也同时丢失。<br><img src="http://oirwmbp4e.bkt.clouddn.com/transaction/lostupdate.png" alt="image"></p>
<p>在T1时刻开启了事务1，T2时刻开启了事务2，</p>
<p>在T3时刻事务1从数据库中取出了id=”402881e535194b8f0135194b91310001”的数据，</p>
<p>T4时刻事务2取出了同一条数据，</p>
<p>T5时刻事务1将age字段值更新为30，</p>
<p>T6时刻事务2更新age为35并提交了数据，</p>
<p>但是T7事务1回滚了事务age最后的值依然为20，事务2的更新丢失了，</p>
<p>这种情况就叫做”第一类丢失更新(lost update)”。</p>
<h3 id="脏读-dirty-read"><a href="#脏读-dirty-read" class="headerlink" title="脏读(dirty read)"></a>脏读(dirty read)</h3><p><strong>事务没提交，提前读取</strong></p>
<p>如果第二个事务查询到第一个事务还未提交的更新数据，形成脏读<br><img src="http://oirwmbp4e.bkt.clouddn.com/transaction/dirtyread.png" alt="image"></p>
<p>在T1时刻开启了事务1，T2时刻开启了事务2，</p>
<p>在T3时刻事务1从数据库中取出了id=”402881e535194b8f0135194b91310001”的数据，</p>
<p>在T5时刻事务1将age的值更新为30，但是事务还未提交，</p>
<p>T6时刻事务2读取同一条记录，获得age的值为30，但是事务1还未提交，</p>
<p>若在T7时刻事务1回滚了事务2的数据就是错误的数据(脏数据)，</p>
<p>这种情况叫做” 脏读(dirty read)”。</p>
<h3 id="虚读-phantom-read"><a href="#虚读-phantom-read" class="headerlink" title="虚读(phantom read)"></a>虚读(phantom read)</h3><p>一个事务执行两次查询，第二次结果集包含第一次中没有或者某些行已被删除，造成两次结果不一致，只是另一个事务在这两次查询中间插入或者删除了数据造成的</p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/transaction/phantomread.png" alt="image"></p>
<p>在T1时刻开启了事务1，T2时刻开启了事务2，</p>
<p>T3时刻事务1从数据库中查询所有记录，记录总共有一条，</p>
<p>T4时刻事务2向数据库中插入一条记录，T6时刻事务2提交事务。</p>
<p>T7事务1再次查询数据数据时，记录变成两条了。</p>
<p>这种情况是”虚读(phantom read)”。</p>
<h3 id="不可重复读-unrepeated-read"><a href="#不可重复读-unrepeated-read" class="headerlink" title="不可重复读(unrepeated read)"></a>不可重复读(unrepeated read)</h3><p>一个事务两次读取同一行数据，结果得到不同状态结果，如中间正好另一个事务更新了该数据，两次结果相异，不可信任<br><img src="http://oirwmbp4e.bkt.clouddn.com/transaction/unrepeatedread.png" alt="image"></p>
<p>在T1时刻开启了事务1，T2时刻开启了事务2，</p>
<p>在T3时刻事务1从数据库中取出了id=”402881e535194b8f0135194b91310001”的数据，此时age=20，</p>
<p>T4时刻事务2查询同一条数据，</p>
<p>T5事务2更新数据age=30，T6时刻事务2提交事务，</p>
<p>T7事务1查询同一条数据，发现数据与第一次不一致。</p>
<p>这种情况就是”不可重复读(unrepeated read)”</p>
<h3 id="第二类丢失更新-second-lost-updates"><a href="#第二类丢失更新-second-lost-updates" class="headerlink" title="第二类丢失更新(second lost updates)"></a>第二类丢失更新(second lost updates)</h3><p><strong>覆盖丢失</strong></p>
<p>不可重复读的特殊情况，如果两个事务都读取同一行，然后两个都进行写操作，并提交，第一个事务所做的改变就会丢失。</p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/transaction/secondlostupdates.png" alt="image"></p>
<p>在T1时刻开启了事务1，T2时刻开启了事务2，</p>
<p>T3时刻事务1更新数据age=25，</p>
<p>T5时刻事务2更新数据age=30，</p>
<p>T6时刻提交事务，</p>
<p>T7时刻事务2提交事务，把事务1的更新覆盖了。</p>
<p>这种情况就是”第二类丢失更新(second lost updates)”。</p>
<h2 id="并发问题总结"><a href="#并发问题总结" class="headerlink" title="并发问题总结"></a>并发问题总结</h2><p>不可重复读的重点是修改 : </p>
<p>同样的条件 ,   你读取过的数据 ,   再次读取出来发现值不一样了 </p>
<p>幻读的重点在于新增或者删除 </p>
<p>同样的条件 ,   第 1 次和第 2 次读出来的记录数不一样 </p>
<p>第一类更新丢失(回滚丢失)</p>
<p>第二类更新丢失(覆盖丢失)</p>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>解决并发问题的途径是什么?答案是：采取有效的隔离机制。怎样实现事务的隔离呢？隔离机制的实现必须使用锁</p>
<p>一般在编程的时候只需要设置隔离等级</p>
<p>数据库系统提供四种事务隔离级别：</p>
<ol>
<li>未提交读（READ UNCOMMITTED ）</li>
</ol>
<p>最低隔离级别，一个事务能读取到别的事务未提交的更新数据，很不安全，可能出现丢失更新、脏读、不可重复读、幻读；</p>
<ol>
<li>提交读（READ COMMITTED）</li>
</ol>
<p>一个事务能读取到别的事务提交的更新数据，不能看到未提交的更新数据，不会出现丢失更新、脏读，但可能出现不可重复读、幻读；</p>
<ol>
<li>可重复读（REPEATABLE READ）</li>
</ol>
<p>保证同一事务中先后执行的多次查询将返回同一结果，不受其他事务影响，不可能出现丢失更新、脏读、不可重复读，但可能出现幻读；</p>
<ol>
<li>序列化（SERIALIZABLE）</li>
</ol>
<p>最高隔离级别，不允许事务并发执行，而必须串行化执行，最安全，不可能出现更新、脏读、不可重复读、幻读，但是效率最低。</p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/transaction/isolation.jpg" alt="image"></p>
<p>隔离级别越高，数据库事务并发执行性能越差，能处理的操作越少。<br>所以一般地，推荐使用REPEATABLE READ级别保证数据的读一致性。<br>对于幻读的问题，可以通过加锁来防止</p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/transaction/isolation-phr.png" alt="image"></p>
<p>MySQL支持这四种事务等级，默认事务隔离级别是REPEATABLE READ。</p>
<p>Oracle数据库支持READ COMMITTED 和 SERIALIZABLE这两种事务隔离级别，<br>所以Oracle数据库不支持脏读</p>
<p>Oracle数据库默认的事务隔离级别是READ COMMITTED</p>
<p>不可重复读和幻读的区别是，不可重复读对应的表的操作是更改(UPDATE)，而幻读对应的表的操作是插入(INSERT)，两种的应对策略不一样。对于不可重复读，只需要采用行级锁防止该记录被更新即可，而对于幻读必须加个表级锁，防止在表中插入数据</p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="乐观锁-Optimistic-Lock-和悲观锁-Pessimistic-Lock"><a href="#乐观锁-Optimistic-Lock-和悲观锁-Pessimistic-Lock" class="headerlink" title="乐观锁(Optimistic Lock)和悲观锁(Pessimistic Lock)"></a>乐观锁(Optimistic Lock)和悲观锁(Pessimistic Lock)</h4><p>最重要的分类就是乐观锁(Optimistic Lock)和悲观锁(Pessimistic Lock)，这实际上是两种锁策略</p>
<p><strong>乐观锁</strong>，顾名思义就是非常乐观，非常相信真善美，每次去读数据都认为其它事务没有在写数据，所以就不上锁，快乐的读取数据，而只在提交数据的时候判断其它事务是否搞过这个数据了，如果搞过就rollback。乐观锁相当于一种检测冲突的手段，可通过为记录添加版本或添加时间戳来实现。</p>
<p><strong>悲观锁</strong>，对其它事务抱有保守的态度，每次去读数据都认为其它事务想要作祟，所以每次读数据的时候都会上锁，直到取出数据。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性，但随之而来的是各种开销。悲观锁相当于一种避免冲突的手段。</p>
<p><em>选择标准</em>：如果并发量不大，或数据冲突的后果不严重，则可以使用乐观锁；而如果并发量大或数据冲突后果比较严重（对用户不友好），那么就使用悲观锁。</p>
<h4 id="分共享锁（S锁，Shared-Lock）和排他锁（X锁，Exclusive-Lock）"><a href="#分共享锁（S锁，Shared-Lock）和排他锁（X锁，Exclusive-Lock）" class="headerlink" title="分共享锁（S锁，Shared Lock）和排他锁（X锁，Exclusive Lock）"></a>分共享锁（S锁，Shared Lock）和排他锁（X锁，Exclusive Lock）</h4><p>从读写角度，分共享锁（S锁，Shared Lock）和排他锁（X锁，Exclusive Lock），也叫读锁（Read Lock）和写锁（Write Lock）。<br>理解：</p>
<p>持有S锁的事务只读不可写。</p>
<p>如果事务A对数据D加上S锁后，其它事务只能对D加上S锁而不能加X锁。</p>
<p>持有X锁的事务可读可写。</p>
<p>如果事务A对数据D加上X锁后，其它事务不能再对D加锁，直到A对D的锁解除。</p>
<h4 id="表级锁（Table-Lock）和行级锁（Row-Lock）"><a href="#表级锁（Table-Lock）和行级锁（Row-Lock）" class="headerlink" title="表级锁（Table Lock）和行级锁（Row Lock）"></a>表级锁（Table Lock）和行级锁（Row Lock）</h4><p>从锁的粒度角度，主要分为表级锁（Table Lock）和行级锁（Row Lock）。</p>
<p>表级锁将整个表加锁，性能开销最小</p>
<p>用户可以同时进行读操作。当一个用户对表进行写操作时，用户可以获得一个写锁，写锁禁止其他的用户读写操作。写锁比读锁的优先级更高，即使有读操作已排在队列中，一个被申请的写锁仍可以排在所队列的前列。</p>
<p>行级锁仅对指定的记录进行加锁</p>
<p>这样其它进程可以对同一个表中的其它记录进行读写操作。行级锁粒度最小，开销大，能够支持高并发，可能会出现死锁。</p>
<p>MySQL的MyISAM引擎使用表级锁，而InnoDB支持表级锁和行级锁，默认是行级锁。<br>还有BDB引擎使用页级锁，即一次锁定一组记录，并发性介于行级锁和表级锁之间。</p>
<h4 id="三级锁协议"><a href="#三级锁协议" class="headerlink" title="三级锁协议"></a>三级锁协议</h4><p>三级加锁协议是为了保证正确的事务并发操作，事务在读、写数据库对象是需要遵循的加锁规则。</p>
<p>一级封锁协议：事务T在修改数据R之前必须对它加X锁，直到事务结束方可释放。而若事务T只是读数据，不进行修改，则不需加锁，因此一级加锁协议下可能会出现脏读和不可重复读。</p>
<p>二级加锁协议：在一级加锁协议的基础上，加上这样一条规则——事务T在读取数据R之前必须对它加S锁，直到读取完毕以后释放。二级加锁协议下可能会出现不可重复读。</p>
<p>三级加锁协议：在一级加锁协议的基础上，加上这样一条规则——事务T在读取数据R之前必须对它加S锁，直到事务结束方可释放。三级加锁协议避免了脏读和不可重复读的问题</p>
<h1 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h1><p>Spring事务管理的实现有许多细节，如果对整个接口框架有个大体了解会非常有利于我们理解事务</p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/transaction/transaction.jpg" alt="image"></p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/transaction/transaction_1.jpg" alt="image"></p>
<h2 id="Spring事务管理器"><a href="#Spring事务管理器" class="headerlink" title="Spring事务管理器"></a>Spring事务管理器</h2><p>Spring事务管理涉及的接口的联系如下：<br><img src="http://oirwmbp4e.bkt.clouddn.com/transaction/spring-interface.png" alt="image"></p>
<p>Spring并不直接管理事务，而是提供了多种事务管理器，他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。 </p>
<p>Spring事务管理器的接口是org.springframework.transaction.PlatformTransactionManager，<br>通过这个接口，Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，</p>
<p>但是具体的实现就是各个平台自己的事情了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * This is the central interface in Spring&apos;s transaction infrastructure.</div><div class="line"> * Applications can use this directly, but it is not primarily meant as API:</div><div class="line"> * Typically, applications will work with either TransactionTemplate or</div><div class="line"> * declarative transaction demarcation through AOP.</div><div class="line"> */</div><div class="line">public interface PlatformTransactionManager &#123;</div><div class="line">    TransactionStatus getTransaction(TransactionDefinition definition)</div><div class="line">        throws TransactionException;</div><div class="line">    void commit(TransactionStatus status) throws TransactionException;</div><div class="line">    void rollback(TransactionStatus status) throws TransactionException;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>标准的jdbc处理事务代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Connection conn = DataSourceUtils.getConnection();</div><div class="line"> //开启事务</div><div class="line">conn.setAutoCommit(false);</div><div class="line">try &#123;</div><div class="line">    Object retVal = callback.doInConnection(conn);</div><div class="line">    conn.commit(); //提交事务</div><div class="line">    return retVal;</div><div class="line">&#125;catch (Exception e) &#123;</div><div class="line">    conn.rollback();//回滚事务</div><div class="line">    throw e;</div><div class="line">&#125;finally &#123;</div><div class="line">    conn.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>spring对应的TranstactionTemplate处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public class TransactionTemplate extends DefaultTransactionDefinition</div><div class="line">		implements TransactionOperations, InitializingBean &#123;</div><div class="line">		</div><div class="line">    @Override</div><div class="line">	public &lt;T&gt; T execute(TransactionCallback&lt;T&gt; action) throws TransactionException &#123;</div><div class="line">		if (this.transactionManager instanceof CallbackPreferringPlatformTransactionManager) &#123;</div><div class="line">			return ((CallbackPreferringPlatformTransactionManager) this.transactionManager).execute(this, action);</div><div class="line">		&#125;</div><div class="line">		else &#123;</div><div class="line">			TransactionStatus status = this.transactionManager.getTransaction(this);</div><div class="line">			T result;</div><div class="line">			try &#123;</div><div class="line">				result = action.doInTransaction(status);</div><div class="line">			&#125;</div><div class="line">			catch (RuntimeException ex) &#123;</div><div class="line">				// Transactional code threw application exception -&gt; rollback</div><div class="line">				rollbackOnException(status, ex);</div><div class="line">				throw ex;</div><div class="line">			&#125;</div><div class="line">			catch (Error err) &#123;</div><div class="line">				// Transactional code threw error -&gt; rollback</div><div class="line">				rollbackOnException(status, err);</div><div class="line">				throw err;</div><div class="line">			&#125;</div><div class="line">			catch (Exception ex) &#123;</div><div class="line">				// Transactional code threw unexpected exception -&gt; rollback</div><div class="line">				rollbackOnException(status, ex);</div><div class="line">				throw new UndeclaredThrowableException(ex, &quot;TransactionCallback threw undeclared checked exception&quot;);</div><div class="line">			&#125;</div><div class="line">			this.transactionManager.commit(status);</div><div class="line">			return result;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>具体的事务管理机制对Spring来说是透明的，它并不关心那些，那些是对应各个平台需要关心的，所以Spring事务管理的一个优点就是为不同的事务API提供一致的编程模型，如JTA、JDBC、Hibernate、JPA。下面分别介绍各个平台框架实现事务管理的机制。</p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/transaction/spring-txmanager.jpg" alt="image"></p>
<h3 id="JDBC事务"><a href="#JDBC事务" class="headerlink" title="JDBC事务"></a>JDBC事务</h3><p>如果应用程序中直接使用JDBC来进行持久化，DataSourceTransactionManager会为你处理事务边界。为了使用DataSourceTransactionManager，你需要使用如下的XML将其装配到应用程序的上下文定义中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</div><div class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>实际上，DataSourceTransactionManager是通过调用java.sql.Connection来管理事务，而后者是通过DataSource获取到的。通过调用连接的commit()方法来提交事务，同样，事务失败则通过调用rollback()方法进行回滚。</p>
<h3 id="Hibernate事务"><a href="#Hibernate事务" class="headerlink" title="Hibernate事务"></a>Hibernate事务</h3><p>如果应用程序的持久化是通过Hibernate实习的，那么你需要使用HibernateTransactionManager。对于Hibernate3，需要在Spring上下文定义中添加如下的<bean>声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt;</div><div class="line">    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></bean></p>
<p>sessionFactory属性需要装配一个Hibernate的session工厂，HibernateTransactionManager的实现细节是它将事务管理的职责委托给org.hibernate.Transaction对象，而后者是从Hibernate Session中获取到的。当事务成功完成时，HibernateTransactionManager将会调用Transaction对象的commit()方法，反之，将会调用rollback()方法。</p>
<h2 id="事务属性"><a href="#事务属性" class="headerlink" title="事务属性"></a>事务属性</h2><p>事务管理器接口PlatformTransactionManager通过getTransaction(TransactionDefinition definition)方法来得到事务，这个方法里面的参数是TransactionDefinition类，这个类就定义了一些基本的事务属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public interface TransactionDefinition &#123;</div><div class="line">    int getPropagationBehavior(); // 返回事务的传播行为</div><div class="line">    int getIsolationLevel(); // 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据</div><div class="line">    int getTimeout();  // 返回事务必须在多少秒内完成</div><div class="line">    boolean isReadOnly(); // 事务是否只读，事务管理器能够根据这个返回值进行优化，确保事务是只读的</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么什么是事务属性呢？事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。事务属性包含了5个方面</p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/transaction/spring-attribute.png" alt="image"></p>
<h3 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h3><p>事务的第一个方面是传播行为（propagation behavior）。<br>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。</p>
<p>为什么需要定义传播？</p>
<blockquote>
<p>在我们用SSH开发项目的时候，我们一般都是将事务设置在Service层 那么当我们调用Service层的一个方法的时候它能够保证我们的这个方法中执行的所有的对数据库的更新操作保持在一个事务中，在事务层里面调用的这些方法要么全部成功，要么全部失败。那么事务的传播特性也是从这里说起的。<br>如果你在你的Service层的这个方法中，除了调用了Dao层的方法之外，还调用了本类的其他的Service方法，那么在调用其他的Service方法的时候，这个事务是怎么规定的呢，我必须保证我在我方法里掉用的这个方法与我本身的方法处在同一个事务中，否则如果保证事物的一致性。事务的传播特性就是解决这个问题的，“事务是会传播的”在Spring中有针对传播特性的多种配置我们大多数情况下只用其中的一种:PROPGATION_REQUIRED：这个配置项的意思是说当我调用service层的方法的时候开启一个事务(具体调用那一层的方法开始创建事务，要看你的aop的配置),那么在调用这个service层里面的其他的方法的时候,如果当前方法产生了事务就用当前方法产生的事务，否则就创建一个新的事务。这个工作使由Spring来帮助我们完成的。<br>以前没有Spring帮助我们完成事务的时候我们必须自己手动的控制事务，例如当我们项目中仅仅使用hibernate，而没有集成进spring的时候，我们在一个service层中调用其他的业务逻辑方法，为了保证事物必须也要把当前的hibernate session传递到下一个方法中，或者采用ThreadLocal的方法，将session传递给下一个方法，其实都是一个目的。现在这个工作由spring来帮助我们完成，就可以让我们更加的专注于我们的业务逻辑。而不用去关心事务的问题。</p>
</blockquote>
<p>Spring定义了七种传播行为：</p>
<p>PROPAGATION_REQUIRED</p>
<p>如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。</p>
<p>PROPAGATION_SUPPORTS</p>
<p>支持当前事务，如果当前没有事务，就以非事务方式执行。</p>
<p>PROPAGATION_MANDATORY</p>
<p>使用当前的事务，如果当前没有事务，就抛出异常。</p>
<p>PROPAGATION_REQUIRES_NEW</p>
<p>新建事务，如果当前存在事务，把当前事务挂起。</p>
<p>PROPAGATION_NOT_SUPPORTED</p>
<p>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p>
<p>PROPAGATION_NEVER</p>
<p>以非事务方式执行，如果当前存在事务，则抛出异常。</p>
<p>PROPAGATION_NESTED</p>
<p>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</p>
<h4 id="传播行为详细"><a href="#传播行为详细" class="headerlink" title="传播行为详细"></a>传播行为详细</h4><p>通过实例尝试一下各个传播属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">ServiceA &#123;</div><div class="line">       </div><div class="line">     void methodA() &#123;</div><div class="line">         ServiceB.methodB();</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line">  </div><div class="line">ServiceB &#123;</div><div class="line">       </div><div class="line">     void methodB() &#123;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="PROPAGATION-REQUIRED"><a href="#PROPAGATION-REQUIRED" class="headerlink" title="PROPAGATION_REQUIRED"></a>PROPAGATION_REQUIRED</h5><p>如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//事务属性 PROPAGATION_REQUIRED</div><div class="line">methodA&#123;</div><div class="line">    ……</div><div class="line">    methodB();</div><div class="line">    ……</div><div class="line">&#125;</div><div class="line">//事务属性 PROPAGATION_REQUIRED</div><div class="line">methodB&#123;</div><div class="line">   ……</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>单独调用methodB方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">main&#123; </div><div class="line">    metodB(); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相当于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Main&#123; </div><div class="line">    Connection con=null; </div><div class="line">    try&#123; </div><div class="line">        con = getConnection(); </div><div class="line">        con.setAutoCommit(false); </div><div class="line"></div><div class="line">        //方法调用</div><div class="line">        methodB(); </div><div class="line"></div><div class="line">        //提交事务</div><div class="line">        con.commit(); </div><div class="line">    &#125; Catch(RuntimeException ex) &#123; </div><div class="line">        //回滚事务</div><div class="line">        con.rollback();   </div><div class="line">    &#125; finally &#123; </div><div class="line">        //释放资源</div><div class="line">        closeCon(); </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Spring保证在methodB方法中所有的调用都获得到一个相同的连接。在调用methodB时，没有一个存在的事务，所以获得一个新的连接，开启了一个新的事务。 </p>
<p><strong>只是在ServiceB.methodB内的任何地方出现异常，ServiceB.methodB将会被回滚，不会引起ServiceA.methodA的回滚</strong></p>
<p>单独调用MethodA时，在MethodA内又会调用MethodB.</p>
<p>执行效果相当于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">main&#123; </div><div class="line">    Connection con = null; </div><div class="line">    try&#123; </div><div class="line">        con = getConnection(); </div><div class="line">        methodA(); </div><div class="line">        con.commit(); </div><div class="line">    &#125; catch(RuntimeException ex) &#123; </div><div class="line">        con.rollback(); </div><div class="line">    &#125; finally &#123;    </div><div class="line">        closeCon(); </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用MethodA时，环境中没有事务，所以开启一个新的事务.</p>
<p>当在MethodA中调用MethodB时，环境中已经有了一个事务，所以methodB就加入当前事务</p>
<p><strong>ServiceA.methodA或者ServiceB.methodB无论哪个发生异常methodA和methodB作为一个整体都将一起回滚</strong></p>
<h5 id="PROPAGATION-SUPPORTS"><a href="#PROPAGATION-SUPPORTS" class="headerlink" title="PROPAGATION_SUPPORTS"></a>PROPAGATION_SUPPORTS</h5><p>如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。但是对于事务同步的事务管理器，PROPAGATION_SUPPORTS与不使用事务有少许不同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//事务属性 PROPAGATION_REQUIRED</div><div class="line">methodA()&#123;</div><div class="line">  methodB();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//事务属性 PROPAGATION_SUPPORTS</div><div class="line">methodB()&#123;</div><div class="line">  ……</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>单纯的调用methodB时，methodB方法是非事务的执行的。当调用methdA时,methodB则加入了methodA的事务中,事务地执行</p>
<h5 id="PROPAGATION-MANDATORY"><a href="#PROPAGATION-MANDATORY" class="headerlink" title="PROPAGATION_MANDATORY"></a>PROPAGATION_MANDATORY</h5><p>如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//事务属性 PROPAGATION_REQUIRED</div><div class="line">methodA()&#123;</div><div class="line">    methodB();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//事务属性 PROPAGATION_MANDATORY</div><div class="line">    methodB()&#123;</div><div class="line">    ……</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当单独调用methodB时，因为当前没有一个活动的事务，则会抛出异常throw new IllegalTransactionStateException(“Transaction propagation ‘mandatory’ but no existing transaction found”);</p>
<p>当调用methodA时，methodB则加入到methodA的事务中，事务地执行</p>
<h5 id="PROPAGATION-REQUIRES-NEW"><a href="#PROPAGATION-REQUIRES-NEW" class="headerlink" title="PROPAGATION_REQUIRES_NEW"></a>PROPAGATION_REQUIRES_NEW</h5><p>总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//事务属性 PROPAGATION_REQUIRED</div><div class="line">methodA()&#123;</div><div class="line">    doSomeThingA();</div><div class="line">    methodB();</div><div class="line">    doSomeThingB();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//事务属性 PROPAGATION_REQUIRES_NEW</div><div class="line">methodB()&#123;</div><div class="line">    ……</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用A方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">main()&#123;</div><div class="line">    methodA();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>相当于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">main()&#123;</div><div class="line">    TransactionManager tm = null;</div><div class="line">    try&#123;</div><div class="line">        //获得一个JTA事务管理器</div><div class="line">        tm = getTransactionManager();</div><div class="line">        tm.begin();//开启一个新的事务</div><div class="line">        Transaction ts1 = tm.getTransaction();</div><div class="line">        doSomeThing();</div><div class="line">        tm.suspend();//挂起当前事务</div><div class="line">        try&#123;</div><div class="line">            tm.begin();//重新开启第二个事务</div><div class="line">            Transaction ts2 = tm.getTransaction();</div><div class="line">            methodB();</div><div class="line">            ts2.commit();//提交第二个事务</div><div class="line">        &#125; Catch(RunTimeException ex) &#123;</div><div class="line">            ts2.rollback();//回滚第二个事务</div><div class="line">        &#125; finally &#123;</div><div class="line">            //释放资源</div><div class="line">        &#125;</div><div class="line">        //methodB执行完后，恢复第一个事务</div><div class="line">        tm.resume(ts1);</div><div class="line">        doSomeThingB();</div><div class="line">        ts1.commit();//提交第一个事务</div><div class="line">    &#125; catch(RunTimeException ex) &#123;</div><div class="line">        ts1.rollback();//回滚第一个事务</div><div class="line">    &#125; finally &#123;</div><div class="line">        //释放资源</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里，我把ts1称为外层事务，ts2称为内层事务。从上面的代码可以看出，ts2与ts1是两个独立的事务，互不相干。</p>
<p>Ts2是否成功并不依赖于ts1</p>
<p>如果methodA方法在调用methodB方法后的doSomeThingB方法失败了，而methodB方法所做的结果依然被提交。</p>
<p>而除了 methodB之外的其它代码导致的结果却被回滚了</p>
<h5 id="PROPAGATION-NOT-SUPPORTED"><a href="#PROPAGATION-NOT-SUPPORTED" class="headerlink" title="PROPAGATION_NOT_SUPPORTED"></a>PROPAGATION_NOT_SUPPORTED</h5><p>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//事务属性 PROPAGATION_REQUIRED</div><div class="line">methodA()&#123;</div><div class="line">    doSomeThingA();</div><div class="line">    methodB();</div><div class="line">    doSomeThingB();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//事务属性 PROPAGATION_NOT_SUPPORTED</div><div class="line">methodB()&#123;</div><div class="line">    ……</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当前不支持事务。比如ServiceA.methodA的事务级别是PROPAGATION_REQUIRED ，<br>而ServiceB.methodB的事务级别是PROPAGATION_NOT_SUPPORTED ，<br>那么当执行到ServiceB.methodB时，ServiceA.methodA的事务挂起，而他以非事务的状态运行完，再继续ServiceA.methodA的事务</p>
<h5 id="PROPAGATION-NEVER"><a href="#PROPAGATION-NEVER" class="headerlink" title="PROPAGATION_NEVER"></a>PROPAGATION_NEVER</h5><p>不能在事务中运行。假设ServiceA.methodA的事务级别是PROPAGATION_REQUIRED，<br>而ServiceB.methodB的事务级别是PROPAGATION_NEVER ，<br>那么ServiceB.methodB就要抛出异常了。</p>
<h5 id="PROPAGATION-NESTED"><a href="#PROPAGATION-NESTED" class="headerlink" title="PROPAGATION_NESTED"></a>PROPAGATION_NESTED</h5><p>开始一个 “嵌套的” 事务,  它是已经存在事务的一个真正的子事务. 潜套事务开始执行时,  它将取得一个 savepoint. 如果这个嵌套事务失败, 我们将回滚到此 savepoint. 潜套事务是外部事务的一部分, 只有外部事务结束后它才会被提交. </p>
<p>比如我们设计ServiceA.methodA的事务级别为PROPAGATION_REQUIRED，ServiceB.methodB的事务级别为PROPAGATION_NESTED，那么当执行到ServiceB.methodB的时候，ServiceA.methodA所在的事务就会挂起，ServiceB.methodB会起一个新的子事务并设置savepoint，等待ServiceB.methodB的事务完成以后，他才继续执行</p>
<p>因为ServiceB.methodB是外部事务的子事务，那么</p>
<ol>
<li>如果ServiceB.methodB已经提交，那么ServiceA.methodA失败回滚，ServiceB.methodB也将回滚。</li>
<li>如果ServiceB.methodB失败回滚，如果他抛出的异常被ServiceA.methodA的try..catch捕获并处理，ServiceA.methodA事务仍然可能提交；如果他抛出的异常未被ServiceA.methodA捕获处理，ServiceA.methodA事务将回滚。</li>
</ol>
<p>理解Nested的关键是savepoint。</p>
<p><strong>与PROPAGATION_REQUIRES_NEW的区别</strong>：</p>
<ol>
<li>RequiresNew每次都创建新的独立的物理事务，而Nested只有一个物理事务；</li>
<li>Nested嵌套事务回滚或提交不会导致外部事务回滚或提交，但外部事务回滚将导致嵌套事务回滚，而 RequiresNew由于都是全新的事务，所以之间是无关联的；</li>
<li>Nested使用JDBC 3的保存点实现，即如果使用低版本驱动将导致不支持嵌套事务。<br>使用嵌套事务，必须确保具体事务管理器实现的nestedTransactionAllowed属性为true，否则不支持嵌套事务，如DataSourceTransactionManager默认支持，而HibernateTransactionManager默认不支持，需要我们来开启。</li>
</ol>
<p>在 spring 中使用 PROPAGATION_NESTED的前提：</p>
<ol>
<li>我们要设置 transactionManager 的 nestedTransactionAllowed 属性为 true, 注意, 此属性默认为 false!!! </li>
<li>java.sql.Savepoint 必须存在, 即 jdk 版本要 1.4+ </li>
<li>Connection.getMetaData().supportsSavepoints() 必须为 true, 即 jdbc drive 必须支持 JDBC 3.0 </li>
</ol>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/transaction/propagation.png" alt="image"></p>
<h3 id="隔离规则"><a href="#隔离规则" class="headerlink" title="隔离规则"></a>隔离规则</h3><p>用来解决并发事务时出现的问题，其使用TransactionDefinition中的静态变量来指定</p>
<ol>
<li>ISOLATION_DEFAULT    使用后端数据库默认的隔离级别</li>
<li>ISOLATION_READ_UNCOMMITTED    最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</li>
<li>ISOLATION_READ_COMMITTED    允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</li>
<li>ISOLATION_REPEATABLE_READ    对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生</li>
<li>ISOLATION_SERIALIZABLE    最高的隔离级别，完全服从ACID的隔离级别，确保阻止脏读、不可重复读以及幻读，也是最慢的事务隔离级别，因为它通常是通过完全锁定事务相关的数据库表来实现的</li>
</ol>
<p>可以使用DefaultTransactionDefinition类的setIsolationLevel(TransactionDefinition. ISOLATION_READ_COMMITTED)来指定隔离级别，其中此处表示隔离级别为提交读</p>
<p>也可以使用或setIsolationLevelName(“ISOLATION_READ_COMMITTED”)方式指定，其中参数就是隔离级别静态变量的名字，但不推荐这种方式</p>
<h3 id="事务只读"><a href="#事务只读" class="headerlink" title="事务只读"></a>事务只读</h3><p>将事务标识为只读，只读事务不修改任何数据；</p>
<p>对于JDBC只是简单的将连接设置为只读模式，对于更新将抛出异常；</p>
<p>对于一些其他ORM框架有一些优化作用，如在Hibernate中，Spring事务管理器将执行“session.setFlushMode(FlushMode.MANUAL)”<br>即指定Hibernate会话在只读事务模式下不用尝试检测和同步持久对象的状态的更新。</p>
<p>如果使用设置具体事务管理的validateExistingTransaction属性为true（默认false），将确保整个事务传播链都是只读或都不是只读<br><img src="http://oirwmbp4e.bkt.clouddn.com/transaction/readonly.JPG" alt="image"></p>
<p>第二个addressService.save()不能设置成false</p>
<p>对于错误的事务只读设置将抛出IllegalTransactionStateException异常，并伴随“Participating transaction with definition [……] is not marked as read-only……”信息，表示参与的事务只读属性设置错误</p>
<h3 id="事务超时"><a href="#事务超时" class="headerlink" title="事务超时"></a>事务超时</h3><p>设置事务的超时时间，单位为秒，默认为-1表示使用底层事务的超时时间</p>
<p>使用如setTimeout(100)来设置超时时间，如果事务超时将抛出org.springframework.transaction.TransactionTimedOutException异常并将当前事务标记为应该回滚，即超时后事务被自动回滚</p>
<p>可以使用具体事务管理器实现的defaultTimeout属性设置默认的事务超时时间，如DataSourceTransactionManager. setDefaultTimeout(10)</p>
<h3 id="回滚规则"><a href="#回滚规则" class="headerlink" title="回滚规则"></a>回滚规则</h3><p>spring事务管理器会捕捉任何未处理的异常，然后依据规则决定是否回滚抛出异常的事务</p>
<p>默认配置下，Spring只有在抛出的异常为运行时unchecked异常时才回滚该事务，也就是抛出的异常为RuntimeException的子类(Errors也会导致事务回滚)，而抛出checked异常则不会导致事务回滚。可以明确的配置在抛出那些异常时回滚事务，包括checked异常。也可以明确定义那些异常抛出时不回滚事务</p>
<p><strong>如何改变默认规则</strong>：</p>
<ol>
<li>让checked例外也回滚：在整个方法前加上 @Transactional(rollbackFor=Exception.class)</li>
<li>让unchecked例外不回滚： @Transactional(notRollbackFor=RunTimeException.class)</li>
<li>不需要事务管理的(只查询的)方法：@Transactional(propagation=Propagation.NOT_SUPPORTED)</li>
</ol>
<h2 id="事务状态"><a href="#事务状态" class="headerlink" title="事务状态"></a>事务状态</h2><p>上面讲到的调用PlatformTransactionManager接口的getTransaction()的方法得到的是TransactionStatus接口的一个实现，这个接口的内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public interface TransactionStatus&#123;</div><div class="line">    boolean isNewTransaction(); // 是否是新的事物</div><div class="line">    boolean hasSavepoint(); // 是否有恢复点</div><div class="line">    void setRollbackOnly();  // 设置为只回滚</div><div class="line">    boolean isRollbackOnly(); // 是否为只回滚</div><div class="line">    boolean isCompleted; // 是否已完成</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以发现这个接口描述的是一些处理事务提供简单的控制事务执行和查询事务状态的方法，在回滚或提交的时候需要应用对应的事务状态</p>
<h2 id="编程式和声明式事务"><a href="#编程式和声明式事务" class="headerlink" title="编程式和声明式事务"></a>编程式和声明式事务</h2><p>Spring提供了对编程式事务和声明式事务的支持，编程式事务允许用户在代码中精确定义事务的边界</p>
<p>而声明式事务（基于AOP）有助于用户将操作与事务规则进行解耦。 </p>
<p>简单地说，编程式事务侵入到了业务代码里面，但是提供了更加详细的事务管理；而声明式事务由于基于AOP，所以既能起到事务管理的作用，又可以不影响业务代码的具体实现。</p>
<h3 id="编程式"><a href="#编程式" class="headerlink" title="编程式"></a>编程式</h3><p>Spring提供两种方式的编程式事务管理，分别是：使用TransactionTemplate和直接使用PlatformTransactionManager</p>
<h4 id="使用TransactionTemplate"><a href="#使用TransactionTemplate" class="headerlink" title="使用TransactionTemplate"></a>使用TransactionTemplate</h4><p>采用TransactionTemplate和采用其他Spring模板，如JdbcTempalte和HibernateTemplate是一样的方法。它使用回调方法，把应用程序从处理取得和释放资源中解脱出来。如同其他模板，TransactionTemplate是线程安全的。代码片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">TransactionTemplate tt = new TransactionTemplate(); // 新建一个TransactionTemplate</div><div class="line">Object result = tt.execute(</div><div class="line">    new TransactionCallback()&#123;  </div><div class="line">        public Object doTransaction(TransactionStatus status)&#123;  </div><div class="line">            updateOperation();  </div><div class="line">            return resultOfUpdateOperation();  </div><div class="line">        &#125;  </div><div class="line">&#125;); // 执行execute方法进行事务管理</div></pre></td></tr></table></figure></p>
<p>使用TransactionCallback()可以返回一个值。如果使用TransactionCallbackWithoutResult则没有返回值</p>
<h4 id="使用PlatformTransactionManager"><a href="#使用PlatformTransactionManager" class="headerlink" title="使用PlatformTransactionManager"></a>使用PlatformTransactionManager</h4><p>示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager();</div><div class="line">//定义一个某个框架平台的TransactionManager，如JDBC、Hibernate</div><div class="line">dataSourceTransactionManager.setDataSource(this.getJdbcTemplate().getDataSource()); // 设置数据源</div><div class="line">    DefaultTransactionDefinition transDef = new DefaultTransactionDefinition(); // 定义事务属性</div><div class="line">    transDef.setPropagationBehavior(DefaultTransactionDefinition.PROPAGATION_REQUIRED); // 设置传播行为属性</div><div class="line">    TransactionStatus status = dataSourceTransactionManager.getTransaction(transDef); // 获得事务状态</div><div class="line">    try &#123;</div><div class="line">        // 数据库操作</div><div class="line">        dataSourceTransactionManager.commit(status);// 提交</div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">        dataSourceTransactionManager.rollback(status);// 回滚</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="声明式"><a href="#声明式" class="headerlink" title="声明式"></a>声明式</h3><p>有几种实现方式，不一一罗列了</p>
<h4 id="使用tx拦截器"><a href="#使用tx拦截器" class="headerlink" title="使用tx拦截器"></a>使用tx拦截器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 定义事务管理器（声明式的事务） --&gt; </div><div class="line">    &lt;bean id=&quot;transactionManager&quot;</div><div class="line">        class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt;</div><div class="line">        &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line"></div><div class="line">    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;</div><div class="line">        &lt;tx:attributes&gt;</div><div class="line">            &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot; /&gt;</div><div class="line">        &lt;/tx:attributes&gt;</div><div class="line">    &lt;/tx:advice&gt;</div><div class="line"></div><div class="line">    &lt;aop:config&gt;</div><div class="line">        &lt;aop:pointcut id=&quot;interceptorPointCuts&quot;</div><div class="line">            expression=&quot;execution(* com.bluesky.spring.dao.*.*(..))&quot; /&gt;</div><div class="line">        &lt;aop:advisor advice-ref=&quot;txAdvice&quot;</div><div class="line">            pointcut-ref=&quot;interceptorPointCuts&quot; /&gt;       </div><div class="line">    &lt;/aop:config&gt;</div></pre></td></tr></table></figure>
<h4 id="全注解"><a href="#全注解" class="headerlink" title="全注解"></a>全注解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt;</div><div class="line">    &lt;bean id=&quot;transactionManager&quot;</div><div class="line">          class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager &quot;&gt;</div><div class="line">        &lt;property name=&quot;dataSource&quot;&gt;</div><div class="line">            &lt;ref bean=&quot;basicDataSource&quot; /&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<h2 id="Spring源码片段"><a href="#Spring源码片段" class="headerlink" title="Spring源码片段"></a>Spring源码片段</h2><p>在《BeanPostProcessor学习》中提到了AOP的实现方式，声明式事务实现是基于AOP</p>
<p>首先得解析xml配置，TxNamespaceHandler<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">	public void init() &#123;</div><div class="line">		registerBeanDefinitionParser(&quot;advice&quot;, new TxAdviceBeanDefinitionParser());</div><div class="line">		registerBeanDefinitionParser(&quot;annotation-driven&quot;, new AnnotationDrivenBeanDefinitionParser());</div><div class="line">		registerBeanDefinitionParser(&quot;jta-transaction-manager&quot;, new JtaTransactionManagerBeanDefinitionParser());</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>主要是TransactionInterceptor类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public Object invoke(final MethodInvocation invocation) throws Throwable &#123;</div><div class="line">		// Work out the target class: may be &#123;@code null&#125;.</div><div class="line">		// The TransactionAttributeSource should be passed the target class</div><div class="line">		// as well as the method, which may be from an interface.</div><div class="line">		Class&lt;?&gt; targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);</div><div class="line"></div><div class="line">		// Adapt to TransactionAspectSupport&apos;s invokeWithinTransaction...</div><div class="line">		//主要逻辑在父类</div><div class="line">		return invokeWithinTransaction(invocation.getMethod(), targetClass, new InvocationCallback() &#123;</div><div class="line">			@Override</div><div class="line">			public Object proceedWithInvocation() throws Throwable &#123;</div><div class="line">				return invocation.proceed();</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>核心逻辑，还得看父类TransactionAspectSupport#invokeWithinTransaction</p>
<p>逻辑主干很清晰</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) &#123;</div><div class="line">			// Standard transaction demarcation with getTransaction and commit/rollback calls.</div><div class="line">			// 判断创建Transaction</div><div class="line">			TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</div><div class="line">			Object retVal = null;</div><div class="line">			try &#123;</div><div class="line">				// This is an around advice: Invoke the next interceptor in the chain.</div><div class="line">				// This will normally result in a target object being invoked.</div><div class="line">				//执行业务逻辑</div><div class="line">				retVal = invocation.proceedWithInvocation();</div><div class="line">			&#125;</div><div class="line">			catch (Throwable ex) &#123;</div><div class="line">				// target invocation exception</div><div class="line">				// 出现异常，回滚</div><div class="line">				completeTransactionAfterThrowing(txInfo, ex);</div><div class="line">				throw ex;</div><div class="line">			&#125;</div><div class="line">			finally &#123;</div><div class="line">				//清除当前事务状态</div><div class="line">				cleanupTransactionInfo(txInfo);</div><div class="line">			&#125;</div><div class="line">			//提交事务</div><div class="line">			commitTransactionAfterReturning(txInfo);</div><div class="line">			return retVal;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<h3 id="创建事务createTransactionIfNecessary"><a href="#创建事务createTransactionIfNecessary" class="headerlink" title="创建事务createTransactionIfNecessary"></a>创建事务createTransactionIfNecessary</h3><p>主要逻辑在PlatformTransactionManager#getTransaction()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException &#123;</div><div class="line">		//得到各个不同数据源的事务对象，spring尽然没有把transaction对象抽象出来，很是奇怪</div><div class="line">		Object transaction = doGetTransaction();</div><div class="line"></div><div class="line">		// Cache debug flag to avoid repeated checks.</div><div class="line">		boolean debugEnabled = logger.isDebugEnabled();</div><div class="line"></div><div class="line">		if (definition == null) &#123;</div><div class="line">			// Use defaults if no transaction definition given.</div><div class="line">			definition = new DefaultTransactionDefinition();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		//此事务是否已经存在</div><div class="line">		if (isExistingTransaction(transaction)) &#123;</div><div class="line">			// Existing transaction found -&gt; check propagation behavior to find out how to behave.</div><div class="line">			return handleExistingTransaction(definition, transaction, debugEnabled);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// Check definition settings for new transaction.</div><div class="line">		if (definition.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;</div><div class="line">			throw new InvalidTimeoutException(&quot;Invalid transaction timeout&quot;, definition.getTimeout());</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// No existing transaction found -&gt; check propagation behavior to find out how to proceed.</div><div class="line">		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</div><div class="line">			throw new IllegalTransactionStateException(</div><div class="line">					&quot;No existing transaction found for transaction marked with propagation &apos;mandatory&apos;&quot;);</div><div class="line">		&#125;</div><div class="line">		//这三种都是新建事务</div><div class="line">		else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</div><div class="line">				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</div><div class="line">				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</div><div class="line">			SuspendedResourcesHolder suspendedResources = suspend(null);</div><div class="line">			if (debugEnabled) &#123;</div><div class="line">				logger.debug(&quot;Creating new transaction with name [&quot; + definition.getName() + &quot;]: &quot; + definition);</div><div class="line">			&#125;</div><div class="line">			try &#123;</div><div class="line">				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</div><div class="line">				DefaultTransactionStatus status = newTransactionStatus(</div><div class="line">						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);</div><div class="line">				//开始获取链接，开启事务，绑定资源到当前线程</div><div class="line">				doBegin(transaction, definition);</div><div class="line">				prepareSynchronization(status, definition);</div><div class="line">				return status;</div><div class="line">			&#125;</div><div class="line">			catch (RuntimeException | Error ex) &#123;</div><div class="line">				resume(null, suspendedResources);</div><div class="line">				throw ex;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		else &#123;</div><div class="line">			// Create &quot;empty&quot; transaction: no actual transaction, but potentially synchronization.</div><div class="line">			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123;</div><div class="line">				logger.warn(&quot;Custom isolation level specified but no actual transaction initiated; &quot; +</div><div class="line">						&quot;isolation level will effectively be ignored: &quot; + definition);</div><div class="line">			&#125;</div><div class="line">			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</div><div class="line">			return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<h4 id="TransactionStatus"><a href="#TransactionStatus" class="headerlink" title="TransactionStatus"></a>TransactionStatus</h4><p>这儿返回的是<strong>TransactionStatus</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public interface TransactionStatus extends SavepointManager, Flushable &#123;</div><div class="line"></div><div class="line">	boolean isNewTransaction();</div><div class="line"></div><div class="line">	boolean hasSavepoint();</div><div class="line"></div><div class="line">	void setRollbackOnly();</div><div class="line"></div><div class="line">	boolean isRollbackOnly();</div><div class="line"></div><div class="line">	void flush();</div><div class="line"></div><div class="line">	boolean isCompleted();</div></pre></td></tr></table></figure>
<h4 id="TransactionInfo"><a href="#TransactionInfo" class="headerlink" title="TransactionInfo"></a>TransactionInfo</h4><p>事务信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">protected final class TransactionInfo &#123;</div><div class="line"></div><div class="line">		private final PlatformTransactionManager transactionManager;</div><div class="line"></div><div class="line">		private final TransactionAttribute transactionAttribute;</div><div class="line"></div><div class="line">		private final String joinpointIdentification;</div><div class="line"></div><div class="line">		private TransactionStatus transactionStatus;</div><div class="line"></div><div class="line">		private TransactionInfo oldTransactionInfo;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<h3 id="commitTransactionAfterReturning提交事务"><a href="#commitTransactionAfterReturning提交事务" class="headerlink" title="commitTransactionAfterReturning提交事务"></a>commitTransactionAfterReturning提交事务</h3><p>逻辑到了AbstractPlatformTransactionManager#processRollback<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">private void processRollback(DefaultTransactionStatus status, boolean unexpected) &#123;</div><div class="line">		try &#123;</div><div class="line">			boolean unexpectedRollback = unexpected;</div><div class="line"></div><div class="line">			try &#123;</div><div class="line">				triggerBeforeCompletion(status);</div><div class="line">				//有savepoint，</div><div class="line">				if (status.hasSavepoint()) &#123;</div><div class="line">					if (status.isDebug()) &#123;</div><div class="line">						logger.debug(&quot;Rolling back transaction to savepoint&quot;);</div><div class="line">					&#125;</div><div class="line">					status.rollbackToHeldSavepoint();</div><div class="line">				&#125;</div><div class="line">				else if (status.isNewTransaction()) &#123;</div><div class="line">					if (status.isDebug()) &#123;</div><div class="line">						logger.debug(&quot;Initiating transaction rollback&quot;);</div><div class="line">					&#125;</div><div class="line">					//回滚事务</div><div class="line">					doRollback(status);</div><div class="line">				&#125;</div><div class="line">				else &#123;</div><div class="line">					// Participating in larger transaction</div><div class="line">					//在一个事务中，就先设置回滚标识,等父事务一起回滚</div><div class="line">					if (status.hasTransaction()) &#123;</div><div class="line">						if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) &#123;</div><div class="line">							if (status.isDebug()) &#123;</div><div class="line">								logger.debug(&quot;Participating transaction failed - marking existing transaction as rollback-only&quot;);</div><div class="line">							&#125;</div><div class="line">							doSetRollbackOnly(status);</div><div class="line">						&#125;</div><div class="line">						else &#123;</div><div class="line">							if (status.isDebug()) &#123;</div><div class="line">								logger.debug(&quot;Participating transaction failed - letting transaction originator decide on rollback&quot;);</div><div class="line">							&#125;</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">					else &#123;</div><div class="line">						logger.debug(&quot;Should roll back transaction but cannot - no transaction available&quot;);</div><div class="line">					&#125;</div><div class="line">					// Unexpected rollback only matters here if we&apos;re asked to fail early</div><div class="line">					if (!isFailEarlyOnGlobalRollbackOnly()) &#123;</div><div class="line">						unexpectedRollback = false;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			catch (RuntimeException | Error ex) &#123;</div><div class="line">				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</div><div class="line">				throw ex;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);</div><div class="line"></div><div class="line">			// Raise UnexpectedRollbackException if we had a global rollback-only marker</div><div class="line">			if (unexpectedRollback) &#123;</div><div class="line">				throw new UnexpectedRollbackException(</div><div class="line">						&quot;Transaction rolled back because it has been marked as rollback-only&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		finally &#123;</div><div class="line">			cleanupAfterCompletion(status);</div><div class="line">		&#125;</div></pre></td></tr></table></figure></p>
<h3 id="completeTransactionAfterThrowing回滚事务"><a href="#completeTransactionAfterThrowing回滚事务" class="headerlink" title="completeTransactionAfterThrowing回滚事务"></a>completeTransactionAfterThrowing回滚事务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">protected void completeTransactionAfterThrowing(TransactionInfo txInfo, Throwable ex) &#123;</div><div class="line">		//有事务才能回滚</div><div class="line">		if (txInfo != null &amp;&amp; txInfo.hasTransaction()) &#123;</div><div class="line">			if (logger.isTraceEnabled()) &#123;</div><div class="line">				logger.trace(&quot;Completing transaction for [&quot; + txInfo.getJoinpointIdentification() +</div><div class="line">						&quot;] after exception: &quot; + ex);</div><div class="line">			&#125;</div><div class="line">			//回滚在 (ex instanceof RuntimeException || ex instanceof Error)</div><div class="line">			if (txInfo.transactionAttribute.rollbackOn(ex)) &#123;</div><div class="line">				try &#123;</div><div class="line">					txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());</div><div class="line">				&#125;</div><div class="line">				catch (TransactionSystemException ex2) &#123;</div><div class="line">					logger.error(&quot;Application exception overridden by rollback exception&quot;, ex);</div><div class="line">					ex2.initApplicationException(ex);</div><div class="line">					throw ex2;</div><div class="line">				&#125;</div><div class="line">				catch (RuntimeException ex2) &#123;</div><div class="line">					logger.error(&quot;Application exception overridden by rollback exception&quot;, ex);</div><div class="line">					throw ex2;</div><div class="line">				&#125;</div><div class="line">				catch (Error err) &#123;</div><div class="line">					logger.error(&quot;Application exception overridden by rollback error&quot;, ex);</div><div class="line">					throw err;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			else &#123;</div><div class="line">				// We don&apos;t roll back on this exception.</div><div class="line">				// Will still roll back if TransactionStatus.isRollbackOnly() is true.</div><div class="line">				try &#123;</div><div class="line">					txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</div><div class="line">				&#125;</div><div class="line">				catch (TransactionSystemException ex2) &#123;</div><div class="line">					logger.error(&quot;Application exception overridden by commit exception&quot;, ex);</div><div class="line">					ex2.initApplicationException(ex);</div><div class="line">					throw ex2;</div><div class="line">				&#125;</div><div class="line">				catch (RuntimeException ex2) &#123;</div><div class="line">					logger.error(&quot;Application exception overridden by commit exception&quot;, ex);</div><div class="line">					throw ex2;</div><div class="line">				&#125;</div><div class="line">				catch (Error err) &#123;</div><div class="line">					logger.error(&quot;Application exception overridden by commit error&quot;, ex);</div><div class="line">					throw err;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一个完整的事务介绍结束了。框架就是封装一切，透明一切，简化一切。本质的流程不会变</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://blog.sina.com.cn/s/blog_7ed8b1e90101mgas.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_7ed8b1e90101mgas.html</a></p>
<p><a href="https://my.oschina.net/wanyuxiang000/blog/277568" target="_blank" rel="external">https://my.oschina.net/wanyuxiang000/blog/277568</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      
      <! -- 添加微信图标 -->
    
    
    
    

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zhuxingsheng.github.io/2017/09/16/comon-sense-thre-continuous-integration,-continuous-delivery,-continuous-deployment/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="朱兴生">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/6222636?v=3&s=460">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="码农戏码">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="码农戏码" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/16/comon-sense-thre-continuous-integration,-continuous-delivery,-continuous-deployment/" itemprop="url">
                  常识三持续集成、持续交付、持续部署
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-16T15:23:25+08:00">
                2017-09-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/互联网研发/" itemprop="url" rel="index">
                    <span itemprop="name">互联网研发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          
	
	  
	  <span class="post-letters-count">
	    &nbsp; | &nbsp;
	    <span>1,582 字</span>
	    &nbsp; | &nbsp;
	    <span>6 min</span>
	  </span>
	  

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>常识系列,作为一名互联网门外汉的科普系列</p>
</blockquote>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>假如把开发工作流程分为以下几个阶段：</p>
<blockquote>
<p>编码 -&gt; 构建 -&gt; 集成 -&gt; 测试 -&gt; 交付 -&gt; 部署</p>
</blockquote>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/ci/ci_all.png" alt="image"></p>
<p>正如你在上图中看到，「持续集成（Continuous Integration）」、「持续交付（Continuous Delivery）」和「持续部署（Continuous Deployment）」有着不同的软件自动化交付周期。</p>
<p>“持续集成”一词来源与极限编程（Extreme Programming）,<br>作为它的12个实践原则之一出现。</p>
<p>ThoughtWorks首席科学家、软件开发领域大事Martin Fowler对持续集成是这样定义的：</p>
<p>持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通常每个成员每天至少集成一次，也就意味置顶每天可能发生多次集成。每次集成都是通过自动化的构建（包括编译、发布、自动化测试）来验证，从而尽快地发现集成错误。许多团队发现这个过程可以大大的减少集成的问题，让团队能够更快的开发内聚的软件。</p>
<p>从上面的定义可以看出，一个典型的持续集成周期包括以下几个步骤：</p>
<ol>
<li>版本控制服务器上有最新的代码</li>
<li>持续集成服务器从版本控制服务器下载最新的代码</li>
<li>等代码完全更新以后，调用自动化编译脚本，进行代码编译</li>
<li>运行所有的自动化测试（单元测试、接口测试、系统级别的UI自动化测试等）</li>
<li>将结果写入报告文件中，反馈给团队成员</li>
<li>如果构建失败，必须尽快修改确保下次构建成功</li>
<li>产生可执行的软件版本，提供给测试人员进行测试</li>
</ol>
<p>持续集成框架是由代码提交活定时来触发的（项目级别的持续集成可以由开发每次代码提交触发，而产品级别的持续集成可以由定时来触发），每次提交到版本控制服务器上的代码都要经过自动化构建，确保每次的代码变更都不会导致持续集成失败。</p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/ci/ci.jpg" alt="image"></p>
<h2 id="「持续集成（Continuous-Integration）」"><a href="#「持续集成（Continuous-Integration）」" class="headerlink" title="「持续集成（Continuous Integration）」"></a>「持续集成（Continuous Integration）」</h2><p>持续集成强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起。<br><img src="http://oirwmbp4e.bkt.clouddn.com/ci/ci_1.png" alt="image"></p>
<h2 id="「持续交付（Continuous-Delivery）」"><a href="#「持续交付（Continuous-Delivery）」" class="headerlink" title="「持续交付（Continuous Delivery）」"></a>「持续交付（Continuous Delivery）」</h2><p>持续交付在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的「类生产环境」（production-like environments）中。比如，我们完成单元测试后，可以把代码部署到连接数据库的 Staging 环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境中。</p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/ci/ci_2.png" alt="image"></p>
<h2 id="「持续部署（Continuous-Deployment）」"><a href="#「持续部署（Continuous-Deployment）」" class="headerlink" title="「持续部署（Continuous Deployment）」"></a>「持续部署（Continuous Deployment）」</h2><p>持续部署则是在持续交付的基础上，把部署到生产环境的过程自动化。<br><img src="http://oirwmbp4e.bkt.clouddn.com/ci/cd.png" alt="image"></p>
<h1 id="三者关系"><a href="#三者关系" class="headerlink" title="三者关系"></a>三者关系</h1><p>持续交付、持续部署</p>
<p>将持续集成扩充到部署到生产环境就是持续交付和持续部署的概念，二者的区别</p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/ci/ci_dif.jpg" alt="image"></p>
<p>手动与自动的区别</p>
<h2 id="CI步骤"><a href="#CI步骤" class="headerlink" title="CI步骤"></a>CI步骤</h2><p><img src="http://oirwmbp4e.bkt.clouddn.com/ci/Continuous-integration-with-docker.png" alt="image"></p>
<h1 id="CI的价值"><a href="#CI的价值" class="headerlink" title="CI的价值"></a>CI的价值</h1><p>开发人员对下面的软件开发场景很熟悉，比如：</p>
<p>场景一：开发了新功能，老功能产生新的 bug；</p>
<p>场景二：修好一个 bug，又产生其他 bug，甚至出现连环 bug；</p>
<p>场景三：出现的 bug 比较多，修改代码要很谨慎，不熟悉的模块一般不敢动，怕引起问题；</p>
<p>持续集成是如何缓解这个问题，Martin Fowler 大师曾经说过：</p>
<blockquote>
<p>“Continuous Integration doesn’t get rid of bugs, but it does make them dramatically easier to find and remove.” — Martin Fowler</p>
</blockquote>
<p>如上面所说，持续集成不能消除 bug ,但能更容易地发现 bug,更快速地修复，提升产品质量。那么，持续集成能给我们带来哪些价值？</p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/ci/jiazhi.jpg" alt="image"></p>
<p>引入了CI（Continuos Integration，即持续集成）以后，每个开发人员在提交代码的时候都会自动进行构建，包括代码审查、编译、单元测试、打包、功能测试等。这样保证了开发人员的每次提交都是安全的。打包生成的文件随时可以被测试人员拿去测试。如果需要给客户演示功能，也只需从CI服务器上直接获取指定的打包完成的文件即可。</p>
<p>CI的好处多多。</p>
<p><strong>减少风险</strong></p>
<p>缺陷的检测和修复变得更快，让寻找和修改bug的工作变简单（只修改系统一小部分，无需看太多代码。由于提交后就可以得到反馈，记忆很新鲜，可以进行差异调试。）同时过早的引入集成，使我们能更好的审视各个模块的接口是否满足要求，减少项目中的假定。</p>
<p><strong>减少重复过程</strong></p>
<p>由于CI将大量的工作给自动化了，那么可以让人们有时间做更多的需要动脑筋的、更高价值的工作。而且通过对重要过程自动化，克服了项目中某些成员对实现改进的抵制，有利于持续集成的推进。这样就形成了一个良性循环。</p>
<p>在任何时间、任何地点生成可部署的软件<br>对于客户来说，可以部署的软件是最实际的资产。而CI则可以轻松做到这一点。</p>
<p><strong>增强项目的可见性</strong></p>
<p>通过对CI服务器的监控，可以随时了解项目的趋势。CI上的红色或绿色表示了当前项目的健康程度。每一个功能的交付都经历了单元测试或集成测试的考验。</p>
<p>对开发团队的软件产品建立起更强大的产品信心<br>CI可以防止破窗综合症，让开发团队一点点积累起对产品的信息。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://apiumtech.com/blog/top-benefits-of-continuous-integration-2/" target="_blank" rel="external">https://apiumtech.com/blog/top-benefits-of-continuous-integration-2/</a></p>
<p><a href="https://www.mindtheproduct.com/2016/02/what-the-hell-are-ci-cd-and-devops-a-cheatsheet-for-the-rest-of-us/" target="_blank" rel="external">https://www.mindtheproduct.com/2016/02/what-the-hell-are-ci-cd-and-devops-a-cheatsheet-for-the-rest-of-us/</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html</a></p>
<p><a href="https://segmentfault.com/a/1190000006166538" target="_blank" rel="external">https://segmentfault.com/a/1190000006166538</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      
      <! -- 添加微信图标 -->
    
    
    
    

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zhuxingsheng.github.io/2017/08/30/comon-sense-two-oauth2.0-introduction-and-security-precautions/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="朱兴生">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/6222636?v=3&s=460">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="码农戏码">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="码农戏码" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/30/comon-sense-two-oauth2.0-introduction-and-security-precautions/" itemprop="url">
                  常识二Oauth2.0介绍及安全防范
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-30T21:33:46+08:00">
                2017-08-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/互联网研发/" itemprop="url" rel="index">
                    <span itemprop="name">互联网研发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          
	
	  
	  <span class="post-letters-count">
	    &nbsp; | &nbsp;
	    <span>3,382 字</span>
	    &nbsp; | &nbsp;
	    <span>13 min</span>
	  </span>
	  

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>常识系列,作为一名互联网门外汉的科普系列</p>
</blockquote>
<h1 id="Oauth概念"><a href="#Oauth概念" class="headerlink" title="Oauth概念"></a>Oauth概念</h1><p>oAuth是Open Authorization的简写</p>
<p>OAuth（开放授权）是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。</p>
<p>OAuth允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的网站（例如，视频编辑网站)在特定的时段（例如，接下来的2小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。这样，OAuth让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容。</p>
<h1 id="OAuth2-0"><a href="#OAuth2-0" class="headerlink" title="OAuth2.0"></a>OAuth2.0</h1><p>OAuth 2.0是一个应用之间彼此访问数据的开源授权协议。比如，一个游戏应用可以访问Facebook的用户数据<br><img src="http://oirwmbp4e.bkt.clouddn.com/oauth/introduction.png" alt="image"></p>
<h2 id="授权流程"><a href="#授权流程" class="headerlink" title="授权流程"></a>授权流程</h2><p><img src="http://oirwmbp4e.bkt.clouddn.com/oauth/overview-1.png" alt="image"></p>
<p>第一步，用户访问客户端web应用。应用中的按钮”通过Facebook登录”(或者其他的系统，如Google或Twitter)。</p>
<p>第二步，当用户点击了按钮后，会被重定向到授权的应用(如Facebook)。用户登录并确认授权应用中的数据给客户端应用。</p>
<p>第三步，授权应用将用户重定向到客户端应用提供的URI，提供这种重定向的URI通常是通过注册客户端应用程序与授权应用程序完成。在注册中，客户端应用的拥有者组注册该重定向URI，在注册过程中认证应用也会给客户端应用客户端标识和密码。在URI后追加一个认证码。该认证码代表了授权。</p>
<p>第四步，用户在客户端应用访问网页被定位到重定向的URI。在背后客户端应用连接授权应用，并且发送在重定向请求参数中接收到的客户端标识，客户端密码和认证码。授权应用将返回一个访问口令。</p>
<p>一旦客户端有了访问口令，该口令便可以被发送到Facebook、Google、Twitter等来访问登录用户的资源。</p>
<h2 id="角色定义"><a href="#角色定义" class="headerlink" title="角色定义"></a>角色定义</h2><p><img src="http://oirwmbp4e.bkt.clouddn.com/oauth/overview-roles.png" alt="image"></p>
<ol>
<li><p>Third-party application：第三方应用程序，本文中又称”客户端”（client）</p>
</li>
<li><p>Resource Owner：资源所有者，本文中又称”用户”（user）。</p>
</li>
<li><p>User Agent：用户代理，本文中就是指浏览器。</p>
</li>
<li><p>Authorization server：认证服务器，即服务提供商专门用来处理认证的服务器。</p>
</li>
<li><p>Resource server：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。</p>
</li>
</ol>
<h2 id="客户端的授权模式"><a href="#客户端的授权模式" class="headerlink" title="客户端的授权模式"></a>客户端的授权模式</h2><p>客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。</p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/oauth/auth.png" alt="image"></p>
<p>OAuth 2.0定义了四种授权方式。</p>
<ul>
<li>授权码模式（authorization code）</li>
<li>简化模式（implicit）</li>
<li>密码模式（resource owner password credentials）</li>
<li>客户端模式（client credentials）</li>
</ul>
<h3 id="授权码模式（authorization-code）"><a href="#授权码模式（authorization-code）" class="headerlink" title="授权码模式（authorization code）"></a>授权码模式（authorization code）</h3><p>授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与”服务提供商”的认证服务器进行互动。</p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/oauth/authorization-auth-code.png" alt="image"></p>
<p>（A）用户访问客户端，后者将前者导向认证服务器。</p>
<p>（B）用户选择是否给予客户端授权。</p>
<p>（C）假设用户给予授权，认证服务器将用户导向客户端事先指定的”重定向URI”（redirection URI），同时附上一个授权码。</p>
<p>（D）客户端收到授权码，附上早先的”重定向URI”，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。</p>
<p>（E）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。</p>
<p>A：客户端申请认证的URI<br>包含以下参数：</p>
<p>response_type：表示授权类型，必选项，此处的值固定为”code”</p>
<p>client_id：表示客户端的ID，必选项</p>
<p>redirect_uri：表示重定向URI，可选项</p>
<p>scope：表示申请的权限范围，可选项</p>
<p>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz</div><div class="line">        &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1</div><div class="line">Host: server.example.com</div></pre></td></tr></table></figure>
<p>C：服务器回应客户端的URI</p>
<p>包含以下参数：</p>
<p>code：表示授权码，必选项。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端ID和重定向URI，是一一对应关系。</p>
<p>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 302 Found</div><div class="line">Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA</div><div class="line">          &amp;state=xyz</div></pre></td></tr></table></figure>
<p>D：<br>客户端向认证服务器申请令牌的HTTP请求</p>
<p>包含以下参数：</p>
<p>grant_type：表示使用的授权模式，必选项，此处的值固定为”authorization_code”。</p>
<p>code：表示上一步获得的授权码，必选项。</p>
<p>redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。</p>
<p>client_id：表示客户端ID，必选项。</p>
<p>client_secret：在开放平台申请时提供的APP Secret</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">POST /token HTTP/1.1</div><div class="line">Host: server.example.com</div><div class="line">Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</div><div class="line">Content-Type: application/x-www-form-urlencoded</div><div class="line"></div><div class="line">grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA</div><div class="line">&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</div></pre></td></tr></table></figure>
<p>E：认证服务器发送的HTTP回复</p>
<p>包含以下参数：</p>
<p>access_token：表示访问令牌，必选项。</p>
<p>token_type：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。</p>
<p>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</p>
<p>refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。</p>
<p>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">    Content-Type: application/json;charset=UTF-8</div><div class="line">    Cache-Control: no-store</div><div class="line">    Pragma: no-cache</div><div class="line"></div><div class="line">    &#123;</div><div class="line">      &quot;access_token&quot;:&quot;2YotnFZFEjr1zCsicMWpAA&quot;,</div><div class="line">      &quot;token_type&quot;:&quot;example&quot;,</div><div class="line">      &quot;expires_in&quot;:3600,</div><div class="line">      &quot;refresh_token&quot;:&quot;tGzv3JOkF0XG5Qx2TlKWIA&quot;,</div><div class="line">      &quot;example_parameter&quot;:&quot;example_value&quot;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>最后根据access_token，使用它，就可以去获取用户的资源了，要获取用户昵称和头像</p>
<h3 id="授权示例"><a href="#授权示例" class="headerlink" title="授权示例"></a>授权示例</h3><p>(1) Alice有一个有效的Google帐号；</p>
<p>(2) Facebook.com已经在Google Authorization Server上注册了Client身份，已经获得(client_id, client_secret)，注意client_secret是Client与AS之间的一个共享密钥。</p>
<p>(3) Alice想授权Facebook.com查看她的联系人列表(<a href="https://www.google.com/m8/feeds)。" target="_blank" rel="external">https://www.google.com/m8/feeds)。</a></p>
<p>展示了Alice、Facebook.com、Google资源服务器、以及Google OAuth授权服务器之间的协议运行过程。</p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/oauth/demo.png" alt="image"></p>
<h3 id="简化模式"><a href="#简化模式" class="headerlink" title="简化模式"></a>简化模式</h3><p>简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了”授权码”这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。</p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/oauth/implicit-type.png" alt="image"></p>
<p>（A）客户端将用户导向认证服务器。</p>
<p>（B）用户决定是否给于客户端授权。</p>
<p>（C）假设用户给予授权，认证服务器将用户导向客户端指定的”重定向URI”，并在URI的Hash部分包含了访问令牌。</p>
<p>（D）浏览器向资源服务器发出请求，其中不包括上一步收到的Hash值。</p>
<p>（E）资源服务器返回一个网页，其中包含的代码可以获取Hash值中的令牌。</p>
<p>（F）浏览器执行上一步获得的脚本，提取出令牌。</p>
<p>（G）浏览器将令牌发给客户端。</p>
<h3 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h3><p>密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。</p>
<p>客户端使用这些信息，向”服务商提供商”索要授权。</p>
<p>在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。</p>
<p>这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。</p>
<p>而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。</p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/oauth/password-type.png" alt="image"></p>
<p>（A）用户向客户端提供用户名和密码。</p>
<p>（B）客户端将用户名和密码发给认证服务器，向后者请求令牌。</p>
<p>（C）认证服务器确认无误后，向客户端提供访问令牌。</p>
<p>B步骤中，客户端发出的HTTP请求，</p>
<p>包含以下参数：</p>
<p>grant_type：表示授权类型，此处的值固定为”password”，必选项。</p>
<p>username：表示用户名，必选项。</p>
<p>password：表示用户的密码，必选项。</p>
<p>scope：表示权限范围，可选项。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">POST /token HTTP/1.1</div><div class="line">     Host: server.example.com</div><div class="line">     Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</div><div class="line">     Content-Type: application/x-www-form-urlencoded</div><div class="line"></div><div class="line">     grant_type=password&amp;username=johndoe&amp;password=A3ddj3w</div></pre></td></tr></table></figure>
<p>C步骤中，认证服务器向客户端发送访问令牌，</p>
<p>下面是一个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">     Content-Type: application/json;charset=UTF-8</div><div class="line">     Cache-Control: no-store</div><div class="line">     Pragma: no-cache</div><div class="line"></div><div class="line">     &#123;</div><div class="line">       &quot;access_token&quot;:&quot;2YotnFZFEjr1zCsicMWpAA&quot;,</div><div class="line">       &quot;token_type&quot;:&quot;example&quot;,</div><div class="line">       &quot;expires_in&quot;:3600,</div><div class="line">       &quot;refresh_token&quot;:&quot;tGzv3JOkF0XG5Qx2TlKWIA&quot;,</div><div class="line">       &quot;example_parameter&quot;:&quot;example_value&quot;</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p>整个过程中，客户端不得保存用户的密码。</p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向”服务提供商”进行认证。</p>
<p>严格地说，客户端模式并不属于OAuth框架所要解决的问题。</p>
<p>在这种模式中，用户直接向客户端注册，客户端以自己的名义要求”服务提供商”提供服务，其实不存在授权问题。</p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/oauth/client-type.png" alt="image"></p>
<p>（A）客户端向认证服务器进行身份认证，并要求一个访问令牌。</p>
<p>（B）认证服务器确认无误后，向客户端提供访问令牌。</p>
<p>A步骤中，客户端发出的HTTP请求，</p>
<p>包含以下参数：</p>
<p>granttype：表示授权类型，此处的值固定为”clientcredentials”，必选项。</p>
<p>scope：表示权限范围，可选项。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">POST /token HTTP/1.1</div><div class="line">     Host: server.example.com</div><div class="line">     Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</div><div class="line">     Content-Type: application/x-www-form-urlencoded</div><div class="line"></div><div class="line">     grant_type=client_credentials</div></pre></td></tr></table></figure>
<p>认证服务器必须以某种方式，验证客户端身份。<br>B步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">    Content-Type: application/json;charset=UTF-8</div><div class="line">    Cache-Control: no-store</div><div class="line">    Pragma: no-cache</div><div class="line"></div><div class="line">    &#123;</div><div class="line">      &quot;access_token&quot;:&quot;2YotnFZFEjr1zCsicMWpAA&quot;,</div><div class="line">      &quot;token_type&quot;:&quot;example&quot;,</div><div class="line">      &quot;expires_in&quot;:3600,</div><div class="line">      &quot;example_parameter&quot;:&quot;example_value&quot;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="OAuth2-0安全"><a href="#OAuth2-0安全" class="headerlink" title="OAuth2.0安全"></a>OAuth2.0安全</h1><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。</p>
<p>CSRF这种攻击方式在2000年已经被国外的安全人员提出，但在国内，直到06年才开始被关注，08年，国内外的多个大型社区和交互网站分别爆出CSRF漏洞，如：NYTimes.com（纽约时报）、Metafilter（一个大型的BLOG网站），YouTube和百度HI……而现在，互联网上的许多站点仍对此毫无防备，以至于安全业界称CSRF为“沉睡的巨人”。</p>
<p>本质 <strong>攻击者盗用了你的身份，以你的名义发送恶意请求</strong> </p>
<h3 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h3><p>假设有用户张三，和攻击者李四，还有一个第三方Web应用Tonr，它集成了第三方社交账号登录，并且允许用户将社交账号和Tonr中的账号进行绑定。此外还有一个OAuth2服务提供者Sparklr。<br><img src="http://oirwmbp4e.bkt.clouddn.com/oauth/2-CSRF-attack.png" alt="image"></p>
<p>Step 1. 攻击者李四登录Tonr网站，并且选择绑定自己的Sparklr账号。</p>
<p>Step 2. Tonr网站将李四重定向到Sparklr，由于他之前已经登录过Sparklr，所以Sparklr直接向他显示“是否授权Tonr访问”的页面。</p>
<p>Step 3. 李四在点击”同意授权“之后，截获Sparklr服务器返回的含有Authorization Code参数的HTTP响应。</p>
<p>Step 4. 李四精心构造一个Web页面，它会触发Tonr网站向Sparklr发起令牌申请的请求，而这个请求中的Authorization Code参数正是上一步截获到的code。</p>
<p>Step 5. 李四将这个Web页面放到互联网上，等待或者诱骗受害者张三来访问。</p>
<p>Step 6. 张三之前登录了Tonr网站，只是没有把自己的账号和其他社交账号绑定起来。在张三访问了李四准备的这个Web页面后，令牌申请流程在张三的浏览器里被顺利触发，Tonr网站从Sparklr那里获取到access_token，但是这个token以及通过它进一步获取到的用户信息却都是攻击者李四的。</p>
<p>Step 7. Tonr网站将李四的Sparklr账号同张三的Tonr账号关联绑定起来，从此以后，李四就可以用自己的Sparklr账号通过OAuth登录到张三在Tonr网站中的账号，堂而皇之的冒充张三的身份执行各种操作。</p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/oauth/3-Sparklr.png" alt="image"></p>
<p>对于开发者而言，要修复这个漏洞，就是必须加入state参数，这个参数既不可预测，又必须可以充分证明client和当前第三方网站的登录认证状态存在关联（如果存在过期时间更好）。其实，随机算一个字符串，然后保存在session，回调时检查state参数和session里面的值，就满足要求了。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://insights.thoughtworkers.org/attack-aim-at-oauth2/#utm_source=rss&amp;utm_medium=rss" target="_blank" rel="external">http://insights.thoughtworkers.org/attack-aim-at-oauth2/#utm_source=rss&amp;utm_medium=rss</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      
      <! -- 添加微信图标 -->
    
    
    
    

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zhuxingsheng.github.io/2017/07/22/comon-sense-one-user-pasword-storage-strategy/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="朱兴生">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/6222636?v=3&s=460">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="码农戏码">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="码农戏码" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/22/comon-sense-one-user-pasword-storage-strategy/" itemprop="url">
                  常识一用户密码存储策略
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-22T08:27:44+08:00">
                2017-07-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/互联网研发/" itemprop="url" rel="index">
                    <span itemprop="name">互联网研发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          
	
	  
	  <span class="post-letters-count">
	    &nbsp; | &nbsp;
	    <span>9,602 字</span>
	    &nbsp; | &nbsp;
	    <span>34 min</span>
	  </span>
	  

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>常识系列,作为一名互联网门外汉的科普系列</p>
</blockquote>
<h1 id="用户安全进化史"><a href="#用户安全进化史" class="headerlink" title="用户安全进化史"></a>用户安全进化史</h1><h2 id="明文存储"><a href="#明文存储" class="headerlink" title="明文存储"></a>明文存储</h2><p>曾经也开发过网站，知道用户密码信息不能直接明文存储，这样处理的风险来自两方面</p>
<ol>
<li>一是来自网站维护人员，可能直接盗用用户帐户</li>
<li>二是来自外部入侵者，下载了整个数据库</li>
</ol>
<p>所以明文存储是肯定不可行的。</p>
<h2 id="加密存储"><a href="#加密存储" class="headerlink" title="加密存储"></a>加密存储</h2><p>升级方案就是对密码进行加密后存储，这样就避免了明文存储的问题。使用什么方式加密呢？比如我们常使用的MD5算法，但这样就是安全的了吗？此处需要再了解几个概念</p>
<h3 id="哈希（Hash）与加密（Encrypt）的区别"><a href="#哈希（Hash）与加密（Encrypt）的区别" class="headerlink" title="哈希（Hash）与加密（Encrypt）的区别"></a>哈希（Hash）与加密（Encrypt）的区别</h3><p>首先从直观层面阐述<a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">哈希（Hash）</a>和<a href="http://en.wikipedia.org/wiki/Cryptography">加密（Encrypt）</a>的区别，因为我见过很多朋友对这两个概念不是很清晰，容易混淆两者。而正确区别两者是正确选择和使用哈希与加密的基础。</p>
<p>概括来说，<strong>哈希（Hash）是将目标文本转换成具有相同长度的、不可逆的杂凑字符串（或叫做消息摘要），而加密（Encrypt）是将目标文本转换成具有不同长度的、可逆的密文。</strong></p>
<p>具体来说，两者有如下重要区别：</p>
<ol>
<li>哈希算法往往被设计成生成具有相同长度的文本，而加密算法生成的文本长度与明文本身的长度有关。</li>
</ol>
<p>例如，设我们有两段文本：“Microsoft”和“Google”。<br>两者使用某种哈希算法得到的结果分别为：“140864078AECA1C7C35B4BEB33C53C34”和“8B36E9207C24C76E6719268E49201D94”，</p>
<p>而使用某种加密算法的到的结果分别为“Njdsptpgu”和“Hpphmf”。</p>
<p>可以看到，哈希的结果具有相同的长度，而加密的结果则长度不同。</p>
<p>实际上，如果使用相同的哈希算法，不论你的输入有多么长，得到的结果长度是一个常数，而加密算法往往与明文的长度成正比。</p>
<ol>
<li>哈希算法是不可逆的，而加密算法是可逆的。</li>
</ol>
<p>这里的不可逆有两层含义，</p>
<ul>
<li><p>一是“给定一个哈希结果R，没有方法将E转换成原目标文本S”</p>
</li>
<li><p>二是“给定哈希结果R，即使知道一段文本S的哈希结果为R，也不能断言当初的目标文本就是S”。</p>
</li>
</ul>
<p>其实稍微想想就知道，哈希是不可能可逆的，因为如果可逆，那么哈希就是世界上最强悍的压缩方式了——能将任意大小的文件压缩成固定大小。</p>
<p>加密则不同，给定加密后的密文R，存在一种方法可以将R确定的转换为加密前的明文S。</p>
<p>这里先从直观层面简单介绍两者的区别，等下文从数学角度对两者做严谨描述后，读者朋友就知道为什么会有这两个区别了。</p>
          <!--noindex-->
          <div class="post-more-link text-center">
            <a class="btn" href="/2017/07/22/comon-sense-one-user-pasword-storage-strategy/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      
      <! -- 添加微信图标 -->
    
    
    
    

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zhuxingsheng.github.io/2017/07/10/beanpostprocesor-learning/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="朱兴生">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/6222636?v=3&s=460">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="码农戏码">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="码农戏码" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/10/beanpostprocesor-learning/" itemprop="url">
                  BeanPostProcessor学习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-10T21:33:46+08:00">
                2017-07-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码解读/" itemprop="url" rel="index">
                    <span itemprop="name">源码解读</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          
	
	  
	  <span class="post-letters-count">
	    &nbsp; | &nbsp;
	    <span>2,050 字</span>
	    &nbsp; | &nbsp;
	    <span>11 min</span>
	  </span>
	  

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>BeanPostProcessor是什么？在看bean初始化时，看到了很多的BeanPostProcessor，具体作用还真搞不清楚。</p>
<p>前人说这是spring的扩展点，遵循“开-闭原则”的一个扩展。可以进行自定义的实例化、初始化、依赖装配、依赖检查等流程，即可以覆盖默认的实例化，也可以增强初始化、依赖注入、依赖检查等流程<br>但我还是一脸蒙逼，到底是什么鬼？</p>
<p>网上找几个实例来个大体认知一下</p>
<p>对所有bean做个代理:<a href="http://guoliangqi.iteye.com/blog/635826" target="_blank" rel="external">http://guoliangqi.iteye.com/blog/635826</a></p>
<p>对bean做一些改动:<a href="http://blog.csdn.net/partner4java/article/details/6973782" target="_blank" rel="external">http://blog.csdn.net/partner4java/article/details/6973782</a></p>
<p>改变Bean的属性值:<a href="http://winneryj.iteye.com/blog/307736" target="_blank" rel="external">http://winneryj.iteye.com/blog/307736</a></p>
<p>做预加载:<a href="http://292528867.iteye.com/blog/2159499" target="_blank" rel="external">http://292528867.iteye.com/blog/2159499</a><br>感觉这个可以使用init-method来实现</p>
<p>这些实例都是对bean的属性和行为都可以修改</p>
<h1 id="BeanPostProcessor定义"><a href="#BeanPostProcessor定义" class="headerlink" title="BeanPostProcessor定义"></a>BeanPostProcessor定义</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Factory hook that allows for custom modification of new bean instances,</div><div class="line"> * e.g. checking for marker interfaces or wrapping them with proxies.</div><div class="line"> * 大体意思是可以检查相应的标识接口完成一些自定义功能实现，如包装目标对象到代理对象。</div><div class="line"> */</div><div class="line">public interface BeanPostProcessor &#123;</div><div class="line">    /**</div><div class="line">     * Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;before&lt;/i&gt; any bean</div><div class="line">     * initialization callbacks (like InitializingBean&apos;s &#123;@code afterPropertiesSet&#125;</div><div class="line">     * or a custom init-method). The bean will already be populated with property values.</div><div class="line">     * The returned bean instance may be a wrapper around the original.</div><div class="line">     * &lt;p&gt;The default implementation returns the given &#123;@code bean&#125; as-is.</div><div class="line">     * @param bean the new bean instance</div><div class="line">     * @param beanName the name of the bean</div><div class="line">     * @return the bean instance to use, either the original or a wrapped one;</div><div class="line">     * if &#123;@code null&#125;, no subsequent BeanPostProcessors will be invoked</div><div class="line">     * @throws org.springframework.beans.BeansException in case of errors</div><div class="line">     * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet</div><div class="line">     */</div><div class="line">    Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;</div><div class="line">    /**</div><div class="line">	 * Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;after&lt;/i&gt; any bean</div><div class="line">	 * initialization callbacks (like InitializingBean&apos;s &#123;@code afterPropertiesSet&#125;</div><div class="line">	 * or a custom init-method). The bean will already be populated with property values.</div><div class="line">	 * The returned bean instance may be a wrapper around the original.</div><div class="line">	 * &lt;p&gt;In case of a FactoryBean, this callback will be invoked for both the FactoryBean</div><div class="line">	 * instance and the objects created by the FactoryBean (as of Spring 2.0). The</div><div class="line">	 * post-processor can decide whether to apply to either the FactoryBean or created</div><div class="line">	 * objects or both through corresponding &#123;@code bean instanceof FactoryBean&#125; checks.</div><div class="line">	 * &lt;p&gt;This callback will also be invoked after a short-circuiting triggered by a</div><div class="line">	 * &#123;@link InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation&#125; method,</div><div class="line">	 * in contrast to all other BeanPostProcessor callbacks.</div><div class="line">	 * &lt;p&gt;The default implementation returns the given &#123;@code bean&#125; as-is.</div><div class="line">	 * @param bean the new bean instance</div><div class="line">	 * @param beanName the name of the bean</div><div class="line">	 * @return the bean instance to use, either the original or a wrapped one;</div><div class="line">	 * if &#123;@code null&#125;, no subsequent BeanPostProcessors will be invoked</div><div class="line">	 * @throws org.springframework.beans.BeansException in case of errors</div><div class="line">	 * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet</div><div class="line">	 * @see org.springframework.beans.factory.FactoryBean</div><div class="line">	 */</div><div class="line">    Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接口结构很简单，两个方法</p>
<ol>
<li>postProcessBeforeInitialization：在Spring调用任何bean的初始化钩子（例如InitializingBean.afterPropertiesSet或者init方法）之前被调用。</li>
<li>postProcessAfterInitialization：Spring在成功完成嵌入初始化以后调用他。</li>
</ol>
<h1 id="注册beanpostprocessor"><a href="#注册beanpostprocessor" class="headerlink" title="注册beanpostprocessor"></a>注册beanpostprocessor</h1><p>这个还是在AbstractApplicationContext的refresh()中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// Invoke factory processors registered as beans in the context.</div><div class="line">//注册beanfactorypostProcessor</div><div class="line">invokeBeanFactoryPostProcessors(beanFactory);</div><div class="line"></div><div class="line">// Register bean processors that intercept bean creation.</div><div class="line">//注册beanpostprocessor</div><div class="line">registerBeanPostProcessors(beanFactory);</div></pre></td></tr></table></figure></p>
<p>具体的委托给PostProcessorRegistrationDelegate<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">	 * Instantiate and invoke all registered BeanPostProcessor beans,</div><div class="line">	 * respecting explicit order if given.</div><div class="line">	 * &lt;p&gt;Must be called before any instantiation of application beans.</div><div class="line">	 */</div><div class="line">	protected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) &#123;</div><div class="line">		PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>注册前需要对Processor进行一下排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">	 * 对所有beanpostprocessor进行排序后再注册</div><div class="line">	 * @param beanFactory</div><div class="line">	 * @param applicationContext</div><div class="line">	 */</div><div class="line">	public static void registerBeanPostProcessors(</div><div class="line">			ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) &#123;</div><div class="line"></div><div class="line">		String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);</div><div class="line"></div><div class="line">		// Register BeanPostProcessorChecker that logs an info message when</div><div class="line">		// a bean is created during BeanPostProcessor instantiation, i.e. when</div><div class="line">		// a bean is not eligible for getting processed by all BeanPostProcessors.</div><div class="line">		int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;</div><div class="line">		beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</div><div class="line"></div><div class="line">		// Separate between BeanPostProcessors that implement PriorityOrdered,</div><div class="line">		// Ordered, and the rest.</div><div class="line">		//排序分类，前面的是PriorityOrder，再是Order,最后是没有实现排序接口的</div><div class="line">		List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();</div><div class="line">		List&lt;BeanPostProcessor&gt; internalPostProcessors = new ArrayList&lt;&gt;();</div><div class="line">		List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();</div><div class="line">		List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();</div><div class="line">		for (String ppName : postProcessorNames) &#123;</div><div class="line">			if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</div><div class="line">				BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</div><div class="line">				priorityOrderedPostProcessors.add(pp);</div><div class="line">				if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</div><div class="line">					internalPostProcessors.add(pp);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</div><div class="line">				orderedPostProcessorNames.add(ppName);</div><div class="line">			&#125;</div><div class="line">			else &#123;</div><div class="line">				nonOrderedPostProcessorNames.add(ppName);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// First, register the BeanPostProcessors that implement PriorityOrdered.</div><div class="line">		sortPostProcessors(beanFactory, priorityOrderedPostProcessors);</div><div class="line">		registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</div><div class="line"></div><div class="line">		// Next, register the BeanPostProcessors that implement Ordered.</div><div class="line">		List&lt;BeanPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();</div><div class="line">		for (String ppName : orderedPostProcessorNames) &#123;</div><div class="line">			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</div><div class="line">			orderedPostProcessors.add(pp);</div><div class="line">			if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</div><div class="line">				internalPostProcessors.add(pp);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		sortPostProcessors(beanFactory, orderedPostProcessors);</div><div class="line">		registerBeanPostProcessors(beanFactory, orderedPostProcessors);</div><div class="line"></div><div class="line">		// Now, register all regular BeanPostProcessors.</div><div class="line">		List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();</div><div class="line">		for (String ppName : nonOrderedPostProcessorNames) &#123;</div><div class="line">			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</div><div class="line">			nonOrderedPostProcessors.add(pp);</div><div class="line">			if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</div><div class="line">				internalPostProcessors.add(pp);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</div><div class="line"></div><div class="line">		// Finally, re-register all internal BeanPostProcessors.</div><div class="line">		sortPostProcessors(beanFactory, internalPostProcessors);</div><div class="line">		registerBeanPostProcessors(beanFactory, internalPostProcessors);</div><div class="line"></div><div class="line">		// Re-register post-processor for detecting inner beans as ApplicationListeners,</div><div class="line">		// moving it to the end of the processor chain (for picking up proxies etc).</div><div class="line">		beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">	 * Register the given BeanPostProcessor beans.</div><div class="line">	 * 具体注册行为，放到beanfactory的proocessor集合中</div><div class="line">	 */</div><div class="line">	private static void registerBeanPostProcessors(</div><div class="line">			ConfigurableListableBeanFactory beanFactory, List&lt;BeanPostProcessor&gt; postProcessors) &#123;</div><div class="line"></div><div class="line">		for (BeanPostProcessor postProcessor : postProcessors) &#123;</div><div class="line">			beanFactory.addBeanPostProcessor(postProcessor);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h1 id="BeanPostProcessor调用"><a href="#BeanPostProcessor调用" class="headerlink" title="BeanPostProcessor调用"></a>BeanPostProcessor调用</h1><p>AbstractAutowireCapableBeanFactory的doCreateBean()方法里<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// Initialize the bean instance.</div><div class="line">		//bean实例化完成</div><div class="line">		Object exposedObject = bean;</div><div class="line">		try &#123;</div><div class="line">			//属性赋值</div><div class="line">			populateBean(beanName, mbd, instanceWrapper);</div><div class="line">			if (exposedObject != null) &#123;</div><div class="line">				//这里面处理aware,init methods and bean post processors</div><div class="line">				exposedObject = initializeBean(beanName, exposedObject, mbd);</div><div class="line">			&#125;</div><div class="line">		&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123;</div><div class="line">		//aware方法</div><div class="line">		if (System.getSecurityManager() != null) &#123;</div><div class="line">			AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</div><div class="line">				@Override</div><div class="line">				public Object run() &#123;</div><div class="line">					invokeAwareMethods(beanName, bean);</div><div class="line">					return null;</div><div class="line">				&#125;</div><div class="line">			&#125;, getAccessControlContext());</div><div class="line">		&#125;</div><div class="line">		else &#123;</div><div class="line">			invokeAwareMethods(beanName, bean);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		Object wrappedBean = bean;</div><div class="line">		//postProcessBeforeInitialization方法</div><div class="line">		if (mbd == null || !mbd.isSynthetic()) &#123;</div><div class="line">			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		try &#123;</div><div class="line">			//调用init-method</div><div class="line">			invokeInitMethods(beanName, wrappedBean, mbd);</div><div class="line">		&#125;</div><div class="line">		catch (Throwable ex) &#123;</div><div class="line">			throw new BeanCreationException(</div><div class="line">					(mbd != null ? mbd.getResourceDescription() : null),</div><div class="line">					beanName, &quot;Invocation of init method failed&quot;, ex);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		//postProcessAfterInitialization</div><div class="line">		if (mbd == null || !mbd.isSynthetic()) &#123;</div><div class="line">			wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</div><div class="line">		&#125;</div><div class="line">		return wrappedBean;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private void invokeAwareMethods(final String beanName, final Object bean) &#123;</div><div class="line">		if (bean instanceof Aware) &#123;</div><div class="line">			if (bean instanceof BeanNameAware) &#123;</div><div class="line">				((BeanNameAware) bean).setBeanName(beanName);</div><div class="line">			&#125;</div><div class="line">			if (bean instanceof BeanClassLoaderAware) &#123;</div><div class="line">				((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());</div><div class="line">			&#125;</div><div class="line">			if (bean instanceof BeanFactoryAware) &#123;</div><div class="line">				((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>通过代码，可以看出bean的顺序</p>
<p><strong>bean实例化 –&gt; bean属性注入 –&gt; aware接口 –&gt; postProcessBeforeInitialization方法 –&gt; init-method –&gt; postProcessAfterInitialization</strong></p>
<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>如果要实现代理类有对应的接口，Spring AOP 默认使用 JDK 自带的 InvocationHandler 来实现代理类。</p>
<p>如果没有对应的接口，Spring 使用 CGLib 来实现代理类</p>
<p>那AOP跟这儿的BeanPostProcessor有什么关系呢？ 其实还有一个aspectj</p>
<blockquote>
<p>Spring AOP也是对目标类增强，生成代理类。但是与AspectJ的最大区别在于—Spring AOP的运行时增强，而AspectJ是编译时增强。</p>
<p>曾经以为AspectJ是Spring AOP一部分，是因为Spring AOP使用了AspectJ的Annotation。使用了Aspect来定义切面,使用Pointcut来定义切入点，使用Advice来定义增强处理。<br>虽然使用了Aspect的Annotation，但是并没有使用它的编译器和织入器。其实现原理是JDK 动态代理，在运行时生成代理类。</p>
</blockquote>
<p>spring在处理aspectj时，其实使用的是BeanPostProcessor机制</p>
<p>主要处理类是AspectJAwareAdvisorAutoProxyCreator<br><img src="http://oirwmbp4e.bkt.clouddn.com/network/aspectjawareadvisorautoproxycreator.jpg" alt="image"></p>
<p>此类实现了BeanPostProcessor接口，在创建完bean后，postProcessAfterInitialization<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</div><div class="line">		if (bean != null) &#123;</div><div class="line">			Object cacheKey = getCacheKey(bean.getClass(), beanName);</div><div class="line">			if (!this.earlyProxyReferences.contains(cacheKey)) &#123;</div><div class="line">				return wrapIfNecessary(bean, beanName, cacheKey);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return bean;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">/**</div><div class="line">	 * Wrap the given bean if necessary, i.e. if it is eligible for being proxied.</div><div class="line">	 * @param bean the raw bean instance</div><div class="line">	 * @param beanName the name of the bean</div><div class="line">	 * @param cacheKey the cache key for metadata access</div><div class="line">	 * @return a proxy wrapping the bean, or the raw bean instance as-is</div><div class="line">	 */</div><div class="line">	protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) &#123;</div><div class="line">		if (beanName != null &amp;&amp; this.targetSourcedBeans.contains(beanName)) &#123;</div><div class="line">			return bean;</div><div class="line">		&#125;</div><div class="line">		if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) &#123;</div><div class="line">			return bean;</div><div class="line">		&#125;</div><div class="line">		if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</div><div class="line">			this.advisedBeans.put(cacheKey, Boolean.FALSE);</div><div class="line">			return bean;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// Create proxy if we have advice.</div><div class="line">		Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);</div><div class="line">		if (specificInterceptors != DO_NOT_PROXY) &#123;</div><div class="line">			this.advisedBeans.put(cacheKey, Boolean.TRUE);</div><div class="line">			//创建proxy</div><div class="line">			Object proxy = createProxy(</div><div class="line">					bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));</div><div class="line">			this.proxyTypes.put(cacheKey, proxy.getClass());</div><div class="line">			return proxy;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		this.advisedBeans.put(cacheKey, Boolean.FALSE);</div><div class="line">		return bean;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">protected Object createProxy(</div><div class="line">			Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource) &#123;</div><div class="line"></div><div class="line">		if (this.beanFactory instanceof ConfigurableListableBeanFactory) &#123;</div><div class="line">			AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass);</div><div class="line">		&#125;</div><div class="line">		//通过proxyFactory去创建proxy</div><div class="line">		ProxyFactory proxyFactory = new ProxyFactory();</div><div class="line">		proxyFactory.copyFrom(this);</div><div class="line"></div><div class="line">		if (!proxyFactory.isProxyTargetClass()) &#123;</div><div class="line">			if (shouldProxyTargetClass(beanClass, beanName)) &#123;</div><div class="line">				proxyFactory.setProxyTargetClass(true);</div><div class="line">			&#125;</div><div class="line">			else &#123;</div><div class="line">				evaluateProxyInterfaces(beanClass, proxyFactory);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</div><div class="line">		for (Advisor advisor : advisors) &#123;</div><div class="line">			proxyFactory.addAdvisor(advisor);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		proxyFactory.setTargetSource(targetSource);</div><div class="line">		customizeProxyFactory(proxyFactory);</div><div class="line"></div><div class="line">		proxyFactory.setFrozen(this.freezeProxy);</div><div class="line">		if (advisorsPreFiltered()) &#123;</div><div class="line">			proxyFactory.setPreFiltered(true);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		return proxyFactory.getProxy(getProxyClassLoader());</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>进入到ProxyFactory里面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public Object getProxy(ClassLoader classLoader) &#123;</div><div class="line">		return createAopProxy().getProxy(classLoader);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">protected final synchronized AopProxy createAopProxy() &#123;</div><div class="line">		if (!this.active) &#123;</div><div class="line">			activate();</div><div class="line">		&#125;</div><div class="line">		//这儿又来一个factory</div><div class="line">		return getAopProxyFactory().createAopProxy(this);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">/**    其实是个默认的实现，没有多态</div><div class="line">	 * Create a new ProxyCreatorSupport instance.</div><div class="line">	 */</div><div class="line">	public ProxyCreatorSupport() &#123;</div><div class="line">		this.aopProxyFactory = new DefaultAopProxyFactory();</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>在这个DefaultAopProxyFactory里面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">	public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException &#123;</div><div class="line">		if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</div><div class="line">			Class&lt;?&gt; targetClass = config.getTargetClass();</div><div class="line">			if (targetClass == null) &#123;</div><div class="line">				throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; +</div><div class="line">						&quot;Either an interface or a target is required for proxy creation.&quot;);</div><div class="line">			&#125;</div><div class="line">			//targetClass如果是接口，或者是实现了Proxy接口，就使用JDK动态代理了</div><div class="line">			if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</div><div class="line">				return new JdkDynamicAopProxy(config);</div><div class="line">			&#125;</div><div class="line">			//不然使用cglib方式</div><div class="line">			return new ObjenesisCglibAopProxy(config);</div><div class="line">		&#125;</div><div class="line">		else &#123;</div><div class="line">			return new JdkDynamicAopProxy(config);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>再深入就是aop自身的知识点了，后面再写文章</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过一系列的实现，其实还是开篇的一句话</p>
<p>BeanPostProcessor是spring的扩展点，遵循“开-闭原则”的一个扩展。</p>
<p>可以进行自定义的实例化、初始化、依赖装配、依赖检查等流程，即可以覆盖默认的实例化，也可以增强初始化、依赖注入、依赖检查等流程</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      
      <! -- 添加微信图标 -->
    
    
    
    

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars0.githubusercontent.com/u/6222636?v=3&s=460"
               alt="朱兴生" />
          <p class="site-author-name" itemprop="name">朱兴生</p>
          <p class="site-description motion-element" itemprop="description">彪悍的人生需要书写</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">31</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/zhuxingsheng" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">朱兴生</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">共85.6k字</span>
</div>


        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	




  
  

  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  


</body>
</html>
