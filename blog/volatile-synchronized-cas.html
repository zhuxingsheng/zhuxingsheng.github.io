<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
<script type="text/javascript">
    var host = "zhuxingsheng.github.io";
    if ((host == window.location.host) && (window.location.protocol != "https:"))
        window.location = window.location.toString().replace(/^http:/, "https:");
</script>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






  <meta name="baidu-site-verification" content="MXFRoVpC6c" />







  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="volatile,cas," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="之前写了《熔断》，以及其中使用的《计数器算法》；本来是要接着再写不通过定时器清理计数环的计数器算法，看了下我司亿级网关的计数器，百行的代码，但却是满满bug。不得穿插一下并发的基础知识 处理并发，最基本的元件就这三样  synchronized 这个关键字不必讲，从开始多线程，它就进入你的视线 volatile 在jdk5之后大放异彩 cas 在J.U.C中大量使用，他与volatile组合是J.">
<meta name="keywords" content="volatile,cas">
<meta property="og:type" content="article">
<meta property="og:title" content="volatile synchronized  cas">
<meta property="og:url" content="http://blog.zhuxingsheng.com/blog/volatile-synchronized-cas.html">
<meta property="og:site_name" content="码农戏码">
<meta property="og:description" content="之前写了《熔断》，以及其中使用的《计数器算法》；本来是要接着再写不通过定时器清理计数环的计数器算法，看了下我司亿级网关的计数器，百行的代码，但却是满满bug。不得穿插一下并发的基础知识 处理并发，最基本的元件就这三样  synchronized 这个关键字不必讲，从开始多线程，它就进入你的视线 volatile 在jdk5之后大放异彩 cas 在J.U.C中大量使用，他与volatile组合是J.">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://hexo.qnimages.zhuxingsheng.com/201806261839_931.png?imageView2/0/q/75|watermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2|imageslim">
<meta property="og:image" content="http://hexo.qnimages.zhuxingsheng.com/201806281746_198.png?imageView2/0/q/75|watermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2|imageslim">
<meta property="og:image" content="http://hexo.qnimages.zhuxingsheng.com/201807021342_940.png?imageView2/0/q/75|watermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2|imageslim">
<meta property="og:image" content="http://hexo.qnimages.zhuxingsheng.com/201807021531_692.png?imageView2/0/q/75|watermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2|imageslim">
<meta property="og:image" content="http://hexo.qnimages.zhuxingsheng.com/201807021457_96.png?imageView2/0/q/75|watermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2|imageslim">
<meta property="og:image" content="http://hexo.qnimages.zhuxingsheng.com/201807021506_541.png?imageView2/0/q/75|watermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2|imageslim">
<meta property="og:image" content="http://hexo.qnimages.zhuxingsheng.com/201807021516_753.png?imageView2/0/q/75|watermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2|imageslim">
<meta property="og:image" content="http://hexo.qnimages.zhuxingsheng.com/201807021529_836.png?imageView2/0/q/75|watermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2|imageslim">
<meta property="og:image" content="http://hexo.qnimages.zhuxingsheng.com/201807031633_466.png?imageView2/0/q/75|watermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2|imageslim">
<meta property="og:image" content="http://hexo.qnimages.zhuxingsheng.com/201807031634_763.png?imageView2/0/q/75|watermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2|imageslim">
<meta property="og:image" content="http://hexo.qnimages.zhuxingsheng.com/201807031406_452.png?imageView2/0/q/75|watermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2|imageslim">
<meta property="og:image" content="http://hexo.qnimages.zhuxingsheng.com/201807031409_511.png?imageView2/0/q/75|watermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2|imageslim">
<meta property="og:image" content="http://hexo.qnimages.zhuxingsheng.com/201807031410_993.png?imageView2/0/q/75|watermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2|imageslim">
<meta property="og:image" content="http://hexo.qnimages.zhuxingsheng.com/201807031735_910.png?imageView2/0/q/75|watermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2|imageslim">
<meta property="og:updated_time" content="2018-11-18T02:49:31.086Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="volatile synchronized  cas">
<meta name="twitter:description" content="之前写了《熔断》，以及其中使用的《计数器算法》；本来是要接着再写不通过定时器清理计数环的计数器算法，看了下我司亿级网关的计数器，百行的代码，但却是满满bug。不得穿插一下并发的基础知识 处理并发，最基本的元件就这三样  synchronized 这个关键字不必讲，从开始多线程，它就进入你的视线 volatile 在jdk5之后大放异彩 cas 在J.U.C中大量使用，他与volatile组合是J.">
<meta name="twitter:image" content="http://hexo.qnimages.zhuxingsheng.com/201806261839_931.png?imageView2/0/q/75|watermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2|imageslim">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 'undefined',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.zhuxingsheng.com/blog/volatile-synchronized-cas.html"/>




  <title> volatile synchronized  cas | 码农戏码 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?48897be5dd7a377cc247d8870a476fb8";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">码农戏码</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://blog.zhuxingsheng.com/blog/volatile-synchronized-cas.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="朱兴生">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/6222636?v=3&s=460">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="码农戏码">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="码农戏码" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                volatile synchronized  cas
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-26T10:43:00+08:00">
                2018-06-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          
	
	  
	  <span class="post-letters-count">
	    &nbsp; | &nbsp;
	    <span>7.6k 字</span>
	    &nbsp; | &nbsp;
	    <span>28 min</span>
	  </span>
	  

          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>之前写了《熔断》，以及其中使用的《计数器算法》；本来是要接着再写不通过定时器清理计数环的计数器算法，看了下我司亿级网关的计数器，百行的代码，但却是满满bug。不得穿插一下并发的基础知识</p>
<p>处理并发，最基本的元件就这三样</p>
<ol>
<li>synchronized 这个关键字不必讲，从开始多线程，它就进入你的视线</li>
<li>volatile 在jdk5之后大放异彩</li>
<li>cas 在J.U.C中大量使用，他与volatile组合是J.U.C的基石</li>
</ol>
<h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p>谈到多线程，不得不说的JMM，这儿只做简单阐述</p>
<p>在jsr-133中是这么定义的</p>
<blockquote>
<p>A memory model describes, given a program and an execution trace of that program,<br>whether the execution trace is a legal execution of the program. For the Java programming language,<br>the memory model works by examining each read in an execution trace and checking that the write observed by that read is valid according to certain rules.</p>
</blockquote>
<p>也就是说<strong>一个内存模型描述了一个给定的程序和和它的执行路径是否一个合法的执行路径</strong>。对于java序言来说，内存模型通过考察在程序执行路径中每一个读操作，根据特定的规则，检查写操作对应的读操作是否能是有效的。<br>java内存模型只是定义了一个规范，具体的实现可以是根据实际情况自由实现的。但是实现要满足java内存模型定义的规范。</p>
<p>从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java内存模型的抽象示意图如下：</p>
<p><img src="http://hexo.qnimages.zhuxingsheng.com/201806261839_931.png?imageView2/0/q/75|watermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2|imageslim" alt=""></p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>由于java的内存模型中有工作内存和主内存之分，所以可能会有两种问题：</p>
<p>（1）线程可能在工作内存中更改变量的值，而没有及时写回到主内存，其他线程从主内存读取的数据仍然是老数据</p>
<p>（2）线程在工作内存中更改了变量的值，写回主内存了，但是其他线程之前也读取了这个变量的值，这样其他线程的工作内存中，此变量的值没有被及时更新。</p>
<p>为了解决这个问题，可以使用同步机制，也可以把变量声明为volatile，</p>
<p><strong>JMM:对volatile字段的写入操作happens-before于每一个后续的同一个字段的读操作</strong></p>
<p>如何理解呢？</p>
<p>（1）每次对变量的修改，都会引起处理器缓存（工作内存）写回到主内存。</p>
<p>（2）一个工作内存回写到主内存会导致其他线程的处理器缓存（工作内存）无效。</p>
<p>基于以上两点，如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。</p>
<h3 id="volatile原子性"><a href="#volatile原子性" class="headerlink" title="volatile原子性"></a>volatile原子性</h3><p>Java内存模型要求lock, unlock, read, load, assign, use, write这个8个操作都具有原子性，但是同时又对64位的数据类型(long&amp;double)给了一个相对宽松的规定，就是允许虚拟机将没有被volatile参数修饰的64位数据类型的<strong>读写划分为两次32位的操作来进行</strong>，即允许虚拟机将load, store, read, write这个4个操作实现为非原子的。</p>
<p>当线程把主存中的long/double类型的值读到线程内存中时，可能是两次32位值的写操作，显而易见，如果几个线程同时操作，那么就可能会出现高低2个32位值出错的情况发生。</p>
<p>java虚拟机规范（jvm spec）中，规定了声明为volatile的long和double变量的get和set操作是原子的</p>
<blockquote>
<p>Writes and reads of volatile long and double values are always atomic.<br>Writes to and reads of references are always atomic, regardless of whether they are implemented as 32-bit or 64-bit values.</p>
</blockquote>
<p>关于volatile变量的使用建议：多线程环境下需要共享的变量采用volatile声明；如果使用了同步块或者是常量，则没有必要使用volatile。</p>
<p><em>当然，需要注意的是，这儿的原子性，与i++不是一个概念</em></p>
<p><strong>前者是单个变量写，后者是复合操作</strong></p>
<h3 id="volatile实现"><a href="#volatile实现" class="headerlink" title="volatile实现"></a>volatile实现</h3><p>volatile是如何做到可见性的呢？</p>
<p>来段代码看下，定义两个变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private int i;</span><br><span class="line"></span><br><span class="line">private volatile int j;</span><br></pre></td></tr></table></figure></p>
<p>通过java -verbos XX.class 查看一下生成的编译码</p>
<p><img src="http://hexo.qnimages.zhuxingsheng.com/201806281746_198.png?imageView2/0/q/75|watermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2|imageslim" alt=""></p>
<p>发现唯一的区别就在于volatile多了<strong>ACC_VOLATILE</strong>标识</p>
<p>通过查看JVM源码，可以看到如下代码</p>
<p><img src="http://hexo.qnimages.zhuxingsheng.com/201807021342_940.png?imageView2/0/q/75|watermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2|imageslim" alt=""></p>
<p>这就是大名鼎鼎的“内存屏障”的抽象</p>
<h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><p><strong>内存屏障Memory Barriers</strong>：是一组处理器指令，用于实现对内存操作的顺序限制。</p>
<p>Memory barrier 能够让 CPU 或编译器在内存访问上有序。一个 Memory barrier 之前的内存访问操作必定先于其之后的完成。</p>
<p><strong>内存屏障有两个能力</strong>：</p>
<ol>
<li>阻止屏障两边的指令重排序</li>
<li>强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效</li>
</ol>
<p><strong>Memory barrier 分类</strong>：</p>
<ol>
<li>编译器 barrier</li>
<li>CPU Memory barrier</li>
</ol>
<p><strong>内存屏障列表</strong>：</p>
<p><img src="http://hexo.qnimages.zhuxingsheng.com/201807021531_692.png?imageView2/0/q/75|watermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2|imageslim" alt=""></p>
<p><strong>JMM针对编译器制定的volatile重排序规则表</strong>：<br><img src="http://hexo.qnimages.zhuxingsheng.com/201807021457_96.png?imageView2/0/q/75|watermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2|imageslim" alt=""></p>
<p>举例来说，第三行最后一个单元格的意思是：在程序顺序中，当第一个操作为普通变量的读或写时，如果第二个操作为volatile写，则编译器不能重排序这两个操作。</p>
<p>从上表我们可以看出：</p>
<p>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后</p>
<p>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前</p>
<p>当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。</p>
<p><strong>volatile的内存语义的（JVM）实现策略</strong>：</p>
<ol>
<li>在每个volatile写操作前，会插入一个StoreStore屏障；</li>
<li>在每个volatile写操作后，会插入一个storeload屏障；</li>
<li>在每个volatile读操作后，插入一个LoadLoad，一个LoadStore屏障</li>
</ol>
<p><img src="http://hexo.qnimages.zhuxingsheng.com/201807021506_541.png?imageView2/0/q/75|watermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2|imageslim" alt=""><br>上图中的StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作已经对任意处理器可见了。这是因为StoreStore屏障将保障上面所有的普通写在volatile写之前刷新到主内存。</p>
<p>这里比较有意思的是volatile写后面的StoreLoad屏障。这个屏障的作用是避免volatile写与后面可能有的volatile读/写操作重排序。因为编译器常常无法准确判断在一个volatile写的后面，是否需要插入一个StoreLoad屏障（比如，一个volatile写之后方法立即return）。为了保证能正确实现volatile的内存语义，JMM在这里采取了保守策略：在每个volatile写的后面或在每个volatile读的前面插入一个StoreLoad屏障。从整体执行效率的角度考虑，JMM选择了在每个volatile写的后面插入一个StoreLoad屏障。因为volatile写-读内存语义的常见使用模式是：一个写线程写volatile变量，多个读线程读同一个volatile变量。当读线程的数量大大超过写线程时，选择在volatile写之后插入StoreLoad屏障将带来可观的执行效率的提升。从这里我们可以看到JMM在实现上的一个特点：首先确保正确性，然后再去追求执行效率。</p>
<p><img src="http://hexo.qnimages.zhuxingsheng.com/201807021516_753.png?imageView2/0/q/75|watermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2|imageslim" alt=""></p>
<p>上图中的LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序。LoadStore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序。</p>
<h4 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h4><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p>
<ol>
<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。<br>从java源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</li>
</ol>
<p><img src="http://hexo.qnimages.zhuxingsheng.com/201807021529_836.png?imageView2/0/q/75|watermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2|imageslim" alt=""></p>
<p>上述的1属于编译器重排序，2和3属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求java编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel称之为memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。<br>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p>
<p>比如现在有一段代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = 1; //代码1</span><br><span class="line">b = 1; //代码2</span><br></pre></td></tr></table></figure></p>
<p>编译器和处理为了提高并行度，可以将代码1和2调整顺序，即先执行代码2和代码1</p>
<p>但是若是其他情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = 1; //代码3</span><br><span class="line">b = a; //代码4</span><br></pre></td></tr></table></figure></p>
<p>这种情况因为代码3和4存在数据依赖，存在hanpens-before关系，处理器和编译器会遵守 as-if-serial原则，不会调整顺序。</p>
<p><strong>as-if-serial原则</strong>：不管怎么重排序，单线程程序的执行结果不能发生改变。编译器、Runtime和处理器也是如此。这个语义相当于把单线程保护起来了，所以即使编译器和处理器对指令序列进行了重排序，我们也会认为程序指令并没有发生重排序</p>
<p><strong>hanpens-before</strong>：指前一个操作对后一个操作可见，并不是前一个操作必须在后一个操作之前执行。</p>
<p>当存在控制依赖时，编译器和处理器会采取猜测执行机制来提高并行度，如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = 1;</span><br><span class="line">flag = true ;</span><br><span class="line">if(flag)&#123; //代码5</span><br><span class="line">    a * = 2; //代码6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码5和6不存在数据依赖，可能会重排，处理器和编译器会先将代码6的执行结果放在缓冲区，等执行代码5之后，将缓冲区的结果直接赋值给a</p>
<p><strong>从JSR-133开始，volatile写-读建立的happens before关系</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class VolatileExample &#123;</span><br><span class="line">    int a = 0;</span><br><span class="line">    volatile boolean flag = false;</span><br><span class="line"> </span><br><span class="line">    public void writer() &#123;</span><br><span class="line">        a = 1;                   //1</span><br><span class="line">        flag = true;               //2</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void reader() &#123;</span><br><span class="line">        if (flag) &#123;                //3</span><br><span class="line">            int i =  a;           //4</span><br><span class="line">            ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假设线程A执行writer()方法之后，线程B执行reader()方法。根据happens before规则，这个过程建立的happens before 关系可以分为两类：<br>·     根据程序次序规则，1 happens before 2; 3 happens before 4。<br>·     根据volatile规则，2 happens before 3。<br>·     根据happens before 的传递性规则，1 happens before 4。<br>上述happens before 关系的图形化表现形式如下：</p>
<p><img src="http://hexo.qnimages.zhuxingsheng.com/201807031633_466.png?imageView2/0/q/75|watermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2|imageslim" alt=""></p>
<p>在上图中，每一个箭头链接的两个节点，代表了一个happens before 关系。黑色箭头表示程序顺序规则；橙色箭头表示volatile规则；蓝色箭头表示组合这些规则后提供的happens before保证。</p>
<p>这里A线程写一个volatile变量后，B线程读同一个volatile变量。<br>A线程在写volatile变量之前所有可见的共享变量，在B线程读同一个volatile变量后，将立即变得对B线程可见。</p>
<p>在JSR-133之前的旧Java内存模型中，虽然不允许volatile变量之间重排序，但旧的Java内存模型允许volatile变量与普通变量之间重排序。<br>在旧的内存模型中，VolatileExample示例程序可能被重排序成下列时序来执行：</p>
<p><img src="http://hexo.qnimages.zhuxingsheng.com/201807031634_763.png?imageView2/0/q/75|watermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2|imageslim" alt=""></p>
<p>在旧的内存模型中，当1和2之间没有数据依赖关系时，1和2之间就可能被重排序（3和4类似）。其结果就是：读线程B执行4时，不一定能看到写线程A在执行1时对共享变量的修改。</p>
<p>因此在旧的内存模型中 ，volatile的写-读没有监视器的释放-获取具有的内存语义。</p>
<p>为了提供一种比监视器锁更轻量级的线程之间通信的机制，JSR-133专家组决定增强</p>
<p>volatile的内存语义：严格限制编译器和处理器对volatile变量与普通变量的重排序，确保volatile的写-读和监视器的释放-获取一样，具有相同的内存语义。</p>
<p>从编译器重排序规则和处理器内存屏障插入策略来看，只要volatile变量与普通变量之间的重排序可能会破坏volatile 的内存语意，这种重排序就会被编译器重排序规则和处理器内存屏障插入策略禁止。</p>
<p>由于volatile仅仅保证对单个volatile变量的读/写具有原子性，而监视器锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。在功能上，监视器锁比volatile更强大；在可伸缩性和执行性能上，volatile更有优势。如果读者想在程序中用volatile代替监视器锁，请一定谨慎。</p>
<h4 id="volatile示例"><a href="#volatile示例" class="headerlink" title="volatile示例"></a>volatile示例</h4><p>还是不太明白，直接跑段代码，区别一下flag带与不带volatile修饰的情况，就很明显了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class TestVolatile &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        ThreadDemo td = new ThreadDemo();</span><br><span class="line">        new Thread(td).start();</span><br><span class="line"></span><br><span class="line">        while(true)&#123;</span><br><span class="line">            if(td.getFlag())&#123;</span><br><span class="line">                System.out.println(&quot;主线程flag:&quot; + td.getFlag());</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ThreadDemo implements Runnable&#123;</span><br><span class="line">    //共享变量</span><br><span class="line">    private volatile   boolean  flag = false;</span><br><span class="line"></span><br><span class="line">    public boolean getFlag() &#123;</span><br><span class="line">        return flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setFlag(boolean flag) &#123;</span><br><span class="line">        this.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(200);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        flag = true;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;其他线程flag=&quot; + getFlag());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>在多线程并发编程中Synchronized一直是元老级角色，很多人都会称呼它为重量级锁</p>
<p>Java SE1.6为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率</p>
<p><img src="http://hexo.qnimages.zhuxingsheng.com/201807031406_452.png?imageView2/0/q/75|watermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2|imageslim" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class SynchronizedTest &#123;</span><br><span class="line"></span><br><span class="line">    public synchronized void test1()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test2()&#123;</span><br><span class="line">        synchronized (this)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>能过javap -v 查看编译后的代码：</p>
<p><img src="http://hexo.qnimages.zhuxingsheng.com/201807031409_511.png?imageView2/0/q/75|watermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2|imageslim" alt=""></p>
<p><img src="http://hexo.qnimages.zhuxingsheng.com/201807031410_993.png?imageView2/0/q/75|watermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2|imageslim" alt=""></p>
<p>从反编译的结果来看，方法的同步并没有通过指令monitorenter和monitorexit来完成（理论上其实也可以通过这两条指令来实现），不过相对于普通方法，其常量池中多了ACC_SYNCHRONIZED标示符。JVM就是根据该标示符来实现方法的同步的：当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。 其实本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。</p>
<p>关于这两条指令的作用，我们直接参考JVM规范中描述：</p>
<p><strong>monitorenter</strong></p>
<blockquote>
<p>Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:<br>• If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.<br>• If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count.<br>• If another thread already owns the monitor associated with objectref, the thread blocks until the monitor’s entry count is zero, then tries again to gain ownership.</p>
</blockquote>
<p>这段话的大概意思为：</p>
<p>每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</p>
<p>1、如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。</p>
<p>2、如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.</p>
<p>3.如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</p>
<p><strong>monitorexit：</strong></p>
<blockquote>
<p>The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref.<br>The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.</p>
</blockquote>
<p>这段话的大概意思为：</p>
<p>执行monitorexit的线程必须是objectref所对应的monitor的所有者。</p>
<p>指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。 </p>
<p>通过这两段描述，我们应该能很清楚的看出Synchronized的实现原理，Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class SynchronizedExample &#123;</span><br><span class="line">int a = 0;</span><br><span class="line">boolean flag = false;</span><br><span class="line"> </span><br><span class="line">public synchronized void writer() &#123;</span><br><span class="line">    a = 1;</span><br><span class="line">    flag = true;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public synchronized void reader() &#123;</span><br><span class="line">    if (flag) &#123;</span><br><span class="line">        int i = a;</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面示例代码中，假设A线程执行writer()方法后，B线程执行reader()方法。这是一个正确同步的多线程程序。</p>
<p><img src="http://hexo.qnimages.zhuxingsheng.com/201807031735_910.png?imageView2/0/q/75|watermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2|imageslim" alt=""></p>
<h2 id="cas"><a href="#cas" class="headerlink" title="cas"></a>cas</h2><p>Java在JDK1.5之前都是靠 synchronized关键字保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有共享变量的锁，都采用独占的方式来访问这些变量。这就是一种独占锁，独占锁其实就是一种悲观锁，所以可以说 synchronized 是悲观锁。</p>
<p>悲观锁机制存在以下问题：　　</p>
<ol>
<li>在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。</li>
<li>一个线程持有锁会导致其它所有需要此锁的线程挂起。</li>
<li>如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。</li>
</ol>
<p>对比于悲观锁的这些问题，另一个更加有效的锁就是乐观锁。</p>
<p>其实乐观锁就是：每次不加锁而是假设没有并发冲突而去完成某项操作，如果因为并发冲突失败就重试，直到成功为止。</p>
<p>CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p>
<p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。<br>（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前值。）<br>CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；<br>否则，不要更改该位置，只告诉我这个位置现在的值即可。”这其实和乐观锁的冲突检查+数据更新的原理是一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final boolean compareAndSet(int expect, int update) &#123;   </span><br><span class="line">    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line"></span><br><span class="line">类似：</span><br><span class="line"></span><br><span class="line">if (this == expect) &#123;</span><br><span class="line"></span><br><span class="line">       this = update</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">&#125;  else &#123;</span><br><span class="line"></span><br><span class="line">       return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h3><p>CAS通过调用JNI的代码实现的。JNI:Java Native Interface为JAVA本地调用，允许java调用其他语言。</p>
<p>而compareAndSwapInt就是借助C来调用CPU底层指令实现的。</p>
<p>下面是sun.misc.Unsafe类的compareAndSwapInt()方法的源代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final native boolean compareAndSwapInt(Object o, long offset,</span><br><span class="line">                                              int expected,</span><br><span class="line">                                              int x);</span><br></pre></td></tr></table></figure></p>
<p>可以看到这是个本地方法调用。这个本地方法在openjdk中依次调用的c++代码为：unsafe.cpp，atomic.cpp和atomicwindowsx86.inline.hpp。这个本地方法的最终实现在openjdk的如下位置：openjdk-7-fcs-src-b147-27jun2011\openjdk\hotspot\src\oscpu\windowsx86\vm\ atomicwindowsx86.inline.hpp（对应于windows操作系统，X86处理器）。下面是对应于intel x86处理器的源代码的片段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// Adding a lock prefix to an instruction on MP machine</span><br><span class="line">// VC++ doesn&apos;t like the lock prefix to be on a single line</span><br><span class="line">// so we can&apos;t insert a label after the lock prefix.</span><br><span class="line">// By emitting a lock prefix, we can define a label after it.</span><br><span class="line">#define LOCK_IF_MP(mp) __asm cmp mp, 0  \</span><br><span class="line">                       __asm je L0      \</span><br><span class="line">                       __asm _emit 0xF0 \</span><br><span class="line">                       __asm L0:</span><br><span class="line"></span><br><span class="line">inline jint     Atomic::cmpxchg    (jint     exchange_value, volatile jint*     dest, jint     compare_value) &#123;</span><br><span class="line">  // alternative for InterlockedCompareExchange</span><br><span class="line">  int mp = os::is_MP();</span><br><span class="line">  __asm &#123;</span><br><span class="line">    mov edx, dest</span><br><span class="line">    mov ecx, exchange_value</span><br><span class="line">    mov eax, compare_value</span><br><span class="line">    LOCK_IF_MP(mp)</span><br><span class="line">    cmpxchg dword ptr [edx], ecx</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上面源代码所示，程序会根据当前处理器的类型来决定是否为cmpxchg指令添加lock前缀。如果程序是在多处理器上运行，就为cmpxchg指令加上lock前缀（lock cmpxchg）。反之，如果程序是在单处理器上运行，就省略lock前缀（单处理器自身会维护单处理器内的顺序一致性，不需要lock前缀提供的内存屏障效果）。</p>
<p>intel的手册对lock前缀的说明如下：</p>
<ol>
<li>确保对内存的读-改-写操作原子执行。在Pentium及Pentium之前的处理器中，带有lock前缀的指令在执行期间会锁住总线，使得其他处理器暂时无法通过总线访问内存。很显然，这会带来昂贵的开销。从Pentium 4，Intel Xeon及P6处理器开始，intel在原有总线锁的基础上做了一个很有意义的优化：如果要访问的内存区域（area of memory）在lock前缀指令执行期间已经在处理器内部的缓存中被锁定（即包含该内存区域的缓存行当前处于独占或以修改状态），并且该内存区域被完全包含在单个缓存行（cache line）中，那么处理器将直接执行该指令。由于在指令执行期间该缓存行会一直被锁定，其它处理器无法读/写该指令要访问的内存区域，因此能保证指令执行的原子性。这个操作过程叫做缓存锁定（cache locking），缓存锁定将大大降低lock前缀指令的执行开销，但是当多处理器之间的竞争程度很高或者指令访问的内存地址未对齐时，仍然会锁住总线。</li>
<li>禁止该指令与之前和之后的读和写指令重排序。</li>
<li>把写缓冲区中的所有数据刷新到内存中。</li>
</ol>
<h3 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h3><p> CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作</p>
<ol>
<li>ABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A<br>从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</li>
<li>循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</li>
<li>只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</li>
</ol>
<h3 id="concurrent包的实现"><a href="#concurrent包的实现" class="headerlink" title="concurrent包的实现"></a>concurrent包的实现</h3><p>由于java的CAS同时具有 volatile 读和volatile写的内存语义，因此Java线程之间的通信现在有了下面四种方式：</p>
<ol>
<li>A线程写volatile变量，随后B线程读这个volatile变量。</li>
<li>A线程写volatile变量，随后B线程用CAS更新这个volatile变量。</li>
<li>A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。</li>
<li>A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。</li>
</ol>
<p>Java的CAS会使用现代处理器上提供的高效机器级别原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键（从本质上来说，能够支持原子性读-改-写指令的计算机器，是顺序计算图灵机的异步等价机器，因此任何现代的多处理器都会去支持某种能对内存执行原子性读-改-写操作的原子指令）。同时，volatile变量的读/写和CAS可以实现线程之间的通信。把这些特性整合在一起，就形成了整个concurrent包得以实现的基石。如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式：</p>
<ul>
<li>首先，声明共享变量为volatile；</li>
<li>然后，使用CAS的原子条件更新来实现线程之间的同步；</li>
<li>同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。</li>
</ul>
<h2 id="volatile-vs-synchronized"><a href="#volatile-vs-synchronized" class="headerlink" title="volatile vs synchronized"></a>volatile vs synchronized</h2><p>1.volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。<br>2.volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。<br>3.volatile仅能实现变量的修改可见性，不能保证原子性（线程A修改了变量还没结束时,另外的线程B可以看到已修改的值,而且可以修改这个变量,而不用等待A释放锁,因为Volatile 变量没上锁）；而synchronized则可以保证变量的修改可见性和原子性。<br>4.volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞和上下文切换。<br>5.volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</p>
<p>6.在使用volatile关键字时要慎重，并不是只要简单类型变量使用volatile修饰，对这个变量的所有操作都是原子操作。当变量的值由自身决定时，如n=n+1、n++ 等，volatile关键字将失效。只有当变量的值和自身无关时对该变量的操作才是原子级别的，如n = m + 1，这个就是原级别的。所以在使用volatile关键时一定要谨慎，如果自己没有把握，可以使用synchronized来代替volatile。</p>
<p>7.“锁是昂贵的”，谨慎使用锁机制。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html" target="_blank" rel="noopener">Java Language Specification</a> </p>
<p><a href="https://www.jianshu.com/p/506c1e38a922" target="_blank" rel="noopener">volatile的底层源码分析</a></p>
<p><a href="http://blog.sina.com.cn/s/blog_12fa13e6e0102v3gm.html" target="_blank" rel="noopener">volatile</a></p>
<p><a href="http://www.cnblogs.com/liaokang/p/5614748.html" target="_blank" rel="noopener">内存屏障（Memory barrier）</a></p>
<p><a href="http://www.infoq.com/cn/articles/java-memory-model-4/" target="_blank" rel="noopener">深入理解Java内存模型（四）——volatile</a></p>

      
    </div>

	<div>
      
        

      
    <strong>volatile synchronized  cas：</strong>
    <a href="http://www.zhuxingsheng.com/blog/volatile-synchronized-cas.html" title="volatile synchronized  cas">http://www.zhuxingsheng.com/blog/volatile-synchronized-cas.html</a>
    </div>

    <div>
      
        
<div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="http://qnimages.zhuxingsheng.com/weixin.jpg" alt="朱兴生 wechat" style="width: 200px; max-width: 100%;"/>
    <div>欢迎大家关注：码农戏码微信公众号</div>
</div>


      
    </div>

    


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/volatile/" rel="tag"># volatile</a>
          
            <a href="/tags/cas/" rel="tag"># cas</a>
          
        </div>
      

 

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/blog/micro-service-fuse-mechanism.html" rel="next" title="微服务-熔断机制">
                <i class="fa fa-chevron-left"></i> 微服务-熔断机制
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/blog/does-active-gc-need.html" rel="prev" title="主动GC是否需要">
                主动GC是否需要 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        
<div class="bdsharebuttonbox">
<a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
<a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
<a href="#" class="bds_youdao" data-cmd="youdao" title="分享到有道云笔记"></a>
<a href="#" class="bds_evernotecn" data-cmd="evernotecn" title="分享到印象笔记"></a>
<a href="#" class="bds_tqq" data-cmd="tqq" title="分享到腾讯微博"></a>
<a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a>
<a href="#" class="bds_renren" data-cmd="renren" title="分享到人人网"></a>
<a href="#" class="bds_copy" data-cmd="copy" title="分享到复制网址"></a>
<a href="#" class="bds_more" data-cmd="more"></a>
</div>

<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{},"image":{"viewList":["tsina","weixin","youdao","evernotecn","tqq","qzone","renren","copy"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","weixin","youdao","evernotecn","tqq","qzone","renren","copy"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>


      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars0.githubusercontent.com/u/6222636?v=3&s=460"
               alt="朱兴生" />
          <p class="site-author-name" itemprop="name">朱兴生</p>
          <p class="site-description motion-element" itemprop="description">彪悍的人生需要书写</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">26</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/zhuxingsheng" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#JMM"><span class="nav-number">1.</span> <span class="nav-text">JMM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile"><span class="nav-number">2.</span> <span class="nav-text">volatile</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile原子性"><span class="nav-number">2.1.</span> <span class="nav-text">volatile原子性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile实现"><span class="nav-number">2.2.</span> <span class="nav-text">volatile实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#内存屏障"><span class="nav-number">2.2.1.</span> <span class="nav-text">内存屏障</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重排序"><span class="nav-number">2.2.2.</span> <span class="nav-text">重排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile示例"><span class="nav-number">2.2.3.</span> <span class="nav-text">volatile示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized"><span class="nav-number">3.</span> <span class="nav-text">synchronized</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cas"><span class="nav-number">4.</span> <span class="nav-text">cas</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS原理"><span class="nav-number">4.1.</span> <span class="nav-text">CAS原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS缺点"><span class="nav-number">4.2.</span> <span class="nav-text">CAS缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#concurrent包的实现"><span class="nav-number">4.3.</span> <span class="nav-text">concurrent包的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile-vs-synchronized"><span class="nav-number">5.</span> <span class="nav-text">volatile vs synchronized</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-number">6.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">朱兴生</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">共75.7k字</span>
</div>


        

<div class="busuanzi-count">

  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	




  
  

  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  


</body>
</html>
