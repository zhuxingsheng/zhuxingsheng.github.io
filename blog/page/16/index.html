<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 8.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.zhuxingsheng.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="彪悍的人生需要书写">
<meta property="og:type" content="website">
<meta property="og:title" content="码农戏码">
<meta property="og:url" content="http://www.zhuxingsheng.com/blog/page/16/index.html">
<meta property="og:site_name" content="码农戏码">
<meta property="og:description" content="彪悍的人生需要书写">
<meta property="og:locale">
<meta property="article:author" content="朱兴生">
<meta property="article:tag" content="DDD,DDD分层,SOLID,DIP,DDD依赖,领域驱动开，binding,微服务，Istio,service mesh,dapr,架构,DDD ACL,motain源码,spring源码,游戏开发,源码分析,java互联网">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://www.zhuxingsheng.com/blog/page/16/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>码农戏码</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">码农戏码</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">新生代农民工的自我修养</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog" rel="section"><i class="home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives" rel="section"><i class="archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags" rel="section"><i class="tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about" rel="section"><i class="user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-在线工具">

    <a href="/tools" rel="section"><i class="gavel fa-fw"></i>在线工具</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://www.zhuxingsheng.com/blog/hashmap-source-code-analysis.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="朱兴生">
      <meta itemprop="description" content="彪悍的人生需要书写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码农戏码">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/hashmap-source-code-analysis.html" class="post-title-link" itemprop="url">Hashmap源码解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-04-06 13:13:00" itemprop="dateCreated datePublished" datetime="2017-04-06T13:13:00+08:00">2017-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-29 15:24:30" itemprop="dateModified" datetime="2021-09-29T15:24:30+08:00">2021-09-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>做什么都怕进入狗咬尾巴的怪圈，上次看hashmap源码还是2012年，这次出去面试时被问到了hashmap的问题，整体思路还是记得的，巴拉巴拉一堆。回来再看一下源码，温习一下</p>
<p>想要了解hashmap，就得先知道一下他的数据结构理论</p>
<h1 id="哈希数据结构"><a href="#哈希数据结构" class="headerlink" title="哈希数据结构"></a>哈希数据结构</h1><p>哈希表（Hash table，也叫散列表），是根据key而直接进行访问的数据结构。也就是说，它通过把key映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
<p>哈希表的做法其实很简单，就是把key通过一个固定的算法函数即所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。</p>
<p>哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上做出取舍。</p>
<h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>哈希查找第一步就是使用哈希函数将键映射成索引。这种映射函数就是哈希函数。如果我们有一个保存0-M数组，那么我们就需要一个能够将任意键转换为该数组范围内的索引（0~M-1）的哈希函数</p>
<p>R.W.Floyed给出的衡量散列思想的三个标准：</p>
<ol>
<li>一个好的hash算法的计算应该是非常快的</li>
<li>一个好的hash算法应该是冲突极小化， 如果存在冲突，应该是冲突均匀化。</li>
</ol>
<h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><p>通过哈希函数，我们可以将键转换为数组的索引(0-M-1)，但是对于两个或者多个键具有相同索引值的情况，我们需要有一种方法来处理这种冲突。</p>
<h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><p>一种比较直接的办法就是，将大小为M 的数组的每一个元素指向一个条链表，链表中的每一个节点都存储散列值为该索引的键值对，这就是拉链法</p>
<p><img src="http://qnimages.zhuxingsheng.com/hash/lalian.png" alt="image"></p>
<p>该方法的基本思想就是选择足够大的M，使得所有的链表都尽可能的短小，以保证查找的效率。对采用拉链法的哈希实现的查找分为两步，首先是根据散列值找到等一应的链表，然后沿着链表顺序找到相应的键。</p>
<p>实现基于拉链表的散列表，目标是选择适当的数组大小M，使得既不会因为空链表而浪费内存空间，也不会因为链表太而在查找上浪费太多时间。拉链表的优点在于，这种数组大小M的选择不是关键性的，如果存入的键多于预期，那么查找的时间只会比选择更大的数组稍长，另外，我们也可以使用更高效的结构来代替链表存储。如果存入的键少于预期，索然有些浪费空间，但是查找速度就会很快。所以当内存不紧张时，我们可以选择足够大的M，可以使得查找时间变为常数，如果内存紧张时，选择尽量大的M仍能够将性能提高M倍。</p>
<h3 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h3><p>线性探测法是开放寻址法解决哈希冲突的一种方法，基本原理为，使用大小为M的数组来保存N个键值对，其中M&gt;N，我们需要使用数组中的空位解决碰撞冲突。如下图所示：</p>
<p><img src="http://qnimages.zhuxingsheng.com/hash/xianxing.png" alt="image"></p>
<p>对照前面的拉链法，在该图中，”Ted Baker” 是有唯一的哈希值153的，但是由于153被”Sandra Dee”占用了。而原先”Snadra Dee”和”John Smith”的哈希值都是152的，但是在对”Sandra Dee”进行哈希的时候发现152已经被占用了，所以往下找发现153没有被占用，所以存放在153上，然后”Ted Baker”哈希到153上，发现已经被占用了，所以往下找，发现154没有被占用，所以值存到了154上。</p>
<p>开放寻址法中最简单的是线性探测法：当碰撞发生时即一个键的散列值被另外一个键占用时，直接检查散列表中的下一个位置即将索引值加1，这样的线性探测会出现三种结果：</p>
<ol>
<li>命中，该位置的键和被查找的键相同</li>
<li>未命中，键为空</li>
<li>继续查找，该位置和键被查找的键不同。</li>
</ol>
<p>线性探查（Linear Probing）方式虽然简单，但是有一些问题，它会导致同类哈希的聚集。在存入的时候存在冲突，在查找的时候冲突依然存在。</p>
<h1 id="hashmap-源码分析"><a href="#hashmap-源码分析" class="headerlink" title="hashmap 源码分析"></a>hashmap 源码分析</h1><p>hashmap原理角度看就是基于哈希数据结构的一种实现，解决冲突的办法是使用拉链法</p>
<p>从源码<strong>基于JDK1.7</strong>看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap&lt;K,V&gt;</span><br><span class="line">    extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure>
<p>HashMap是基于哈希表的Map接口的非同步实现，它提供所有可选的映射操作，并允许使用null键和null值。<br>此集合不保证映射的顺序，特别不保证其顺序永久不变。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        if (initialCapacity &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                               loadFactor);</span><br><span class="line"></span><br><span class="line">        this.loadFactor = loadFactor;</span><br><span class="line">        threshold = initialCapacity;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>两个重要的初始化参数，[初始容量，负载因子]</p>
<p>这个JDK7大版本里面的小版本对hashmap改动好好几次。</p>
<p>这个源码是基于JDK7.0_80的。有些版本在构造函数里面就确保容量是2的N次方，但这个版本没有，很简单的赋值</p>
<p>初始容量16，负载因子0.75</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * The default initial capacity - MUST be a power of two.</span><br><span class="line">    */</span><br><span class="line">   static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * The maximum capacity, used if a higher value is implicitly specified</span><br><span class="line">    * by either of the constructors with arguments.</span><br><span class="line">    * MUST be a power of two &lt;= 1&lt;&lt;30.</span><br><span class="line">    */</span><br><span class="line">   static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * The load factor used when none specified in constructor.</span><br><span class="line">    */</span><br><span class="line">   static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br></pre></td></tr></table></figure>

<h2 id="2的N次方"><a href="#2的N次方" class="headerlink" title="2的N次方"></a>2的N次方</h2><p>很多算法书上都认为想要降低key冲突，最好容量为素数。为什么java却取了个2的N次方呢。</p>
<p>为了将各元素的hashCode保存至长度为Length的key数组中，一般采用取模的方式，即index &#x3D; hashCode % Length。不可避免的，存在多个不同对象的hashCode被安排在同一位置，这就是我们平时所谓的“冲突”。<br>如果仅仅是考虑元素均匀化与冲突极小化，似乎应该将Length取为素数（尽管没有明显的理论来支持这一点，但数学家们通过大量的实践得出结论，对素数取模的产生结果的无关性要大于其它数字）。为此，Craig Larman and Rhett Guthrie《Java Performence》中对此也大加抨击。</p>
<p>为了弄清楚这个问题，Bruce Eckel（Thinking in JAVA的作者）专程采访了java.util.hashMap的作者Joshua Bloch,此设计的原因<br>取模运算在包括Java在内的大多数语言中的效率都十分低下，而当除数为2的N次方时，取模运算将退化为最简单的位运算，其效率明显提升（按照Bruce Eckel给出的数据，大约可以提升5～8倍）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Returns index for hash code h.</span><br><span class="line">     */</span><br><span class="line">    static int indexFor(int h, int length) &#123;</span><br><span class="line">        // assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span><br><span class="line">        return h &amp; (length-1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看下图，左边两组是数组长度为16（2的4次方），右边两组是数组长度为15。两组的hashcode为8和9，但是很明显，当它们和1110“与”的时候，产生了相同的结果，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8和9会被放到同一个链表上，那么查询的时候就需要遍历这个链表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为15的时候，hashcode的值会与14（1110）进行“与”，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！ </p>
<p><img src="http://qnimages.zhuxingsheng.com/hash/2n.jpg" alt="image"></p>
<h2 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Associates the specified value with the specified key in this map.</span><br><span class="line">     * If the map previously contained a mapping for the key, the old</span><br><span class="line">     * value is replaced.</span><br><span class="line">     *</span><br><span class="line">     * @param key key with which the specified value is to be associated</span><br><span class="line">     * @param value value to be associated with the specified key</span><br><span class="line">     * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span><br><span class="line">     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span><br><span class="line">     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span><br><span class="line">     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span><br><span class="line">     */</span><br><span class="line">    public V put(K key, V value) &#123;</span><br><span class="line">        if (table == EMPTY_TABLE) &#123;</span><br><span class="line">            inflateTable(threshold);</span><br><span class="line">        &#125;</span><br><span class="line">        if (key == null)</span><br><span class="line">            return putForNullKey(value);</span><br><span class="line">        int hash = hash(key);</span><br><span class="line">        int i = indexFor(hash, table.length);</span><br><span class="line">        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(this);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当table &#x3D;&#x3D; EMPTY_TABLE时，先填充table</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Inflates the table.</span><br><span class="line">     */</span><br><span class="line">    private void inflateTable(int toSize) &#123;</span><br><span class="line">        // Find a power of 2 &gt;= toSize</span><br><span class="line">        int capacity = roundUpToPowerOf2(toSize);</span><br><span class="line"></span><br><span class="line">        threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">        table = new Entry[capacity];</span><br><span class="line">        initHashSeedAsNeeded(capacity);</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>
<p>这儿看到了2的N次方，没有跟之前一样使用while循环</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int capacity = 1;  </span><br><span class="line">while (capacity &lt; initialCapacity)   </span><br><span class="line">capacity &lt;&lt;= 1;    </span><br></pre></td></tr></table></figure>
<p>threshold的值&#x3D;容量*负载因子</p>
<p>看下roundUpToPowerOf2()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static int roundUpToPowerOf2(int number) &#123;</span><br><span class="line">        // assert number &gt;= 0 : &quot;number must be non-negative&quot;;</span><br><span class="line">        return number &gt;= MAXIMUM_CAPACITY</span><br><span class="line">                ? MAXIMUM_CAPACITY</span><br><span class="line">                : (number &gt; 1) ? Integer.highestOneBit((number - 1) &lt;&lt; 1) : 1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>主要是Integer.highestOneBit</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static int highestOneBit(int i) &#123;</span><br><span class="line">        // HD, Figure 3-1</span><br><span class="line">        i |= (i &gt;&gt;  1);</span><br><span class="line">        i |= (i &gt;&gt;  2);</span><br><span class="line">        i |= (i &gt;&gt;  4);</span><br><span class="line">        i |= (i &gt;&gt;  8);</span><br><span class="line">        i |= (i &gt;&gt; 16);</span><br><span class="line">        return i - (i &gt;&gt;&gt; 1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法单纯的使用位运算，性能自然提高<br>解析下这个方法，这个方法的作用是求构成一个整数的最大的位所代表的整数的值<br>接下来举个简单的例子，128来讲二进制是1000 0000。下面以他为例子算下：<br>    移1位<br>    1000 0000<br>    0100 0000<br>    |————-<br>    移2位<br>    1100 0000<br>    0011 0000<br>    |————<br>    移4位<br>    1111 0000<br>    0000 1111<br>    |————<br>    移8位<br>    1111 1111<br>    0000 0000<br>    |————<br>    移动16位<br>    1111 1111<br>    0000 0000<br>    |————<br>    1111 1111<br>最终的结果如你所看到的，后面的位全部填充为1，把后面的位全部减掉就得到了最高的位代表的整数。</p>
<p>回到put方法，如果key&#x3D;&#x3D;null，putForNullKey(value);说明hashmap支持key为null</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Offloaded version of put for null keys</span><br><span class="line">     */</span><br><span class="line">    private V putForNullKey(V value) &#123;</span><br><span class="line">        for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123;</span><br><span class="line">            if (e.key == null) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(this);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(0, null, value, 0);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个逻辑比较简单</p>
<ol>
<li>第一步，如果找到之前有key为null的key,进行一下value替换，返回oldValue</li>
<li>如果没有为null的key,那进行addEntry() 添加元素的主要方法</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Adds a new entry with the specified key, value and hash code to</span><br><span class="line"> * the specified bucket.  It is the responsibility of this</span><br><span class="line"> * method to resize the table if appropriate.</span><br><span class="line"> *</span><br><span class="line"> * Subclass overrides this to alter the behavior of put method.</span><br><span class="line"> */</span><br><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;</span><br><span class="line">        resize(2 * table.length);</span><br><span class="line">        hash = (null != key) ? hash(key) : 0;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新添加元素时，先看下有没有达到threshold &amp;&amp; bucketIndex元素不为null</p>
<p>如果成立，那就需要resize，这是个耗性能的操作，所以在初始化时，一般计算好元素多少，给一个合适的初始容量</p>
<p>按照上面的条件，一个合适的容量应该这样计算了</p>
<p>我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，即使是1000，hashmap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的，因为0.75*1000 &lt; 1000, 也就是说为了让0.75 * size &gt; 1000, 我们必须这样new HashMap(2048)才最合适，既考虑了&amp;的问题，也避免了resize的问题。 </p>
<p>先看createEntry</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void createEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">        table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个很简单，新建一个Entry指向bucketIndex，老元素e，被指向新元素的next。</p>
<p>这儿也看出hashmap是使用的<a href="###%E6%8B%89%E9%93%BE%E6%B3%95">拉链法</a></p>
<p>看Entry,就是一个链表，一个元素接着另一个元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        final K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line">        int hash;</span><br><span class="line">        </span><br><span class="line">        Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">            value = v;</span><br><span class="line">            next = n;</span><br><span class="line">            key = k;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h2><p>耗性能的地方，重新散列，看看这个方法的实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//在put方法里,当容量达到threshold时，进行双倍的扩容。</span><br><span class="line">resize(2 * table.length);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void resize(int newCapacity) &#123;</span><br><span class="line">        Entry[] oldTable = table;</span><br><span class="line">        int oldCapacity = oldTable.length;</span><br><span class="line">        if (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Entry[] newTable = new Entry[newCapacity];</span><br><span class="line">        transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">        table = newTable;</span><br><span class="line">        threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">/**</span><br><span class="line">     * Transfers all entries from current table to newTable.</span><br><span class="line">     */</span><br><span class="line">    void transfer(Entry[] newTable, boolean rehash) &#123;</span><br><span class="line">        int newCapacity = newTable.length;</span><br><span class="line">        for (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">            while(null != e) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                if (rehash) &#123;</span><br><span class="line">                    e.hash = null == e.key ? 0 : hash(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                int i = indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果容量已经达到MAX_VALUE,那就不扩容了，只能处理冲突</p>
<p>transfer(),这是核心方法，把以前的元素，按新的capacity，计算的hashCode，重新放置元素。</p>
<p>这儿看到e.next&#x3D;newTable[i],明显使用的是链表头部插入法</p>
<h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">        if (key == null)</span><br><span class="line">            return getForNullKey();</span><br><span class="line">        Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">        return null == entry ? null : entry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">    final Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">        if (size == 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int hash = (key == null) ? 0 : hash(key);</span><br><span class="line">        for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">             e != null;</span><br><span class="line">             e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            if (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                return e;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>get很好理解了，跟算法一致，先hash找bucket，如果有冲突的元素，再使用equals来判定</p>
<h2 id="hashSeed"><a href="#hashSeed" class="headerlink" title="hashSeed"></a>hashSeed</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * A randomizing value associated with this instance that is applied to</span><br><span class="line">     * hash code of keys to make hash collisions harder to find. If 0 then</span><br><span class="line">     * alternative hashing is disabled.</span><br><span class="line">     */</span><br><span class="line">    transient int hashSeed = 0;</span><br><span class="line">    </span><br><span class="line">/**</span><br><span class="line">     * Initialize the hashing mask value. We defer initialization until we</span><br><span class="line">     * really need it.</span><br><span class="line">     */</span><br><span class="line">    final boolean initHashSeedAsNeeded(int capacity) &#123;</span><br><span class="line">        boolean currentAltHashing = hashSeed != 0;</span><br><span class="line">        boolean useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">                (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">        boolean switching = currentAltHashing ^ useAltHashing;</span><br><span class="line">        if (switching) &#123;</span><br><span class="line">            hashSeed = useAltHashing</span><br><span class="line">                ? sun.misc.Hashing.randomHashSeed(this)</span><br><span class="line">                : 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return switching;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>initHashSeedAsNeeded在inflateTable中被调用过，这个hashSeed到底有什么用？</p>
<p>hashSeed就好像我们加密时使用的密钥，在StackOverfolw上是这样描述hashSeed的：</p>
<blockquote>
<p>The seed parameter is a means for you to randomize the hash function. You should provide the same seed value for all calls to the hashing function in the same application of the hashing function. However, each invocation of your application (assuming it is creating a new hash table) can use a different seed, e.g., a random value.</p>
</blockquote>
<blockquote>
<p>Why is it provided?</p>
</blockquote>
<blockquote>
<p>One reason is that attackers may use the properties of a hash function to construct a denial of service attack. They could do this by providing strings to your hash function that all hash to the same value destroying the performance of your hash table. But if you use a different seed for each run of your program, the set of strings the attackers must use changes.</p>
</blockquote>
<p>虽然seed近似随机，但在同一个HashMap中必须保证每次的计算Hash值的时候使用的同一个seed，也就相当于保证我们在一个密码系统中加密时，使用同一个密钥。同时使用seed可以抵御攻击，因为每个应用的seed都会一样。</p>
<p>对于安全方面的了解几乎是0，有机会再学习了。</p>
<h2 id="ConcurrentModificationException"><a href="#ConcurrentModificationException" class="headerlink" title="ConcurrentModificationException"></a>ConcurrentModificationException</h2><p>hashmap不是线程安全的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> private abstract class HashIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123;</span><br><span class="line">        Entry&lt;K,V&gt; next;        // next entry to return</span><br><span class="line">        int expectedModCount;   // For fast-fail</span><br><span class="line">        int index;              // current slot</span><br><span class="line">        Entry&lt;K,V&gt; current;     // current entry</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">final Entry&lt;K,V&gt; nextEntry() &#123;</span><br><span class="line">            if (modCount != expectedModCount)</span><br><span class="line">                throw new ConcurrentModificationException();</span><br></pre></td></tr></table></figure>
<p>这个内部遍历类使用了Fail-Fast机制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * The number of times this HashMap has been structurally modified</span><br><span class="line">     * Structural modifications are those that change the number of mappings in</span><br><span class="line">     * the HashMap or otherwise modify its internal structure (e.g.,</span><br><span class="line">     * rehash).  This field is used to make iterators on Collection-views of</span><br><span class="line">     * the HashMap fail-fast.  (See ConcurrentModificationException).</span><br><span class="line">     */</span><br><span class="line">    transient int modCount;</span><br></pre></td></tr></table></figure>
<p>modCount为HashMap的一个实例变量，并且被声明为volatile，表示任何线程都可以看到该变量被其它线程修改的结果</p>
<p>（根据JVM内存模型的优化，每一个线程都会存一份自己的工作内存，此工作内存的内容与本地内存并非时时刻刻都同步，因此可能会出现线程间的修改不可见的问题） </p>
<p>使用Iterator开始迭代时，会将modCount的赋值给expectedModCount，在迭代过程中，通过每次比较两者是否相等来判断HashMap是否在内部或被其它线程修改</p>
<p>在并发条件下，还是要使用并发包下的ConcurrentHashmap，有时间也得写一写</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>(1) 扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。</p>
<p>(2) 负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。</p>
<p>(3) HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.cnblogs.com/yangecnu/p/Introduce-Hashtable.html">浅谈算法和数据结构: 十一 哈希表</a></p>
<p><a href="http://blog.csdn.net/sheepmu/article/details/17662113">单链表—java实现</a></p>
<p><a href="http://www.nowamagic.net/librarys/veda/detail/1202">HashMap的存取之美</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://www.zhuxingsheng.com/blog/game-introduction.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="朱兴生">
      <meta itemprop="description" content="彪悍的人生需要书写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码农戏码">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/game-introduction.html" class="post-title-link" itemprop="url">游戏小传序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-04-01 10:35:00" itemprop="dateCreated datePublished" datetime="2017-04-01T10:35:00+08:00">2017-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-29 15:24:30" itemprop="dateModified" datetime="2021-09-29T15:24:30+08:00">2021-09-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>在游戏行业足足待了八年了。从大学毕业就开始开发游戏。一直到现在还在一线岗位。</p>
<p>从小小的开发，到掌握后端全局的主程；从胎死腹中的产品，到月流水过亿的大作。</p>
<p>游戏人太苦，996工作制是正常的，凌晨下班也是常有的，为什么可以坚持，可能是心中都有个游戏梦，要大成，要大作。但每次都是充满期待，结果却无声奈何。想想那些从别的行业转来做游戏的同事，一个一个期望变成失落，坚持了几年，又都失望地离开了游戏行业，而我是幸运的，至少经历了大作，经过了一款月流水过亿的产品。</p>
<p>人常说七年就是一辈子，那我这算在工作经历上过完了一辈子，下辈子怎么过呢？不清楚。但至少不能再重复上辈子</p>
<p>对于一辈子想有个总结，开始想写本书，至少是个系列《游戏开发实战》，写的过程又是重学的过程，而之前定的一周一篇技术文章的目标总是不能执行，因为时间不够，工作很忙，要写一篇好的技术文章很废时间。所以不想再以技术文章为系列去写，写技术文章太枯燥，由浅入深，面面俱到，太累！</p>
<p>所以这次就以时间为轴线，以技术内容为补充，记录一下我从小鸟变成一个老兵的成长过程，在此过程中遇到的一些问题，思考心得。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://www.zhuxingsheng.com/blog/threadlocal-parsing.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="朱兴生">
      <meta itemprop="description" content="彪悍的人生需要书写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码农戏码">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/threadlocal-parsing.html" class="post-title-link" itemprop="url">ThreadLocal解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-03-15 11:09:00" itemprop="dateCreated datePublished" datetime="2017-03-15T11:09:00+08:00">2017-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-07-23 11:55:38" itemprop="dateModified" datetime="2022-07-23T11:55:38+08:00">2022-07-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近对于职业规划做了些思考，时间不等人，时机不等人；又是金三银四的好时机，今天当面试官虐人，明天被面试被人虐，相互伤害，爱恨情仇，一切都是缘分。</p>
<p>一份简历，一两张A4纸，就要体现出一个人的真实水平，没点功力，还真是难。</p>
<p>技术人都比较实在，不明白之前，感觉很高深，有难点，学了之后必有进步；但在搞过之后，发现不过如此，感觉都是理所当然，简单如是，不好意思跟人讲研究了什么，实在是太简单；</p>
<p>正因为有如此思维，所以在写简历时无处下笔，感觉没什么优势可写，毫无亮点。<br>要么就是简单写写项目经历，要么对着招聘简介看看，摘抄一些了</p>
<p>不管怎么写，还是要写出自己的特长，把自己拿手的写出来，少不可怕，只要写出来的不被面试官难倒，就算成功。</p>
<p>当然也不能为了体现多面手，乱写，熟悉XX，精通OO，了解MM，掌握GG；到面试时，被问得打脸就不好了。</p>
<p>面试时态度端正也很重要，正面回答问题，有时其实对问题答案掌握不好，回避问题甚至绕弯弯，当然这还是看度的，不可绕太多，行家一出手就知有没有，诚恳点，知道多少说多少，知之为知之。</p>
<hr>
<p>面试官，我当得也不好，层次不清，岗位定位不清，有时为了招些优秀的，会问些不合岗位的问题，问得过难；</p>
<p>还是要好好挖掘候选人简历，毕竟简历是展现的第一窗口，技术人书写能力差，不能很好的推销自己，所以还是要从简历中挖掘亮点，有时很精通，但写出来的很笼统，需要面试官去发现亮点了</p>
<h1 id="ThreadLocal的意义"><a href="#ThreadLocal的意义" class="headerlink" title="ThreadLocal的意义"></a>ThreadLocal的意义</h1><p>这个类，好早就有了，JDK1.2就出现了。有时也会用一用，但他的作用是什么，很难表达了，难以表达，不能形成文字，说明了解的深度不够。</p>
<blockquote>
<p>ThreadLocal为解决多线程程序的并发问题提供了一种新的思路；</p>
<p>ThreadLocal的目的是为了解决多线程访问资源时的共享问题。</p>
</blockquote>
<p>这基本上搜索到的threadlocal文章开头都是这样写的。</p>
<p>然，谎言说多了就成了真理。</p>
<p>但在JDK文档里面</p>
<blockquote>
<p>该类提供了线程局部 (thread-local)变量。<br>这些变量不同于它们的普通对应物，因为访问某个变量（通过其 get 或 set 方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。<br>ThreadLocal 实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。</p>
</blockquote>
<p><strong>ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。</strong></p>
<p>ThreadLocal和多线程并发没有什么关系。ThreadLocal模式是为了解决单线程内的跨类跨方法调用的</p>
<blockquote>
<p>ThreadLocal不是用来解决对象共享访问问题的，而是为了处理在多线程环境中，某个方法处理一个业务，需要递归依赖其他方法时，而要在这些方法中共享参数的问题。</p>
<p>例如有方法a()，在该方法中调用了方法b()，而在b方法中又调用了方法c()，即a–&gt;b—&gt;c，如果a，b，c都需要使用用户对象，那么我们常用做法就是a(User user)–&gt;b(User user)—c(User user)。</p>
<p>但是如果使用ThreadLocal我们就可以用另外一种方式解决：<br>  在某个接口中定义一个静态的ThreadLocal 对象，<br>  例如 public static ThreadLocal  threadLocal&#x3D;new ThreadLocal ();<br>  然后让a，b，c方法所在的类假设是类A，类B，类C都实现1中的接口<br>  在调用a时，使用A.threadLocal.set(user) 把user对象放入ThreadLocal环境<br>  这样我们在方法a，方法b，方法c可以在不用传参数的前提下，在方法体中使用threadLocal.get()方法就可以得到user对象。</p>
<p>上面的类A，类B ，类C就可以分别对应我们做web开发时的 web层的Action—&gt;业务逻辑层的Service–&gt;数据访问层的DAO，当我们要在这三层中共享参数时，那么我们就可以使用ThreadLocal 了。</p>
</blockquote>
<p>在使用hibernate中常见的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class HibernateUtil &#123;</span><br><span class="line">    private static Log log = LogFactory.getLog(HibernateUtil.class);</span><br><span class="line">    private static final SessionFactory sessionFactory;     //定义SessionFactory</span><br><span class="line"> </span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 通过默认配置文件hibernate.cfg.xml创建SessionFactory</span><br><span class="line">            sessionFactory = new Configuration().configure().buildSessionFactory();</span><br><span class="line">        &#125; catch (Throwable ex) &#123;</span><br><span class="line">            log.error(&quot;初始化SessionFactory失败！&quot;, ex);</span><br><span class="line">            throw new ExceptionInInitializerError(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //创建线程局部变量session，用来保存Hibernate的Session</span><br><span class="line">    public static final ThreadLocal session = new ThreadLocal();</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 获取当前线程中的Session</span><br><span class="line">     * @return Session</span><br><span class="line">     * @throws HibernateException</span><br><span class="line">     */</span><br><span class="line">    public static Session currentSession() throws HibernateException &#123;</span><br><span class="line">        Session s = (Session) session.get();</span><br><span class="line">        // 如果Session还没有打开，则新开一个Session</span><br><span class="line">        if (s == null) &#123;</span><br><span class="line">            s = sessionFactory.openSession();</span><br><span class="line">            session.set(s);         //将新开的Session保存到线程局部变量中</span><br><span class="line">        &#125;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void closeSession() throws HibernateException &#123;</span><br><span class="line">        //获取线程局部变量，并强制转换为Session类型</span><br><span class="line">        Session s = (Session) session.get();</span><br><span class="line">        session.set(null);</span><br><span class="line">        if (s != null)</span><br><span class="line">            s.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Threadlocal源码"><a href="#Threadlocal源码" class="headerlink" title="Threadlocal源码"></a>Threadlocal源码</h1><p>这个类有以下方法：</p>
<ol>
<li>get()：返回当前线程拷贝的局部线程变量的值。</li>
<li>initialValue()：返回当前线程赋予局部线程变量的初始值。</li>
<li>remove()：移除当前线程赋予局部线程变量的值。</li>
<li>set(T value)：为当前线程拷贝的局部线程变量设置一个特定的值。</li>
</ol>
<h2 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        if (map != null) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">            if (e != null)</span><br><span class="line">                return (T)e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        return setInitialValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>根据当前线程，拿到ThreadLocalMap，通过当前threadloal对象取到value.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private T setInitialValue() &#123;</span><br><span class="line">        T value = initialValue();</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        if (map != null)</span><br><span class="line">            map.set(this, value);</span><br><span class="line">        else</span><br><span class="line">            createMap(t, value);</span><br><span class="line">        return value;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">        return t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">void createMap(Thread t, T firstValue) &#123;</span><br><span class="line">        t.threadLocals = new ThreadLocalMap(this, firstValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Thread.java 里面</p>
<p>ThreadLocalMap是Thread的属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* ThreadLocal values pertaining to this thread. This map is maintained</span><br><span class="line">     * by the ThreadLocal class. */</span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = null;</span><br></pre></td></tr></table></figure>


<p>这个还跟之前的理解不太一样，以为是以当前threadId为key,取到值</p>
<p>数据结构是这样的：</p>
<p>threadlocal&lt;threadId,value&gt;</p>
<p>事实上结构是这样的：</p>
<p><strong>thread &lt;-&gt; threadlocalmap&lt;threadlocal,value&gt;</strong></p>
<p><strong>每个Thread维护一个ThreadLocalMap映射表，这个映射表的key是ThreadLocal实例本身，value是真正需要存储的Object。</strong></p>
<blockquote>
<p>这样设计的主要有以下几点优势：</p>
<ol>
<li>这样设计之后每个Map的Entry数量变小了：之前是Thread的数量，现在是ThreadLocal的数量，能提高性能，据说性能的提升不是一点两点</li>
<li>当 Thread销毁之后对应的ThreadLocalMap也就随之销毁了，能减少内存使用量。</li>
</ol>
</blockquote>
<h1 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h1><p>有些人认为在使用此类时，容易出现OOM</p>
<p><img src="http://qnimages.zhuxingsheng.com/threadlocal-mm.jpg" alt="image"></p>
<blockquote>
<p>如上图，ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：</p>
<p><strong>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</strong></p>
<p>永远无法回收，造成内存泄露。</p>
</blockquote>
<p>进一步分析一下ThreadlocalMap</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * ThreadLocalMap is a customized hash map suitable only for</span><br><span class="line">     * maintaining thread local values. No operations are exported</span><br><span class="line">     * outside of the ThreadLocal class. The class is package private to</span><br><span class="line">     * allow declaration of fields in class Thread.  To help deal with</span><br><span class="line">     * very large and long-lived usages, the hash table entries use</span><br><span class="line">     * WeakReferences for keys. However, since reference queues are not</span><br><span class="line">     * used, stale entries are guaranteed to be removed only when</span><br><span class="line">     * the table starts running out of space.</span><br><span class="line">     */</span><br><span class="line">    static class ThreadLocalMap &#123;</span><br></pre></td></tr></table></figure>
<p>根据注释和代码，发现ThreadLocalMap并没有使用HashMap，而是重新实现了一个map<br>，里面放的Entry</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">         * The entries in this hash map extend WeakReference, using</span><br><span class="line">         * its main ref field as the key (which is always a</span><br><span class="line">         * ThreadLocal object).  Note that null keys (i.e. entry.get()</span><br><span class="line">         * == null) mean that the key is no longer referenced, so the</span><br><span class="line">         * entry can be expunged from table.  Such entries are referred to</span><br><span class="line">         * as &quot;stale entries&quot; in the code that follows.</span><br><span class="line">         */</span><br><span class="line">        static class Entry extends WeakReference&lt;ThreadLocal&gt; &#123;</span><br><span class="line">            /** The value associated with this ThreadLocal. */</span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal k, Object v) &#123;</span><br><span class="line">                super(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">         * Construct a new map initially containing (firstKey, firstValue).</span><br><span class="line">         * ThreadLocalMaps are constructed lazily, so we only create</span><br><span class="line">         * one when we have at least one entry to put in it.</span><br><span class="line">         */</span><br><span class="line">        ThreadLocalMap(ThreadLocal firstKey, Object firstValue) &#123;</span><br><span class="line">            //默认16长度</span><br><span class="line">            table = new Entry[INITIAL_CAPACITY];</span><br><span class="line">            //hashcode取模，得到坑位</span><br><span class="line">            int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);</span><br><span class="line">            table[i] = new Entry(firstKey, firstValue);</span><br><span class="line">            size = 1;</span><br><span class="line">            setThreshold(INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Set the resize threshold to maintain at worst a 2/3 load factor.</span><br><span class="line">         */</span><br><span class="line">        private void setThreshold(int len) &#123;</span><br><span class="line">            threshold = len * 2 / 3;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void set(ThreadLocal key, Object value) &#123;</span><br><span class="line"></span><br><span class="line">			// We don&#x27;t use a fast path as with get() because it is at</span><br><span class="line">			// least as common to use set() to create new entries as</span><br><span class="line">			// it is to replace existing ones, in which case, a fast</span><br><span class="line">			// path would fail more often than not.</span><br><span class="line">			Entry[] tab = table;</span><br><span class="line">			int len = tab.length;</span><br><span class="line">			int i = key.threadLocalHashCode &amp; (len - 1);</span><br><span class="line"></span><br><span class="line">			for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">				ThreadLocal k = e.get();</span><br><span class="line"></span><br><span class="line">				if (k == key) &#123;</span><br><span class="line">					e.value = value;</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line">				//key在gc时，会被回收，变成null</span><br><span class="line">				if (k == null) &#123;</span><br><span class="line">					replaceStaleEntry(key, value, i);</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			tab[i] = new Entry(key, value);</span><br><span class="line">			int sz = ++size;</span><br><span class="line">			if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">				rehash();</span><br><span class="line">		&#125;</span><br><span class="line">private void replaceStaleEntry(ThreadLocal key, Object value, int staleSlot) &#123;</span><br><span class="line">			Entry[] tab = table;</span><br><span class="line">			int len = tab.length;</span><br><span class="line">			Entry e;</span><br><span class="line"></span><br><span class="line">			// Back up to check for prior stale entry in current run.</span><br><span class="line">			// We clean out whole runs at a time to avoid continual</span><br><span class="line">			// incremental rehashing due to garbage collector freeing</span><br><span class="line">			// up refs in bunches (i.e., whenever the collector runs).</span><br><span class="line">			int slotToExpunge = staleSlot;</span><br><span class="line">                        //替换掉之前有key=null的</span><br><span class="line">			for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len))</span><br><span class="line">				if (e.get() == null)</span><br><span class="line">					slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">			// Find either the key or trailing null slot of run, whichever</span><br><span class="line">			// occurs first</span><br><span class="line">			for (int i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123;</span><br><span class="line">				ThreadLocal k = e.get();</span><br><span class="line"></span><br><span class="line">				// If we find key, then we need to swap it</span><br><span class="line">				// with the stale entry to maintain hash table order.</span><br><span class="line">				// The newly stale slot, or any other stale slot</span><br><span class="line">				// encountered above it, can then be sent to expungeStaleEntry</span><br><span class="line">				// to remove or rehash all of the other entries in run.</span><br><span class="line">				if (k == key) &#123;</span><br><span class="line">					e.value = value;</span><br><span class="line"></span><br><span class="line">					tab[i] = tab[staleSlot];</span><br><span class="line">					tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">					// Start expunge at preceding stale entry if it exists</span><br><span class="line">					if (slotToExpunge == staleSlot)</span><br><span class="line">						slotToExpunge = i;</span><br><span class="line">					cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				// If we didn&#x27;t find stale entry on backward scan, the</span><br><span class="line">				// first stale entry seen while scanning for key is the</span><br><span class="line">				// first still present in the run.</span><br><span class="line">				if (k == null &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">					slotToExpunge = i;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// If key not found, put new entry in stale slot</span><br><span class="line">			tab[staleSlot].value = null;</span><br><span class="line">			tab[staleSlot] = new Entry(key, value);</span><br><span class="line"></span><br><span class="line">			// If there are any other stale entries in run, expunge them</span><br><span class="line">			if (slotToExpunge != staleSlot)</span><br><span class="line">				cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。将key为null的这些Entry都删除，防止内存泄露。</p>
</blockquote>
<blockquote>
<p>但是光这样还是不够的，上面的设计思路依赖一个前提条件：<br>要调用ThreadLocalMap的getEntry函数或者set函数。这当然是不可能任何情况都成立的，所以很多情况下需要使用者手动调用ThreadLocal的remove函数，手动删除不再需要的ThreadLocal，防止内存泄露。<br>所以JDK建议将ThreadLocal变量定义成private static的，<br>这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露</p>
</blockquote>
<h1 id="为什么使用弱引用"><a href="#为什么使用弱引用" class="headerlink" title="为什么使用弱引用"></a>为什么使用弱引用</h1><blockquote>
<p>To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys.<br>为了应对非常大和长时间的用途，哈希表使用弱引用的 key</p>
</blockquote>
<ul>
<li><strong>key 使用强引用</strong>：引用的ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。</li>
<li><strong>key 使用弱引用</strong>：引用的ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。value在下一次ThreadLocalMap调用set,get，remove的时候会被清除</li>
</ul>
<p>比较两种情况，我们可以发现：由于ThreadLocalMap的生命周期跟Thread一样长，如果都没有手动删除对应key，都会导致内存泄漏，但是使用弱引用可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set,get,remove的时候会被清除。</p>
<p>因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。</strong></p>
<ul>
<li><p>不是为了解决多线程共享同步之类的作用</p>
</li>
<li><p>ThreadLocal变量定义成private static,不要定义成局部变量</p>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.iteye.com/topic/617368">http://www.iteye.com/topic/617368</a></p>
<p><a href="http://qifuguang.me/2015/09/02/[Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%83]%E8%A7%A3%E5%AF%86ThreadLocal/">http://qifuguang.me/2015/09/02/[Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%83]%E8%A7%A3%E5%AF%86ThreadLocal/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://www.zhuxingsheng.com/blog/jit-optimization.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="朱兴生">
      <meta itemprop="description" content="彪悍的人生需要书写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码农戏码">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/jit-optimization.html" class="post-title-link" itemprop="url">JIT优化之道</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-03-02 13:10:00" itemprop="dateCreated datePublished" datetime="2017-03-02T13:10:00+08:00">2017-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-29 15:24:30" itemprop="dateModified" datetime="2021-09-29T15:24:30+08:00">2021-09-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h1><p>《JIT优化之道》是去年在公司的一次分享，对于公司组织分享我是赞同又不赞同，怎么讲呢？</p>
<p>技术分享当然是好的，这是一个双赢，分享者教学相长，而收听者也能更快的了解进步。</p>
<p>但以前在原先的公司也做过些类事情，但没有想象的好，大家对分享主题的探索也只限于在分享时间段内，过后很少有人，几乎没人去做进一步的探索。填鸭式的学习效果甚微。后来只涉及一些项目中使用到的知识点，让项目中人去发现项目中的一些亮点，盲区</p>
<p>聪明人从旁人的错误中吸取教训,愚笨人则从自身的错误中吸取教训，有多少聪明人呢？<br>不经历风雨又怎么见彩虹？</p>
<h1 id="JIT主要关注三个点"><a href="#JIT主要关注三个点" class="headerlink" title="JIT主要关注三个点"></a>JIT主要关注三个点</h1><ol>
<li>JIT是什么</li>
<li>JIT的原理</li>
<li>JIT的意义</li>
</ol>
<h2 id="JIT是什么"><a href="#JIT是什么" class="headerlink" title="JIT是什么"></a>JIT是什么</h2><p>JIT是just in time,即时编译器；使用该技术，能够加速java程序的执行速度</p>
<p><img src="http://qnimages.zhuxingsheng.com/jit/jit.png" alt="image"></p>
<h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><p><img src="http://qnimages.zhuxingsheng.com/jit/compile.png" alt="image"></p>
<p>Java编译器总的来说分为</p>
<ol>
<li>前端编译器</li>
<li>JIT（just in time compiler）编译器</li>
<li>AOT（Ahead Of Time Compiler）编译器</li>
</ol>
<p>前端编译器： 将Java文件编译为class文件的编译器，目前主要有以下两个，<br>                        Sun提供的Javac 和Eclipse JDT中的增量式编译器（ECJ）</p>
<p>JIT编译器： 虚拟机后端运行期编译器，把字节码转换为机器码的过程。<br>                         HotSpot Vm中提供的C1, C2编译器</p>
<p>AOT编译器：直接把Java文件转换为本地机器码的过程</p>
<h3 id="解释器与编译器"><a href="#解释器与编译器" class="headerlink" title="解释器与编译器"></a>解释器与编译器</h3><p><img src="http://qnimages.zhuxingsheng.com/jit/jieshibianyi.png" alt="image"></p>
<p>当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。</p>
<p>在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率</p>
<h3 id="分层编译的策略TieredCompilation"><a href="#分层编译的策略TieredCompilation" class="headerlink" title="分层编译的策略TieredCompilation"></a>分层编译的策略TieredCompilation</h3><p>为了在程序启动响应速度与运行效率之间达到最佳平衡，HotSpot虚拟机还会逐渐启动分层编译的策略。分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次，包括：</p>
<ol>
<li>第0层，程序解释执行，解释器不开启性能监控功能，可触发第1层编译。</li>
<li>第1层，也称为C1编译，将字节码编译成本地代码，进行简单、可靠的优化，如有必要将加入性能监控的逻辑。</li>
<li>第2层，也称为C2编译，也是将字节码编译为本地代码，但是会启动一下编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。</li>
</ol>
<p>实施分层编译后，Client Compiler和Server Compiler 将会同时工作，许多代码都可能会多次编译，C1获取更高的编译速度，用C2获取更好的编译质量，在解释时候的时候也无须再承担收集性能监控信息的任务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Oracle JDK从JDK 6u25以后的版本支持了多层编译（-XX:+TieredCompilation）</span><br><span class="line">可以用jinfo -flag或-XX:+PrintFlagsFinal来确认是否打开</span><br><span class="line"></span><br><span class="line">JDK8是默认打开的</span><br></pre></td></tr></table></figure>
<p><img src="http://qnimages.zhuxingsheng.com/jit/tieredxingneng.png" alt="image"></p>
<p>图表描绘了纯解析、客户端、服务器端和混合编译的性能区别。X轴代码执行时间，Y轴代表性能</p>
<p>和单纯的代码解析相比，使用客户端编译器可以提高大约5-10倍的执行性能，实际上提高了应用的性能。当然，收益的变化还是依赖于编译器性能如何，哪些优化生效了或者被实现了，还有就是对于目标执行平台来说应用程序设计的有多好。后者是Java开发人员从来不需要担心的。</p>
<p>和客户端编译器相比，服务器端编译器通常能够提升可度量的30％－50％的代码效率。在大部分情况下，这性能的提高将平衡掉多余的资源开销。</p>
<p>分层编译结合了两种编译器的优点。客户端编译产生了快速的启动时间和及时的优化，服务器端编译在执行周期的后期，可以提供更多的高级优化</p>
<h3 id="JIT开关"><a href="#JIT开关" class="headerlink" title="JIT开关"></a>JIT开关</h3><p><img src="http://qnimages.zhuxingsheng.com/jit/jit-switch.png" alt="image"></p>
<p>3种执行方式，分别是解释执行、混合模式和编译执行，默认情况下处于混合模式中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过-Xint  -Xcomp改变执行方式</span><br></pre></td></tr></table></figure>

<p>通过代码也可以</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Compiler.disable();</span><br><span class="line"></span><br><span class="line">java.lang.Compiler.enable();</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Pi &#123;</span><br><span class="line">	public static double calcPi() &#123;</span><br><span class="line">		double re = 0;</span><br><span class="line">		for (int i = 1; i &lt; 100000; i++) &#123;</span><br><span class="line">			re += ((i &amp; 1) == 0 ? -1 : 1) * 1.0 / (2 * i - 1);</span><br><span class="line">		&#125;</span><br><span class="line">		return re * 4;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		long b = System.currentTimeMillis();</span><br><span class="line">		for (int i = 0; i &lt; 100000; i++)</span><br><span class="line">			calcPi();</span><br><span class="line">		long e = System.currentTimeMillis();</span><br><span class="line">		System.err.println(&quot;spend:&quot; + (e - b) + &quot;ms&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">mixed:spend:418ms</span><br><span class="line">int:spend:2547ms</span><br><span class="line">comp:spend:416ms</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>jstat -compiler <pid>显示VM实时编译的数量等信息。<br>显示列名<br>具体描述<br>Compiled<br>编译任务执行数量<br>Failed<br>编译任务执行失败数量<br>Invalid<br>编译任务执行失效数量<br>Time<br>编译任务消耗时间<br>FailedType<br>最后一个编译失败任务的类型<br>FailedMethod<br>最后一个编译失败任务所在的类及方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstat -compiler 55417</span><br><span class="line">Compiled Failed Invalid   Time   FailedType FailedMethod</span><br><span class="line">    6296      6       0    50.37          1  org/eclipse/jdt/internal/core/CompilationUnitStructureRequestor createTypeInfo</span><br></pre></td></tr></table></figure>

<h2 id="JIT原理"><a href="#JIT原理" class="headerlink" title="JIT原理"></a>JIT原理</h2><p><img src="http://qnimages.zhuxingsheng.com/jit/jit-guocheng.png" alt="image"></p>
<h3 id="寻找热点代码"><a href="#寻找热点代码" class="headerlink" title="寻找热点代码"></a>寻找热点代码</h3><p>在运行过程中，会被即时编译器编译的“热点代码”有两类，即：</p>
<ol>
<li>被多次调用的方法</li>
<li>被多次执行的循环体（OSR On StackReplacement）</li>
</ol>
<p>判断是否是热点代码的行为成为热点探测：hot spotdetection,主要的热点探测方式主要有两种：</p>
<ol>
<li><p>基于采样的热点探测，JVM会周期性检查各个线程的栈顶，如果某个方法经常出现在栈顶，那就认定为热点方法。简单高效，精度不够。</p>
</li>
<li><p>基于计数器的热点探测，统计方法执行次数。（HOTSPOT使用这种方式）</p>
</li>
</ol>
<h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>HOTSPOT有两个计数器：</p>
<p>1、方法调用计数器</p>
<p>2、回边计数器</p>
<h4 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h4><p><img src="http://qnimages.zhuxingsheng.com/jit/jit-count1.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法调用计数器</span><br><span class="line">client默认1500次，</span><br><span class="line">server默认10000次，</span><br><span class="line"></span><br><span class="line">-XX:CompileThreshold</span><br></pre></td></tr></table></figure>
<p>方法调用计数器并不是统计方法调用绝对次数，而是一个相对执行频率，<br>超过一定时间，如果方法调用次数不足以让它提交给编译器，则计数器就会被减少一半，这种现象称为热度衰减(Counter Decay)，<br>进行热度衰减的动作是在垃圾回收时顺便进行的，而这段时间就被称为半衰周期（Counter Half Life Time）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可用-XX:-UseCounterDecay来关闭热度衰减，</span><br><span class="line">用-XX:CounterHalfLifeTime来设置半衰时间。</span><br></pre></td></tr></table></figure>

<p><strong>要不要关闭这个衰减？</strong></p>
<p>HotSpot VM的触发JIT的计数器的半衰（counter decaying）是一种很好的机制，保证只有真正热的代码才会被编译，而那种偶尔才被调用一次的方法则不会因为运行时间长而积累起虚假的热度。</p>
<p>不建议关闭这个选项，除非它在具体案例中造成了问题。</p>
<p>Counter decaying是伴随GC运行而执行的。过多的手动调用System.gc()倒是有可能会干扰了这个衰减，导致方法达不到触发JIT编译的热度。</p>
<h4 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h4><p><img src="http://qnimages.zhuxingsheng.com/jit/jit-count2.png" alt="image"></p>
<p>回边计数器阈值计算公式</p>
<p>（1）Client模式下<br>方法调用计数器阈值（CompileThreshold）* OSR比率（OnStackReplacePercentage）&#x2F;100.<br>其中OnStackReplacePercentage默认值为933，如果都取默认值，那Client模式虚拟机回边数的阈值为13995。</p>
<p>（2）Server模式下<br>方法调用计数器阈值（CompileThreshold）*（OSR比率（OnStackReplacePercentage）减去解释器监控比率（InterpreterProfilePercentage）的差值）&#x2F;100。</p>
<p>其中OnStackReplacePercentage默认值为140，InterpreterProfilePercentage默认值为33，<br>如果都取默认值，那Server模式虚拟机回边计数器的阈值为10700</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:BackEdgeThreshold</span><br><span class="line">-XX:OnStackReplacePercentage</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>与方法计数器不同，回边计数器没有计数热度衰减的过程，因此这个计数器统计的就是该方法循环执行的绝对次数</p>
<h2 id="学习JIT意义"><a href="#学习JIT意义" class="headerlink" title="学习JIT意义"></a>学习JIT意义</h2><h3 id="大方法-与-小方法？"><a href="#大方法-与-小方法？" class="headerlink" title="大方法 与 小方法？"></a>大方法 与 小方法？</h3><p> java中一般建议一个方法不要写的过长，不方便维护和阅读是其中的一个原因，但是其真正性能的原因大家知道吗？</p>
<p>我们知道，JVM一开始是以解释方式执行字节码的。当这段代码被执行的次数足够多以后，它会被动态优化并编译成机器码执行，执行速度会大大加快，这就是所谓的JIT编译。<br>hotsopt源码中有一句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (DontCompileHugeMethods &amp;&amp; m-&gt;code_size() &gt; HugeMethodLimit) return false;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当DontCompileHugeMethods&#x3D;true且代码长度大于HugeMethodLimit时，方法不会被编译</p>
<p>DontCompileHugeMethods与HugeMethodLimit的值在globals.hpp中定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">product(bool, DontCompileHugeMethods, true,</span><br><span class="line">        &quot;don&#x27;t compile methods &gt; HugeMethodLimit&quot;)</span><br><span class="line">develop(intx, HugeMethodLimit,  8000,</span><br><span class="line">        &quot;don&#x27;t compile methods larger than this if +DontCompileHugeMethods&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面两个参数说明了Hotspot对字节码超过8000字节的大方法有JIT编译限制，这就是大方法不会被JIT编译的原因。由于使用的是product mode的JRE，</p>
<p>我们只能尝试关闭DontCompileHugeMethods，即增加VM参数”-XX:-DontCompileHugeMethods”来强迫JVM编译大方法。</p>
<p>但是不建议这么做，因为一旦CodeCache满了，HotSpot会停止所有后续的编译任务，虽然已编译的代码不受影响，但是后面的所有方法都会强制停留在纯解释模式。</p>
<h3 id="查看jit工作的参数"><a href="#查看jit工作的参数" class="headerlink" title="查看jit工作的参数"></a>查看jit工作的参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-XX:-CITime 打印发费在JIT编译上的时间</span><br><span class="line"></span><br><span class="line">$ java -server -XX:+CITime Benchmark</span><br><span class="line">[...]</span><br><span class="line">Accumulated compiler times (for compiled methods only)</span><br><span class="line">------------------------------------------------</span><br><span class="line">  Total compilation time   :  0.178 s</span><br><span class="line">    Standard compilation   :  0.129 s, Average : 0.004</span><br><span class="line">    On stack replacement   :  0.049 s, Average : 0.024</span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintCompilation 我们可以简单的输出一些关于从字节码转化成本地代码的编译过程</span><br><span class="line"></span><br><span class="line">$ java -server -XX:+PrintCompilation Benchmark</span><br><span class="line">  1       java.lang.String::hashCode (64 bytes)</span><br><span class="line">  2       java.lang.AbstractStringBuilder::stringSizeOfInt (21 bytes)</span><br><span class="line">  3       java.lang.Integer::getChars (131 bytes)</span><br><span class="line">  4       java.lang.Object::&lt;init&gt; (1 bytes)</span><br><span class="line">---   n   java.lang.System::arraycopy (static)</span><br><span class="line">  5       java.util.HashMap::indexFor (6 bytes)</span><br><span class="line">  6       java.lang.Math::min (11 bytes)</span><br><span class="line">  7       java.lang.String::getChars (66 bytes)</span><br><span class="line">  8       java.lang.AbstractStringBuilder::append (60 bytes)</span><br><span class="line">  9       java.lang.String::&lt;init&gt; (72 bytes)</span><br><span class="line"> 10       java.util.Arrays::copyOfRange (63 bytes)</span><br><span class="line"> 11       java.lang.StringBuilder::append (8 bytes)</span><br><span class="line"> 12       java.lang.AbstractStringBuilder::&lt;init&gt; (12 bytes)</span><br><span class="line"> 13       java.lang.StringBuilder::toString (17 bytes)</span><br><span class="line"> 14       java.lang.StringBuilder::&lt;init&gt; (18 bytes)</span><br><span class="line"> 15       java.lang.StringBuilder::append (8 bytes)</span><br><span class="line">[...]</span><br><span class="line"> 29       java.util.regex.Matcher::reset (83 bytes)</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>每当一个方法被编译，就输出一行-XX:+PrintCompilation。每行都包含顺序号（唯一的编译任务ID）和已编译方法的名称和大小。</p>
<p>因此，顺序号1，代表编译String类中的hashCode方法到原生代码的信息。根据方法的类型和编译任务打印额外的信息。例如，本地的包装方法前方会有”n”参数，像上面的System::arraycopy一样。注意这样的方法不会包含顺序号和方法占用的大小，因为它不需要编译为本地代码。</p>
<p>同样可以看到被重复编译的方法，例如StringBuilder::append顺序号为11和15。输出在顺序号29时停止 ，这表明在这个Java应用运行时总共需要编译29个方法。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://www.zhuxingsheng.com/blog/gc-and-jvm-parameters.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="朱兴生">
      <meta itemprop="description" content="彪悍的人生需要书写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码农戏码">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/gc-and-jvm-parameters.html" class="post-title-link" itemprop="url">GC及JVM参数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-02-22 12:42:00" itemprop="dateCreated datePublished" datetime="2017-02-22T12:42:00+08:00">2017-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-29 15:24:30" itemprop="dateModified" datetime="2021-09-29T15:24:30+08:00">2021-09-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这段时间懈怠了，罪过！</p>
<p>最近看到有同事也开始用上了微信公众号写博客了，挺好的~给他们点赞，这博客我也不推广，默默的静静的，主要是担心自己坚持不了。以前写过时间事件日志现在也不写了；写过博客也不写了；月记也不写了。</p>
<p>坚持平凡事就是伟大，本来计划一周一篇的，这次没有严格执行。懈怠了</p>
<p>这个GC跟JVM内容太多了，理论性东西多些，少年时还能记个八九成，好久没弄，都忘记了。这次权当整理温习,再看看《深入理解JVM虚拟机》，找些过去写的博客挖点东西过来！</p>
<h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><p>Java GC（Garbage Collection，垃圾收集，垃圾回收）机制，是Java与C++&#x2F;C的主要区别之一，作为Java开发者，一般不需要专门编写内存回收和垃圾清理代码，对内存泄露和溢出的问题，也不需要像C程序员那样战战兢兢。这是因为在Java虚拟机中，存在自动内存管理和垃圾清扫机制。概括地说，该机制对虚拟机中的内存进行标记，并确定哪些内存需要回收，根据一定的回收策略，自动的回收内存，永不停息（Nerver Stop）的保证虚拟机中的内存空间，防止出现内存泄露和溢出问题。</p>
<p>主要从这几个问题入手，就差不多了</p>
<ol>
<li>Java内存区域</li>
<li>哪些内存需要回收？</li>
<li>什么时候回收</li>
<li>如何回收</li>
<li>监控和优化GC</li>
</ol>
<h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><p><img src="http://qnimages.zhuxingsheng.com/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.jpg" alt="image"></p>
<ol>
<li>程序计数器（Program Counter Register）</li>
</ol>
<p>程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行到了第几行，可以理解为是当前线程的行号指示器。字节码解释器在工作时，会通过改变这个计数器的值来取下一条语句指令。每个程序计数器只用来记录一个线程的行号，所以它是线程私有（一个线程就有一个程序计数器）的。<br>如果程序执行的是一个Java方法，则计数器记录的是正在执行的虚拟机字节码指令地址；如果正在执行的是一个本地（native，由C语言编写完成）方法，则计数器的值为Undefined，由于程序计数器只是记录当前指令地址，所以不存在内存溢出的情况，因此，程序计数器也是所有JVM内存区 域中唯一一个没有定义OutOfMemoryError的区域。</p>
<ol start="2">
<li>虚拟机栈（JVM Stack）</li>
</ol>
<p>一个线程的每个方法在执行的同时，都会创建一个栈帧（Statck Frame），栈帧中存储的有局部变量表、操作站、动态链接、方法出口等，当方法被调用时，栈帧在JVM栈中入栈，当方法执行完成时，栈帧出栈。局部变量表中存储着方法的相关局部变量，包括各种基本数据类型，对象的引用，返回地址等。在局部变量表中，只有long和double类型会占用2个局部变量空间（Slot，对于32位机器，一个Slot就是32个bit），其它都是1个Slot。需要注意的是，局部变量表是在编译时就已经确定 好的，方法运行所需要分配的空间在栈帧中是完全确定的，在方法的生命周期内都不会改变。虚拟机栈中定义了两种异常，如果线程调用的栈深度大于虚拟机允许的最大深度，则抛出StatckOverFlowError（栈溢出）；不过多 数Java虚拟机都允许动态扩展虚拟机栈的大小(有少部分是固定长度的)，所以线程可以一直申请栈，知道内存不足，此时，会抛出 OutOfMemoryError（内存溢出）。每个线程对应着一个虚拟机栈，因此虚拟机栈也是线程私有的。</p>
<ol start="3">
<li>本地方法栈（Native Method Statck）：</li>
</ol>
<p>本地方法栈在作用，运行机制，异常类型等方面都与虚拟机栈相同，唯一的区别是：虚拟机栈是执行Java方法的，而本地方法栈是用来执行native方法的，在很多虚拟机中（如Sun的JDK默认的HotSpot虚拟机），会将本地方法栈与虚拟机栈放在一起使用。本地方法栈也是线程私有的。</p>
<ol start="4">
<li>堆区（Heap）</li>
</ol>
<p>堆区是理解Java GC机制最重要的区域，没有之一。在JVM所管理的内存中，堆区是最大的一块，堆区也是Java GC机制所管理的主要内存区域，堆区由所有线程共享，在虚拟机启动时创建。堆区的存在是为了存储对象实例，原则上讲，所有的对象都在堆区上分配内存（不过现代技术里，也不是这么绝对的，也有栈上直接分配的）。一般的，根据Java虚拟机规范规定，堆内存需要在逻辑上是连续的（在物理上不需要），在实现时，可以是固定大小的，也可以是可扩展的，目前主流的虚拟机都是可扩展的。如果在执行垃圾回收之后，仍没有足够的内存分配，也不能再扩展，将会抛出OutOfMemoryError:Java heap space异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-Xms 参数设置最小值</span><br><span class="line"></span><br><span class="line">-Xmx 参数设置最大值 </span><br><span class="line">例：VM Args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line"></span><br><span class="line">若-Xms=-Xmx,则可避免堆自动扩展。</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError 可以让虚拟机在出现内存溢出是dump出当前的内存堆转储快照。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>方法区（Method Area）</li>
</ol>
<p>在Java虚拟机规范中，将方法区作为堆的一个逻辑部分来对待，但事实上，方法区并不是堆（Non-Heap）；另外，不少人的博客中，将Java GC的分代收集机制分为3个代：青年代，老年代，永久代，这些作者将方法区定义为“永久代”，这是因为，对于之前的HotSpot Java虚拟机的实现方式中，将分代收集的思想扩展到了方法区，并将方法区设计成了永久代。不过，除HotSpot之外的多数虚拟机，并不将方法区当做永久代，HotSpot本身，也计划取消永久代。<br>方法区是各个线程共享的区域，用于存储已经被虚拟机加载的类信息（即加载类时需要加载的信息，包括版本、field、方法、接口等信息）、final常量、静态变量、编译器即时编译的代码等。方法区在物理上也不需要是连续的，可以选择固定大小或可扩展大小，并且方法区比堆还多了一个限制：可以选择是否执行垃圾收集。一般的，方法区上 执行的垃圾收集是很少的，这也是方法区被称为永久代的原因之一（HotSpot），但这也不代表着在方法区上完全没有垃圾收集，其上的垃圾收集主要是针对常量池的内存回收和对已加载类的卸载。在方法区上进行垃圾收集，条件苛刻而且相当困难，效果也不令人满意，所以一般不做太多考虑，可以留作以后进一步深入研究时使用。在方法区上定义了OutOfMemoryError:PermGen space异常，<br>在内存不足时抛出。<br>运行时常量池（Runtime Constant Pool）是方法区的一部分，用于存储编译期就生成的字面常量、符号引用、翻译出来的直接引用（符号引用就是编码是用字符串表示某个变量、接口的位置，直接引用就是根据符号引用翻译出来的地址，将在类链接阶段完成翻译）；运行时常量池除了存储编译期常量外，也可以存储在运行时间产生的常量（比如String类的intern()方法，作用是String维护了一个常量池，如果调用的字符“abc”已经在常量池中，则返回池中的字符串地址，否则，新建一个常量加入池中，并返回地址）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxPermSize 设置上限</span><br><span class="line">-XX:PermSize 设置最小值 </span><br><span class="line">例：VM Args: -XX:PermSize=10M -XX:MaxPermSize=10M</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>直接内存（Direct Memory）</li>
</ol>
<p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。</p>
<p>Direct Memory满了之后，系统不会自动回收这段内存； 而是要等Tenured Generation满触发GC时，Direct Memory才会被跟着回收。</p>
<p>在JDK 1.4中新加入了NIO（New Input&#x2F;Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I&#x2F;O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p>
<p>显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括RAM及SWAP区或者分页文件）的大小及处理器寻址空间的限制。服务器管理员配置虚拟机参数时，一般会根据实际内存设置-Xmx等参数信息，但经常会忽略掉直接内存，使得各个内存区域的总和大于物理内存限制（包括物理上的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxDirectMemorySize 设置最大值，默认与java堆最大值一样。</span><br><span class="line"></span><br><span class="line">例 ：-XX:MaxDirectMemorySize=10M -Xmx20M</span><br></pre></td></tr></table></figure>


<h2 id="哪些内存被回收"><a href="#哪些内存被回收" class="headerlink" title="哪些内存被回收"></a>哪些内存被回收</h2><p>根据运行时数据区域的各个部分，程序计数器、虚拟机栈、本地方法栈三个区域随着线程而生，<strong>随线程灭而灭</strong>。栈中的栈帧随着方法的进入和退出而进栈出栈。每个栈帧分配多少内存在类结构确定下来的时候就基本已经确定。所以这个三个区域内存回收时方法或者线程结束而回收的，不需要太多关注；而java堆和方法区则不一样，一个接口不同实现类，一个方法中不同的分支，在具体运行的时候才能确定创建那些对象，所以这部分内存是动态的，也是需要垃圾回收机制来回收处理的。</p>
<ol>
<li>堆内存</li>
</ol>
<p>判断堆内的对象是否可以回收，要判断这个对象实例是否确实没用，判断算法有两种：引用计数法和根搜索算法。</p>
<ul>
<li><p>引用计数法：就是给每个对象加一个计数器，如果有一个地方引用就加1，当引用失效就减1；当计数器为0，则认为对象是无用的。这种算法最大的问题在于不能解决相互引用的对象，如：A.b&#x3D;B;B.a&#x3D;A，在没有其他引用的情况下，应该回收；但按照引用计数法来计算，他们的引用都不为0，显然不能回收。</p>
</li>
<li><p>根搜索算法：这个算法的思路是通过一系列名为“GC Roots”的对象作为起点，<br>从这个节点向下搜索，搜索所经过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连(图论的不可达)时，则证明该对象不可用。</p>
</li>
</ul>
<p>java等一大部分商用语言是用根搜索算法来管理内存的，java中可以做为GC Roots的对象有如下几种：</p>
<p><em>虚拟机栈（栈帧中的本地变量表）中的引用的对象；</em></p>
<p><em>方法区中的类静态属性引用的对象；</em></p>
<p><em>方法区中常量引用的对象；</em></p>
<p><em>本地方法栈JNI(Native)的引用对象；</em></p>
<p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。在JDK1.2以前，Java中的引用的定义很传统<strong>如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用</strong>。这种定义很纯粹，但是太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为力。我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。</p>
<p>在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。</p>
<ul>
<li>强引用</li>
</ul>
<p>只要强引用还存在，垃圾收集器永远不会收掉被引用的对象</p>
<ul>
<li>软引用</li>
</ul>
<p>在系统将要发生内存异常之前，将会把这些对象列进回收范围之中进行第二次回收。</p>
<ul>
<li>弱引用</li>
</ul>
<p>被弱引用关联的对象只能生存道下一次垃圾收集发生之前。</p>
<ul>
<li>虚引用</li>
</ul>
<p>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象的实例。</p>
<h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h3><p>在Object类中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected void finalize() throws Throwable &#123; &#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意下这个访问控制符是protected</strong></p>
<h4 id="finalize-在什么时候被调用"><a href="#finalize-在什么时候被调用" class="headerlink" title="finalize()在什么时候被调用?"></a>finalize()在什么时候被调用?</h4><p>有三种情况</p>
<ol>
<li>所有对象被Garbage Collection时自动调用,比如运行System.gc()的时候.</li>
<li>程序退出时为每个对象调用一次finalize方法。</li>
<li>显式的调用finalize方法</li>
</ol>
<p>当一个对象不可到达时，并不是马上就被回收的。</p>
<p><img src="http://qnimages.zhuxingsheng.com/finalize.jpg" alt="image"></p>
<p><strong>当对象没有覆盖finalize()方法，或者finalized()已经被JVM调用过，那就是没有必要执行finalzied()<br>;Finalizer线程执行它，但并不保证等待它执行结束，这主要是防止finalize()出现问题，导致Finalizer线程无限等待，整个内存回收系统崩溃</strong></p>
<h4 id="具体的finalize流程："><a href="#具体的finalize流程：" class="headerlink" title="具体的finalize流程："></a>具体的finalize流程：</h4><p>对象可由两种状态，涉及到两类状态空间，一是终结状态空间 F &#x3D; {unfinalized, finalizable, finalized}；二是可达状态空间 R &#x3D; {reachable, finalizer-reachable, unreachable}。各状态含义如下：<br>unfinalized: 新建对象会先进入此状态，GC并未准备执行其finalize方法，因为该对象是可达的<br>finalizable: 表示GC可对该对象执行finalize方法，GC已检测到该对象不可达。正如前面所述，GC通过F-Queue队列和一专用线程完成finalize的执行<br>finalized: 表示GC已经对该对象执行过finalize方法<br>reachable: 表示GC Roots引用可达<br>finalizer-reachable(f-reachable)：表示不是reachable，但可通过某个finalizable对象可达<br>unreachable：对象不可通过上面两种途径可达<br><img src="http://qnimages.zhuxingsheng.com/finalize-state.jpg" alt="image"></p>
<ol>
<li>新建对象首先处于[reachable, unfinalized]状态(A)</li>
<li>随着程序的运行，一些引用关系会消失，导致状态变迁，从reachable状态变迁到f-reachable(B, C, D)或unreachable(E, F)状态</li>
<li>若JVM检测到处于unfinalized状态的对象变成f-reachable或unreachable，JVM会将其标记为finalizable状态(G,H)。若对象原处于[unreachable, unfinalized]状态，则同时将其标记为f-reachable(H)。</li>
<li>在某个时刻，JVM取出某个finalizable对象，将其标记为finalized并在某个线程中执行其finalize方法。由于是在活动线程中引用了该对象，该对象将变迁到(reachable, finalized)状态(K或J)。该动作将影响某些其他对象从f-reachable状态重新回到reachable状态(L, M, N), 这就是对象重生</li>
<li>处于finalizable状态的对象不能同时是unreahable的，由第4点可知，将对象finalizable对象标记为finalized时会由某个线程执行该对象的finalize方法，致使其变成reachable。这也是图中只有八个状态点的原因</li>
<li>程序员手动调用finalize方法并不会影响到上述内部标记的变化，因此JVM只会至多调用finalize一次，即使该对象“复活”也是如此。程序员手动调用多少次不影响JVM的行为</li>
<li>若JVM检测到finalized状态的对象变成unreachable，回收其内存(I)</li>
<li>若对象并未覆盖finalize方法，JVM会进行优化，直接回收对象（O）</li>
</ol>
<p>注：System.runFinalizersOnExit()等方法可以使对象即使处于reachable状态，JVM仍对其执行finalize方法</p>
<p>对finalize()的一句话概括：<br><em><strong>JVM能够保证一个对象在回收以前一定会调用一次它的finalize()方法。这句话中两个陷阱：回收以前一定和一次</strong></em></p>
<p>但有很多地方是讲，JVM不承诺这一定调用finalize()，这就是上面的陷阱造成的</p>
<p>你永远不知道它什么时候被调用甚至会不会调用（因为有些对象是永远不会被回收的，或者被回收以前程序就结束了）,但如果他是有必要执行finalize()的，那在GC前一定调用一次且仅一次，如果在第一次GC时没有被回收，那以后再GC时，就不再调用finalize()</p>
<ol start="2">
<li>方法区</li>
</ol>
<p>很多人认为方法区（或者HotSpot虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集*++一般可以回收70%~95%的空间++，而永久代的垃圾收集效率远低于此。</p>
<p>方法区回收主要有两部分：废弃的常量和无用的类。废弃的常量判断方法和堆中的对象类似，只要判断没有地方引用就可以回收。相比之下，判断一个类是否无用，条件就比较苛刻，需要同时满足下面3个条件才能算是“无用的类”：</p>
<ul>
<li>该类的所有实例都已经被回收，也就是java堆中不存在该类的任何实例；</li>
<li>加载该类的ClassLoader已经被回收；</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而不是和对象一样，不使用了就必然会回收。是否对类进行回收，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HotSpot虚拟机提供了</span><br><span class="line">-Xnoclassgc参数进行控制，</span><br><span class="line">还可以使用</span><br><span class="line">-verbose:class</span><br><span class="line">-XX:+TraceClassLoading</span><br><span class="line">-XX:+TraceClassUnLoading查看类的加载和卸载信息。</span><br></pre></td></tr></table></figure>
<p>在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出</p>
<h2 id="如何回收"><a href="#如何回收" class="headerlink" title="如何回收"></a>如何回收</h2><p>选择合适的GC collector是JVM调优最重要的一项，前提是先了解回收算法</p>
<h3 id="“标记-清除”（Mark-Sweep）"><a href="#“标记-清除”（Mark-Sweep）" class="headerlink" title="“标记-清除”（Mark-Sweep）"></a>“标记-清除”（Mark-Sweep）</h3><p><img src="http://qnimages.zhuxingsheng.com/Mark-Sweep.png" alt="image"></p>
<p>算法分为“标记”和“清除”两个阶段：<br>首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象</p>
<p>主要缺点有两个</p>
<ol>
<li>一个是效率问题，标记和清除过程的效率都不高</li>
<li>一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</li>
</ol>
<h3 id="“复制”（Copying）"><a href="#“复制”（Copying）" class="headerlink" title="“复制”（Copying）"></a>“复制”（Copying）</h3><p><img src="http://qnimages.zhuxingsheng.com/Copying.png" alt="image"></p>
<p>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</p>
<p>只是这种算法的代价是将内存缩小为原来的一半，未免太高了一点</p>
<p>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM的专门研究表明，新生代中的对象98%是朝生夕死的，所以并不需要按照1∶1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存是会被“浪费”的。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。</p>
<p>在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:SurvivorRatio=4</span><br><span class="line">设置年轻代中Eden区与Survivor区的大小比值。</span><br><span class="line">设置为4，则Eden区与两个Survivor区的比值为4:1:1，一个Survivor区占整个年轻代的1/6 </span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么新生代有两个survivor?<br>StackOverflow上面给出的解释是：</p>
</blockquote>
<blockquote>
<p>The reason for the HotSpot JVM’s two survivor spaces is to reduce the need to deal with fragmentation. New objects are allocated in eden space. All well and good. When that’s full, you need a GC, so kill stale objects and move live ones to a survivor space, where they can mature for a while before being promoted to the old generation. Still good so far. The next time we run out of eden space, though, we have a conundrum. The next GC comes along and clears out some space in both eden and our survivor space, but the spaces aren’t contiguous. So is it better to</p>
<ol>
<li>Try to fit the survivors from eden into the holes in the survivor space that were cleared by the GC?</li>
<li>Shift all the objects in the survivor space down to eliminate the fragmentation, and then move the survivors into it?</li>
<li>Just say “screw it, we’re moving everything around anyway,” and copy all of the survivors from both spaces into a completely separate space–the second survivor space–thus leaving you with a clean eden and survivor space where you can repeat the sequence on the next GC?</li>
</ol>
</blockquote>
<blockquote>
<p>Sun’s answer to the question is obvious.</p>
</blockquote>
<h3 id="“标记-整理”（Mark-Compact）"><a href="#“标记-整理”（Mark-Compact）" class="headerlink" title="“标记-整理”（Mark-Compact）"></a>“标记-整理”（Mark-Compact）</h3><p><img src="http://qnimages.zhuxingsheng.com/Mark-Compact.png" alt="image"></p>
<p>此算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，</p>
<ol>
<li>第一阶段从根节点开始标记所有被引用对象，</li>
<li>第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。</li>
</ol>
<h3 id="“分代收集”（Generational-Collection）"><a href="#“分代收集”（Generational-Collection）" class="headerlink" title="“分代收集”（Generational Collection）"></a>“分代收集”（Generational Collection）</h3><p>当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，<br>这种算法并没有什么新的思想，只是根据对象的存活周期的不同将内存划分为几块。<br>一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。</p>
<p><img src="http://qnimages.zhuxingsheng.com/GenerationalGC.png" alt="image"></p>
<ul>
<li><p>新生代 GC（Minor GC）：指发生在新生代的垃圾收集动作，因为 Java 对象大多都具<br>备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。</p>
</li>
<li><p>老年代 GC（Major GC）：指发生在老年代的 GC，出现了 Major GC，经常<br>会伴随至少一次的 Minor GC（但非绝对的，在 ParallelScavenge 收集器的收集策略里<br>就有直接进行 Major GC 的策略选择过程） 。MajorGC 的速度一般会比 Minor GC 慢 10<br>倍以上。<br>虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1。对象在 Survivor 区中每熬过一次 Minor GC，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁）时，就会被晋升到老年代中。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象晋升老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。</span><br></pre></td></tr></table></figure>

<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img src="http://qnimages.zhuxingsheng.com/gc.jpg" alt="image"></p>
<h3 id="按系统线程分"><a href="#按系统线程分" class="headerlink" title="按系统线程分"></a>按系统线程分</h3><p><img src="http://qnimages.zhuxingsheng.com/gc-thread.jpg" alt="image"></p>
<p><strong>注意并发（Concurrent）和并行（Parallel）的区别</strong>：</p>
<ol>
<li>并发是指用户线程与GC线程同时执行（不一定是并行，可能交替，但总体上是在同时执行的），不需要停顿用户线程（其实在CMS中用户线程还是需要停顿的，只是非常短，GC线程在另一个CPU上执行）；</li>
<li>并行收集是指多个GC线程并行工作，但此时用户线程是暂停的；</li>
</ol>
<blockquote>
<p>这个跟传统的并发并行概念不同<br>并行是物理的，并发是逻辑的。<br>并行是和串行对立。</p>
</blockquote>
<h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p><img src="http://qnimages.zhuxingsheng.com/Serial.jpg" alt="image"><br>Serial是最基本、历史最悠久的垃圾收集器，使用复制算法，曾经是JDK1.3.1之前新生代唯一的垃圾收集器。目前也是ClientVM下 ServerVM 4核4GB以下机器的默认垃圾回收器。<br>串行收集器并不是只能使用一个CPU进行收集，而是当JVM需要进行垃圾回收的时候，需要中断所有的用户线程，知道它回收结束为止，因此又号称“Stop The World” 的垃圾回收器。注意，JVM中文名称为java虚拟机，因此它就像一台虚拟的电脑一样在工作，而其中的每一个线程就被认为是JVM的一个处理器，因此大家看到图中的CPU0、CPU1实际为用户的线程，而不是真正机器的CPU，大家不要误解哦。</p>
<p>串行回收方式适合低端机器，是<strong>Client模式下的默认收集器</strong>，对CPU和内存的消耗不高，适合用户交互比较少，后台任务较多的系统。</p>
<p>Serial收集器默认新旧生代的回收器搭配为Serial+ SerialOld</p>
<p>新生代、老年代使用串行回收；新生代复制算法、老年代标记-压缩</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在J2SE5.0上，在非server模式下，JVM自动选择串行收集器。</span><br><span class="line">也可以显示进行选择，在Java启动参数中增加： </span><br><span class="line">-XX:+UseSerialGC</span><br></pre></td></tr></table></figure>

<h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p>SerialOld是旧生代Client模式下的默认收集器，单线程执行，使用“标记-整理”算法<br>在Server模式下，主要有两个用途：</p>
<ol>
<li>在JDK1.5之前版本中与新生代的Parallel Scavenge收集器搭配使用。</li>
<li>作为年老代中使用CMS收集器的后备垃圾收集方案。</li>
</ol>
<h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p><img src="http://qnimages.zhuxingsheng.com/ParNew.jpg" alt="image"><br>ParNew收集器其实就是多线程版本的Serial收集器,</p>
<p>Stop The World</p>
<p>他是多CPU模式下的首选回收器（该回收器在单CPU的环境下回收效率远远低于Serial收集器，所以一定要注意场景哦）</p>
<p>Server模式下的默认收集器。</p>
<p>新生代并行，老年代串行；新生代复制算法、老年代标记-压缩</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParNewGC  ParNew收集器</span><br><span class="line"></span><br><span class="line">ParNew收集器默认开启和CPU数目相同的线程数</span><br><span class="line">-XX:ParallelGCThreads 限制线程数量</span><br></pre></td></tr></table></figure>
<h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><p>Parallel Scavenge收集器也是一个新生代垃圾收集器，同样使用复制算法，也是一个多线程的垃圾收集器,也称吞吐量优先的收集器</p>
<p>所提到的<strong>吞吐量&#x3D;程序运行时间&#x2F;(JVM执行回收的时间+程序运行时间)</strong>,假设程序运行了100分钟，JVM的垃圾回收占用1分钟，那么吞吐量就是99%。在当今网络告诉发达的今天，良好的响应速度是提升用户体验的一个重要指标，多核并行云计算的发展要求程序尽可能的使用CPU和内存资源，尽快的计算出最终结果，因此在交互不多的云端，比较适合使用该回收器。</p>
<p>可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例</p>
<p>新生代复制算法、老年代标记-压缩</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC  使用Parallel收集器+ 老年代串行</span><br><span class="line"></span><br><span class="line">Parallel Scavenge收集器提供了两个参数用于精准控制吞吐量：</span><br><span class="line">a.-XX:MaxGCPauseMillis：控制最大垃圾收集停顿时间，是一个大于0的毫秒数。</span><br><span class="line">b.-XX:GCTimeRation：直接设置吞吐量大小，是一个大于0小于100的整数，</span><br><span class="line">也就是程序运行时间占总时间的比率，默认值是99，即垃圾收集运行最大1%（1/(1+99)）的垃圾收集时间</span><br><span class="line"></span><br><span class="line">-XX:+UseAdaptiveSizePolicy，这是个开关参数，</span><br><span class="line">打开之后就不需要手动指定新生代大小(-Xmn)、Eden与Survivor区的比例(-XX:SurvivorRation)、</span><br><span class="line">新生代晋升年老代对象年龄(-XX:PretenureSizeThreshold)等细节参数</span><br></pre></td></tr></table></figure>

<h4 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h4><p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在JDK 1.6中才开始提供</p>
<p>在JDK1.6之前，新生代使用ParallelScavenge收集器只能搭配年老代的Serial Old收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量，Parallel Old正是为了在年老代同样提供吞吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，可以优先考虑新生代Parallel Scavenge和年老代Parallel Old收集器的搭配策略</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参数控制： -XX:+UseParallelOldGC 使用Parallel收集器+ 老年代并行</span><br></pre></td></tr></table></figure>
<p>新生代Parallel Scavenge和年老代Parallel Old收集器搭配运行过程图：<br><img src="http://qnimages.zhuxingsheng.com/Parallel.jpg" alt="image"></p>
<h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>CMS（Concurrent Mark Sweep）收集器是一种以获取<strong>最短回收停顿时间为目标</strong>的收集器。目前很大一部分的Java应用都集中在互联网站或B&#x2F;S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。</p>
<p>由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用ParNew）</p>
<p>优点:并发收集、低停顿 </p>
<p>缺点：产生大量空间碎片、并发阶段会降低吞吐量</p>
<p>从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括： </p>
<ol>
<li><p>初始标记（CMS initial mark）</p>
</li>
<li><p>并发标记（CMS concurrent mark）</p>
</li>
<li><p>重新标记（CMS remark）</p>
</li>
<li><p>并发清除（CMS concurrent sweep）</p>
</li>
</ol>
<p>a.初始标记：只是标记一下GC Roots能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。</p>
<p>b.并发标记：进行GC Roots跟踪的过程，和用户线程一起工作，不需要暂停工作线程。</p>
<p>c.重新标记：为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。</p>
<p>d.并发清除：清除GC Roots不可达对象，和用户线程一起工作，不需要暂停工作线程。<br>由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS收集器的内存回收和用户线程是一起并发地执行。</p>
<p>CMS收集器工作过程：</p>
<p><img src="http://qnimages.zhuxingsheng.com/cms.jpg" alt="image"></p>
<p>其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。</p>
<p>CMS收集器有以下三个不足：</p>
<ul>
<li><p>CMS收集器对CPU资源非常敏感，其默认启动的收集线程数&#x3D;(CPU数量+3)&#x2F;4，在用户程序本来CPU负荷已经比较高的情况下，如果还要分出CPU资源用来运行垃圾收集器线程，会使得CPU负载加重。</p>
</li>
<li><p>CMS无法处理浮动垃圾(Floating Garbage)，可能会导致Concurrent ModeFailure失败而导致另一次Full GC。由于CMS收集器和用户线程并发运行，因此在收集过程中不断有新的垃圾产生，这些垃圾出现在标记过程之后，CMS无法在本次收集中处理掉它们，只好等待下一次GC时再将其清理掉，这些垃圾就称为浮动垃圾。<br>CMS垃圾收集器不能像其他垃圾收集器那样等待年老代机会完全被填满之后再进行收集，需要预留一部分空间供并发收集时的使用，可以通过参数-XX:CMSInitiatingOccupancyFraction来设置年老代空间达到多少的百分比时触发CMS进行垃圾收集，默认是68%。<br>如果在CMS运行期间，预留的内存无法满足程序需要，就会出现一次ConcurrentMode Failure失败，此时虚拟机将启动预备方案，使用Serial Old收集器重新进行年老代垃圾回收。</p>
</li>
<li><p>CMS收集器是基于标记-清除算法，因此不可避免会产生大量不连续的内存碎片，如果无法找到一块足够大的连续内存存放对象时，将会触发因此Full GC。CMS提供一个开关参数-XX:+UseCMSCompactAtFullCollection，用于指定在Full GC之后进行内存整理，内存整理会使得垃圾收集停顿时间变长，CMS提供了另外一个参数-XX:CMSFullGCsBeforeCompaction，用于设置在执行多少次不压缩的Full GC之后，跟着再来一次内存整理</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC  使用CMS收集器</span><br><span class="line">-XX:+ UseCMSCompactAtFullCollection Full GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长</span><br><span class="line">-XX:+CMSFullGCsBeforeCompaction  设置进行几次Full GC后，进行一次碎片整理</span><br><span class="line">-XX:ParallelCMSThreads  设定CMS的线程数量（一般情况约等于可用CPU数量）</span><br></pre></td></tr></table></figure>

<h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>G1可谓博采众家之长，力求到达一种完美。他吸取了增量收集优点，把整个堆划分为一个一个等大小的区域（region）。内存的回收和划分都以region为单位；同时，他也吸取了CMS的特点，把这个垃圾回收过程分为几个阶段，分散一个垃圾回收过程；而且，G1也认同分代垃圾回收的思想，认为不同对象的生命周期不同，可以采取不同收集方式，因此，它也支持分代的垃圾回收。为了达到对回收时间的可预计性，G1在扫描了region以后，对其中的活跃对象的大小进行排序，首先会收集那些活跃对象小的region，以便快速回收空间（要复制的活跃对象少了），因为活跃对象小，里面可以认为多数都是垃圾，所以这种方式被称为Garbage First（G1）的垃圾回收算法，即：垃圾优先的回收。</p>
<p><img src="http://qnimages.zhuxingsheng.com/g1.png" alt="image"></p>
<p>与CMS收集器相比G1收集器有以下特点：</p>
<ol>
<li><p>空间整合，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。</p>
</li>
<li><p>可预测停顿，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</p>
</li>
</ol>
<p>收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。</p>
<p>G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。</p>
<p>和CMS类似，G1收集器收集老年代对象会有短暂停顿。</p>
<ol>
<li><p>标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark)</p>
</li>
<li><p>Root Region Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。</p>
</li>
<li><p>Concurrent Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。<br><img src="http://qnimages.zhuxingsheng.com/g1-3.jpg" alt="image"></p>
</li>
<li><p>Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。</p>
</li>
<li><p>Copy&#x2F;Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。<br><img src="http://qnimages.zhuxingsheng.com/g1-5.jpg" alt="image"></p>
</li>
<li><p>复制&#x2F;清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。<br><img src="http://qnimages.zhuxingsheng.com/g1-6.jpg" alt="image"></p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UnlockExperimentalVMOptions -XX:+UseG1GC        #开启</span><br><span class="line">-XX:MaxGCPauseMillis =50                  #暂停时间目标</span><br><span class="line">-XX:GCPauseIntervalMillis =200          #暂停间隔目标</span><br><span class="line">-XX:+G1YoungGenSize=512m            #年轻代大小</span><br><span class="line">-XX:SurvivorRatio=6                            #幸存区比例</span><br></pre></td></tr></table></figure>


<h2 id="什么时候回收"><a href="#什么时候回收" class="headerlink" title="什么时候回收"></a>什么时候回收</h2><h3 id="Minor-GC触发"><a href="#Minor-GC触发" class="headerlink" title="Minor GC触发"></a>Minor GC触发</h3><ol>
<li>Eden区域满了，或者新创建的对象大小 &gt; Eden所剩空间</li>
<li>CMS设置了CMSScavengeBeforeRemark参数，这样在CMS的Remark之前会先做一次Minor GC来清理新生代，加速之后的Remark的速度。这样整体的stop-the world时间反而短</li>
<li>Full GC的时候会先触发Minor GC</li>
</ol>
<h3 id="啥时候会触发CMS-GC？"><a href="#啥时候会触发CMS-GC？" class="headerlink" title="啥时候会触发CMS GC？"></a>啥时候会触发CMS GC？</h3><p>CMS不等于Full GC，很多人会认为CMS肯定会引发Minor GC。CMS是针对老年代的GC策略，原则上它不会去清理新生代，只有设置CMSScavengeBeforeRemark优化时，或者是concurrent mode failure的时候才会去做Minor GC</p>
<p>1、旧生代或者持久代已经使用的空间达到设定的百分比时（CMSInitiatingOccupancyFraction这个设置old区，perm区也可以设置）；</p>
<p>2、JVM自动触发(JVM的动态策略，也就是悲观策略)（基于之前GC的频率以及旧生代的增长趋势来评估决定什么时候开始执行），如果不希望JVM自行决定，可以通过-XX：UseCMSInitiatingOccupancyOnly&#x3D;true来制定；</p>
<p>3、设置了 -XX：CMSClassUnloadingEnabled 这个则考虑Perm区；</p>
<h3 id="啥时候会触发Full-GC？"><a href="#啥时候会触发Full-GC？" class="headerlink" title="啥时候会触发Full GC？"></a>啥时候会触发Full GC？</h3><p>一、旧生代空间不足：java.lang.outOfMemoryError：java heap space；</p>
<p>二、Perm空间满：java.lang.outOfMemoryError：PermGen space；</p>
<p>三、CMS GC时出现promotion failed  和concurrent  mode failure（Concurrent mode failure发生的原因一般是CMS正在进行，但是由于old区内存不足，需要尽快回收old区里面的死的java对象，这个时候foreground gc需要被触发，停止所有的java线程，同时终止CMS，直接进行MSC。）；</p>
<p>四、统计得到的minor GC晋升到旧生代的平均大小大于旧生代的剩余空间；</p>
<p>五、主动触发Full GC（执行jmap -histo:live [pid]）来避免碎片问题；</p>
<p>六、调用System.gc时，系统建议执行Full GC，但是不必然执行,-XX:+DisableExplicitGC 禁用System.gc()调用</p>
<h2 id="GC策略选择总结"><a href="#GC策略选择总结" class="headerlink" title="GC策略选择总结"></a>GC策略选择总结</h2><p>jvm有client和server两种模式，这两种模式的gc默认方式是不同的：</p>
<p>client模式下，新生代选择的是串行gc，旧生代选择的是串行gc</p>
<p>server模式下，新生代选择的是并行回收gc，旧生代选择的是并行gc</p>
<p>一般来说我们系统应用选择有两种方式：<strong>吞吐量优先和暂停时间优先</strong>，对于吞吐量优先的采用server默认的并行gc方式，对于暂停时间优先的选用并发gc（CMS）方式。</p>
<h2 id="监控与调优"><a href="#监控与调优" class="headerlink" title="监控与调优"></a>监控与调优</h2><h3 id="GC日志"><a href="#GC日志" class="headerlink" title="GC日志"></a>GC日志</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGC 输出GC日志</span><br><span class="line">-XX:+PrintGCDetails 输出GC的详细日志</span><br><span class="line">-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）</span><br><span class="line">-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）</span><br><span class="line">-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息</span><br><span class="line">-Xloggc:../logs/gc.log 日志文件的输出路径</span><br><span class="line">-verbose.gc开关可显示GC的操作内容。</span><br><span class="line">打开它，可以显示最忙和最空闲收集行为发生的时间、收集前后的内存大小、收集需要的时间等</span><br></pre></td></tr></table></figure>

<p><strong>-XX:+PrintGCTimeStamps和-XX:+PrintGCDateStamps</strong></p>
<p>使用-XX:+PrintGCTimeStamps可以将时间和日期也加到GC日志中。表示自JVM启动至今的时间戳会被添加到每一行中。例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 0.185: [GC 66048K-&gt;53077K(251392K), 0.0977580 secs]</span><br><span class="line">2 0.323: [GC 119125K-&gt;114661K(317440K), 0.1448850 secs]</span><br><span class="line">3 0.603: [GC 246757K-&gt;243133K(375296K), 0.2860800 secs]</span><br></pre></td></tr></table></figure>
<p>如果指定了-XX:+PrintGCDateStamps，每一行就添加上了绝对的日期和时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2014-01-03T12:08:38.102-0100: [GC 66048K-&gt;53077K(251392K), 0.0959470 secs]</span><br><span class="line">2 2014-01-03T12:08:38.239-0100: [GC 119125K-&gt;114661K(317440K), 0.1421720 secs]</span><br><span class="line">3 2014-01-03T12:08:38.513-0100: [GC 246757K-&gt;243133K(375296K), 0.2761000 secs]</span><br></pre></td></tr></table></figure>
<p>如果需要也可以同时使用两个参数。推荐同时使用这两个参数，因为这样在关联不同来源的GC日志时很有帮助</p>
<p>每一种收集器的日志形式都是由它们自身的实现所决定的，换而言之，每个收集器的日志格式都可以不一样。</p>
<p>但虚拟机设计者为了方便用户阅读，将各个收集器的日志都维持一定的共性，</p>
<p>例如以下两段典型的GC日志：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">33.125: [GC [DefNew: 3324K-&gt;152K(3712K), 0.0025925 secs] 3324K-&gt;152K(11904K), 0.0031680 secs]</span><br><span class="line">100.667: [Full GC [Tenured: 0K-&gt;210K(10240K), 0.0149142 secs] 4603K-&gt;210K(19456K), </span><br><span class="line">[Perm : 2999K-&gt;2999K(21248K)], 0.0150007 secs] [Times: user=0.01 sys=0.00, real=0.02 secs]</span><br></pre></td></tr></table></figure>
<p>最前面的数字“33.125：”和“100.667：”代表了GC发生的时间，这个数字的含义是从Java虚拟机启动以来经过的秒数。</p>
<p>GC日志开头的“［GC”和“［Full GC”说明了这次垃圾收集的停顿类型，</p>
<p>而不是用来区分新生代GC还是老年代GC的。</p>
<p>如果有“Full”，说明这次GC是发生了Stop-The-World的，</p>
<p>例如下面这段新生代收集器ParNew的日志也会出现“［Full GC”（这一般是因为出现了分配担保失败之类的问题，所以才导致STW）。</p>
<p>如果是调用System.gc()方法所触发的收集，那么在这里将显示“［Full GC (System)”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Full GC 283.736: [ParNew: 261599K-&gt;261599K(261952K), 0.0000288 secs] </span><br></pre></td></tr></table></figure>
<p>接下来的“［DefNew”、“［Tenured”、“［Perm”表示GC发生的区域，这里显示的区域名称与使用的GC收集器是密切相关的</p>
<p>例如上面样例所使用的Serial收集器中的新生代名为“Default New Generation”，所以显示的是“［DefNew”。</p>
<p>如果是ParNew收集器，新生代名称就会变为“［ParNew”，意为“Parallel New Generation”。</p>
<p>如果采用Parallel Scavenge收集器，那它配套的新生代称为“PSYoungGen”，老年代和永久代同理，名称也是由收集器决定的。</p>
<p>后面方括号内部的“3324K-&gt;152K(3712K)”含义是“GC前该内存区域已使用容量-&gt; GC后该内存区域已使用容量 (该内存区域总容量)”。</p>
<p>而在方括号之外的“3324K-&gt;152K(11904K)”表示“GC前Java堆已使用容量 -&gt; GC后Java堆已使用容量 (Java堆总容量)”。</p>
<p>再往后，“0.0025925 secs”表示该内存区域GC所占用的时间，单位是秒。</p>
<p>有的收集器会给出更具体的时间数据</p>
<p>如“［Times： user&#x3D;0.01 sys&#x3D;0.00， real&#x3D;0.02 secs］”，<br>这里面的user、sys和real与Linux的time命令所输出的时间含义一致，分别代表用户态消耗的CPU时间、内核态消耗的CPU事件和操作从开始到结束所经过的墙钟时间（Wall Clock Time）。</p>
<p>CPU时间与墙钟时间的区别是，墙钟时间包括各种非运算的等待耗时，例如等待磁盘I&#x2F;O、等待线程阻塞，而CPU时间不包括这些耗时，但当系统有多CPU或者多核的话，多线程操作会叠加这些CPU时间，所以读者看到user或sys时间超过real时间是完全正常的。</p>
<h3 id="分析工具"><a href="#分析工具" class="headerlink" title="分析工具"></a>分析工具</h3><p>可以使用一些离线的工具来对GC日志进行分析</p>
<p>比如sun的gchisto( <a href="https://java.net/projects/gchisto">https://java.net/projects/gchisto</a>)</p>
<p>gcviewer（ <a href="https://github.com/chewiebug/GCViewer">https://github.com/chewiebug/GCViewer</a> ），</p>
<p>这些都是开源的工具，用户可以直接通过版本控制工具下载其源码，进行离线分析
　　</p>
<h3 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h3><p>HotSpot JVM 提供了三类参数。<br>第一类包括了标准参数。顾名思义，标准参数中包括功能和输出的参数都是很稳定的，很可能在将来的JVM版本中不会改变。你可以用java命令（或者是用 java -help）检索出所有标准参数。我们在第一部分中已经见到过一些标准参数，例如：-server。</p>
<p>第二类是X参数，非标准化的参数在将来的版本中可能会改变。所有的这类参数都以-X开始，并且可以用java -X来检索。注意，不能保证所有参数都可以被检索出来，其中就没有-Xcomp。</p>
<p>第三类是包含XX参数（到目前为止最多的），它们同样不是标准的，甚至很长一段时间内不被列出来（最近，这种情况有改变 ，我们将在本系列的第三部分中讨论它们）。然而，在实际情况中X参数和XX参数并没有什么不同。X参数的功能是十分稳定的，然而很多XX参数仍在实验当中（主要是JVM的开发者用于debugging和调优JVM自身的实现）。值的一读的介绍非标准参数的文档 HotSpot JVM documentation，其中明确的指出XX参数不应该在不了解的情况下使用。这是真的，并且我认为这个建议同样适用于X参数（同样一些标准参数也是）。不管类别是什么，在使用参数之前应该先了解它可能产生的影响。<br>用一句话来说明XX参数的语法。所有的XX参数都以”-XX:”开始，但是随后的语法不同，取决于参数的类型。</p>
<ul>
<li>对于布尔类型的参数，我们有”+”或”-“，然后才设置JVM选项的实际名称。例如，-XX:+<name>用于激活<name>选项，而-XX:-<name>用于注销选项。</li>
<li>对于需要非布尔值的参数，如string或者integer，我们先写参数的名称，后面加上”&#x3D;”，最后赋值。例如，  -XX:<name>&#x3D;<value>给<name>赋值<value>。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintFlagsFinal and -XX:+PrintFlagsInitial</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Global flags]</span><br><span class="line">uintx AdaptivePermSizeWeight               = 20               &#123;product&#125;</span><br><span class="line">uintx AdaptiveSizeDecrementScaleFactor     = 4                &#123;product&#125;</span><br><span class="line">uintx AdaptiveSizeMajorGCDecayTimeScale    = 10               &#123;product&#125;</span><br><span class="line">uintx AdaptiveSizePausePolicy              = 0                &#123;product&#125;[...]</span><br><span class="line">uintx YoungGenerationSizeSupplementDecay   = 8                &#123;product&#125;</span><br><span class="line">uintx YoungPLABSize                        = 4096             &#123;product&#125;</span><br><span class="line"> bool ZeroTLAB                             = false            &#123;product&#125;</span><br><span class="line"> intx hashCode                             = 0                &#123;product&#125;</span><br></pre></td></tr></table></figure>
<p>表格的每一行包括五列，来表示一个XX参数。第一列表示参数的数据类型，第二列是名称，第四列为值，第五列是参数的类别。第三列”&#x3D;”表示第四列是参数的默认值，而”:&#x3D;” 表明了参数被用户或者JVM赋值了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintCommandLineFlags</span><br></pre></td></tr></table></figure>
<p>这个参数让JVM打印出那些已经被用户或者JVM设置过的详细的XX参数的名称和值。</p>
<p>换句话说，它列举出 -XX:+PrintFlagsFinal的结果中第三列有”:&#x3D;”的参数。</p>
<p>以这种方式，我们可以用-XX:+PrintCommandLineFlags作为快捷方式来查看修改过的参数</p>
<h3 id="监控jvm"><a href="#监控jvm" class="headerlink" title="监控jvm"></a>监控jvm</h3><p>使用自带工具就行，jstat,jmap,jstack</p>
<ul>
<li>jstack主要用来查看某个Java进程内的线程堆栈信息</li>
<li>jmap用来查看堆内存使用状况，一般结合jhat使用</li>
<li>jstat利用JVM内建的指令对Java应用程序的资源和性能进行实时的命令行的监控，包括了对进程的classloader，compiler，gc情况</li>
</ul>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ol>
<li>选择合适的GC collector</li>
<li>整个JVM heap的大小</li>
<li>young generation在整个JVM heap中所占的比重</li>
</ol>
<h3 id="参数实例"><a href="#参数实例" class="headerlink" title="参数实例"></a>参数实例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException&#123;</span><br><span class="line">       //通过allocateDirect分配128MB直接内存</span><br><span class="line">       ByteBuffer bb = ByteBuffer.allocateDirect(1024*1024*128);</span><br><span class="line">        </span><br><span class="line">       TimeUnit.SECONDS.sleep(10);</span><br><span class="line">       System.out.println(&quot;ok&quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>测试用例1：设置JVM参数-Xmx100m，运行异常，因为如果没设置-XX:MaxDirectMemorySize，则默认与-Xmx参数值相同，分配128M直接内存超出限制范围</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Direct buffer memory</span><br><span class="line">    at java.nio.Bits.reserveMemory(Bits.java:658)</span><br><span class="line">    at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:123)</span><br><span class="line">    at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:306)</span><br><span class="line">    at com.stevex.app.nio.DirectByteBufferTest.main(DirectByteBufferTest.java:8)</span><br></pre></td></tr></table></figure>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><p>为了避免Perm区满引起的full gc，建议开启CMS回收Perm区选项：</p>
<p>+CMSPermGenSweepingEnabled -XX:+CMSClassUnloadingEnabled</p>
<p>默认CMS是在tenured generation沾满68%的时候开始进行CMS收集，如果你的年老代增长不是那么快，并且希望降低CMS次数的话，可以适当调高此值：</p>
<p>-XX:CMSInitiatingOccupancyFraction&#x3D;80</p>
<p>遇到两种fail引起full gc：</p>
<p>Prommotion failed和Concurrent mode failed时：</p>
<p>promotion failed是在进行Minor GC时，survivor space放不下、<br>对象只能放入旧生代，而此时old gen 的碎片太多为进行过内存重组和压缩，无法提供一块较大的、连续的内存空间存放来自新生代对象</p>
<p>Prommotion failed的日志输出大概是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">42576.951: [ParNew (promotion failed): 320138K-&gt;320138K(353920K), 0.2365970 secs]</span><br><span class="line">42576.951: [CMS: 1139969K-&gt;1120688K( 166784K), 9.2214860 secs] 1458785K-&gt;1120688K(2520704K), 9.4584090 secs]</span><br></pre></td></tr></table></figure>
<p>因为<br>解决这个问题的办法有两种完全相反的倾向：增大救助空间、增大年老代或者去掉救助空间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解决方法可以通过设置参数</span><br><span class="line">-XX:+UseCMSCompactAtFullCollection（打开对年老代的压缩）</span><br><span class="line">-XX:CMSFullGCsBeforeCompaction（设置运行多少次FULL GC以后对内存空间进行压缩、整理） </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">直接关了servivor空间</span><br><span class="line">-XX:SurvivorRatio=65536 -XX:MaxTenuringThreshold=0</span><br></pre></td></tr></table></figure>

<p>concurrent mode failure</p>
<p>发生在当CMS已经在工作并处于concurrent阶段中，而Java堆的内存不够用需要做major GC（full GC）的时候。换句话说，old gen内存的消耗速度比CMS的收集速度要高，CMS收集器跟不上分配速度的时候会发生concurrent mode failure</p>
<p>Concurrent mode failed的日志大概是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(concurrent mode failure): 1228795K-&gt;1228598K(1228800K), 7.6748280 secs] 1911483K-&gt;1681165K(1911488K), </span><br><span class="line">[CMS Perm : 225407K-&gt;225394K(262144K)], 7.6751800 secs]</span><br></pre></td></tr></table></figure>
<p>避免这个现象的产生就是调小-XX:CMSInitiatingOccupancyFraction参数的值，<br>让CMS更早更频繁的触发，降低年老代被沾满的可能。</p>
<h1 id="-2"><a href="#-2" class="headerlink" title=""></a></h1><h1 id="-3"><a href="#-3" class="headerlink" title=""></a></h1><p>full gc频繁说明old区很快满了。</p>
<p>如果是一次full gc后，剩余对象不多。那么说明你eden区设置太小，导致短生命周期的对象进入了old区</p>
<p>如果一次full gc后，old区回收率不大，那么说明old区太小</p>
<h1 id="-4"><a href="#-4" class="headerlink" title=""></a></h1><h1 id="-5"><a href="#-5" class="headerlink" title=""></a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">已知虚拟机的一些参数设置如下： </span><br><span class="line">-Xms：1G； </span><br><span class="line">-Xmx：2G； </span><br><span class="line">-Xmn：500M； </span><br><span class="line">-XX:MaxPermSize：64M； </span><br><span class="line">-XX:+UseConcMarkSweepGC； </span><br><span class="line">-XX:SurvivorRatio=3； </span><br><span class="line">求Eden区域的大小？</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">分析这是网易2016年在线笔试题中的一道选择题。 </span><br><span class="line">先分析一下里面各个参数的含义： </span><br><span class="line">-Xms：1G ， 就是说初始堆大小为1G </span><br><span class="line">-Xmx：2G ， 就是说最大堆大小为2G </span><br><span class="line">-Xmn：500M ，就是说年轻代大小是500M（包括一个Eden和两个Survivor） </span><br><span class="line">-XX:MaxPermSize：64M ， 就是说设置持久代最大值为64M </span><br><span class="line">-XX:+UseConcMarkSweepGC ， 就是说使用使用CMS内存收集算法 </span><br><span class="line">-XX:SurvivorRatio=3 ， 就是说Eden区与Survivor区的大小比值为3：1：1</span><br><span class="line"></span><br><span class="line">题目中所问的Eden区的大小是指年轻代的大小，直接根据-Xmn：500M和-XX:SurvivorRatio=3可以直接计算得出</span><br><span class="line">解500M*(3/(3+1+1)) </span><br><span class="line">=500M*（3/5） </span><br><span class="line">=500M*0.6 </span><br><span class="line">=300M </span><br><span class="line">所以Eden区域的大小为300M。</span><br></pre></td></tr></table></figure>

<h1 id="-6"><a href="#-6" class="headerlink" title=""></a></h1><h1 id="-7"><a href="#-7" class="headerlink" title=""></a></h1><p>-Xmn200m -server</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap pid</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = 0</span><br><span class="line">   MaxHeapFreeRatio         = 100</span><br><span class="line">   MaxHeapSize              = 4282384384 (4084.0MB)</span><br><span class="line">   NewSize                  = 209715200 (200.0MB)</span><br><span class="line">   MaxNewSize               = 209715200 (200.0MB)</span><br><span class="line">   OldSize                  = 58720256 (56.0MB)</span><br><span class="line">   NewRatio                 = 2</span><br><span class="line">   SurvivorRatio            = 8</span><br><span class="line">   MetaspaceSize            = 21807104 (20.796875MB)</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 17592186044415 MB</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 92274688 (88.0MB)</span><br><span class="line">   used     = 37931936 (36.174713134765625MB)</span><br><span class="line">   free     = 54342752 (51.825286865234375MB)</span><br><span class="line">   41.107628562233664% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 58720256 (56.0MB)</span><br><span class="line">   used     = 20305320 (19.364662170410156MB)</span><br><span class="line">   free     = 38414936 (36.635337829589844MB)</span><br><span class="line">   34.57975387573242% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 56623104 (54.0MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 56623104 (54.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = 176160768 (168.0MB)</span><br><span class="line">   used     = 65785064 (62.737525939941406MB)</span><br><span class="line">   free     = 110375704 (105.2624740600586MB)</span><br><span class="line">   37.34376544044132% used</span><br></pre></td></tr></table></figure>
<p>发现为什么from space与to space不对呢。应该是20M才对</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-server默认使用ParallelScavenge系的GC</span><br><span class="line"></span><br><span class="line">HotSpot VM里，ParallelScavenge系的GC（UseParallelGC / UseParallelOldGC）</span><br><span class="line">默认行为是SurvivorRatio如果不显式设置就没啥用。</span><br><span class="line">显式设置到跟默认值一样的值则会有效果</span><br><span class="line"></span><br><span class="line">因为ParallelScavenge系的GC最初设计就是默认打开AdaptiveSizePolicy的，</span><br><span class="line">它会自动、自适应的调整各种参数</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需要显示配置 -XX:SurvivorRatio=8</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://yinwufeng.iteye.com/blog/2157787">http://yinwufeng.iteye.com/blog/2157787</a></p>
<p><a href="http://itindex.net/detail/47030-cms-gc-%E9%97%AE%E9%A2%98">http://itindex.net/detail/47030-cms-gc-%E9%97%AE%E9%A2%98</a></p>
<p><a href="http://www.cnblogs.com/ityouknow/p/5614961.html">http://www.cnblogs.com/ityouknow/p/5614961.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://www.zhuxingsheng.com/blog/motan-server.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="朱兴生">
      <meta itemprop="description" content="彪悍的人生需要书写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码农戏码">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/motan-server.html" class="post-title-link" itemprop="url">motan服务端</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-02-06 16:03:00" itemprop="dateCreated datePublished" datetime="2017-02-06T16:03:00+08:00">2017-02-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-29 15:24:30" itemprop="dateModified" datetime="2021-09-29T15:24:30+08:00">2021-09-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/source/" itemprop="url" rel="index"><span itemprop="name">源码解读</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前引"><a href="#前引" class="headerlink" title="前引"></a>前引</h1><p>新年回来上班，记录下服务端的处理过程，就当热个身</p>
<p>服务端的处理也有套路，不管上层怎么玩，最后还得是通过反射得到Method对象，再调用invoke()</p>
<p><img src="http://qnimages.zhuxingsheng.com/motan-server.png" alt="image"><br>根据这张序列图，可以把服务端分为两部分</p>
<ol>
<li>NettyServer前面的算一部分，搭基础构建Exporter对象</li>
<li>nettyserver后面的算一部分，找到对应method，invoke,通过网络返回</li>
</ol>
<h1 id="构建Exporter对象"><a href="#构建Exporter对象" class="headerlink" title="构建Exporter对象"></a>构建Exporter对象</h1><h2 id="结合spring"><a href="#结合spring" class="headerlink" title="结合spring"></a>结合spring</h2><p>其实在《motan客户端》时有提过，但没有深究；spring扩展自定义xml是个很老的技术了<br><a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/xml-custom.html#extensible-xml-using">spring扩展xml文档</a></p>
<blockquote>
<p>spring通过XML解析程序将其解析为DOM树，通过NamespaceHandler指定对应的Namespace的BeanDefinitionParser将其转换成BeanDefinition。再通过Spring自身的功能对BeanDefinition实例化对象。</p>
</blockquote>
<blockquote>
<p>在期间，Spring还会加载两项资料：</p>
<ol>
<li>META-INF&#x2F;spring.handlers</li>
</ol>
</blockquote>
<blockquote>
<p>指定NamespaceHandler(实现org.springframework.beans.factory.xml.NamespaceHandler)接口，或使用org.springframework.beans.factory.xml.NamespaceHandlerSupport的子类。<br>2. META-INF&#x2F;spring.schemas </p>
</blockquote>
<blockquote>
<p>在解析XML文件时将XSD重定向到本地文件，避免在解析XML文件时需要上网下载XSD文件。通过现实org.xml.sax.EntityResolver接口来实现该功能。</p>
</blockquote>
<h2 id="ConfigHandler"><a href="#ConfigHandler" class="headerlink" title="ConfigHandler"></a>ConfigHandler</h2><p>解析完xml后，服务器通过ServiceConfigBean来监听spring容器加载完成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void onApplicationEvent(ContextRefreshedEvent event) &#123;</span><br><span class="line">        if (!getExported().get()) &#123;</span><br><span class="line">            export();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>调用export()，构建Exporter；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void export() &#123;</span><br><span class="line">        if (exported.get()) &#123;</span><br><span class="line">            LoggerUtil.warn(String.format(&quot;%s has already been expoted, so ignore the export request!&quot;, interfaceClass.getName()));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        checkInterfaceAndMethods(interfaceClass, methods);</span><br><span class="line"></span><br><span class="line">        List&lt;URL&gt; registryUrls = loadRegistryUrls();</span><br><span class="line">        if (registryUrls == null || registryUrls.size() == 0) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Should set registry config for service:&quot; + interfaceClass.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Integer&gt; protocolPorts = getProtocolAndPort();</span><br><span class="line">        for (ProtocolConfig protocolConfig : protocols) &#123;</span><br><span class="line">            Integer port = protocolPorts.get(protocolConfig.getId());</span><br><span class="line">            if (port == null) &#123;</span><br><span class="line">                throw new MotanServiceException(String.format(&quot;Unknow port in service:%s, protocol:%s&quot;, interfaceClass.getName(),</span><br><span class="line">                        protocolConfig.getId()));</span><br><span class="line">            &#125;</span><br><span class="line">            doExport(protocolConfig, port, registryUrls);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        afterExport();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法主要就做了两件事</p>
<ol>
<li>loadRegistryUrls()，根据<a href="motan:registry">motan:registry</a>,生成URL对象。URL也算是整个框架的核心，一个url包含了配置中的所有内容。就像一个领域对象一样。</li>
</ol>
<p>如果使用的是zookeeper，对就的URL就是：zookeeper:&#x2F;&#x2F;127.0.0.1:2181&#x2F;com.weibo.api.motan.registry.RegistryService?group&#x3D;default_rpc</p>
<p>这是注册中心的URL</p>
<p>而服务URL是以参数为embed为key包含在里面，里面包含了所有的服务参数</p>
<p>motan:&#x2F;&#x2F;127.0.0.1:8002&#x2F;com.share.rpc.service.DEMOService?module&#x3D;match-rpc&amp;loadbalance&#x3D;activeWeight&amp;nodeType&#x3D;service&amp;accessLog&#x3D;true&amp;minWorkerThread&#x3D;2&amp;protocol&#x3D;motan&amp;isDefault&#x3D;true&amp;maxWorkerThread&#x3D;10&amp;refreshTimestamp&#x3D;1486448597095&amp;id&#x3D;com.weibo.api.motan.config.springsupport.ServiceConfigBean&amp;export&#x3D;protocolMatch:8002&amp;requestTimeout&#x3D;60000&amp;group&#x3D;match-rpc&amp;</p>
<ol start="2">
<li>doExport()</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ConfigHandler configHandler = ExtensionLoader.getExtensionLoader(ConfigHandler.class).getExtension(MotanConstants.DEFAULT_VALUE);</span><br><span class="line"> exporters.add(configHandler.export(interfaceClass, ref, urls));</span><br></pre></td></tr></table></figure>
<p>到这儿就是委托给ConfigHandler处理了。</p>
<p>默认的实现类：SimpleConfigHandler</p>
<p>这个类里面有两个重要的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public &lt;T&gt; T refer(Class&lt;T&gt; interfaceClass, List&lt;Cluster&lt;T&gt;&gt; clusters, String proxyType) &#123;</span><br><span class="line">        ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getExtension(proxyType);</span><br><span class="line">        return proxyFactory.getProxy(interfaceClass, new RefererInvocationHandler&lt;T&gt;(interfaceClass, clusters));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public &lt;T&gt; Exporter&lt;T&gt; export(Class&lt;T&gt; interfaceClass, T ref, List&lt;URL&gt; registryUrls) &#123;</span><br><span class="line"></span><br><span class="line">        String serviceStr = StringTools.urlDecode(registryUrls.get(0).getParameter(URLParamType.embed.getName()));</span><br><span class="line">        URL serviceUrl = URL.valueOf(serviceStr);</span><br><span class="line"></span><br><span class="line">        // export service</span><br><span class="line">        // 利用protocol decorator来增加filter特性</span><br><span class="line">        String protocolName = serviceUrl.getParameter(URLParamType.protocol.getName(), URLParamType.protocol.getValue());</span><br><span class="line">        Protocol protocol = new ProtocolFilterDecorator(ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(protocolName));</span><br><span class="line">        Provider&lt;T&gt; provider = new DefaultProvider&lt;T&gt;(ref, serviceUrl, interfaceClass);</span><br><span class="line">        Exporter&lt;T&gt; exporter = protocol.export(provider, serviceUrl);</span><br><span class="line"></span><br><span class="line">        // register service</span><br><span class="line">        register(registryUrls, serviceUrl);</span><br><span class="line"></span><br><span class="line">        return exporter;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>refer()就是RefererConfig配置完后的调用的方法，就看到了客户端的核心类RefererInvocationHandler</p>
<p>export()就是服务端使用的方法了。</p>
<p>构造provider</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Provider&lt;T&gt; extends Caller&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    Class&lt;T&gt; getInterface();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是外面服务类的代理类,里面就一个服务类的引用。在初始化时，把所有的方法全部缓存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void initMethodMap(Class&lt;T&gt; clz) &#123;</span><br><span class="line">        Method[] methods = clz.getMethods();</span><br><span class="line"></span><br><span class="line">        for (Method method : methods) &#123;</span><br><span class="line">            String methodDesc = ReflectUtil.getMethodDesc(method);</span><br><span class="line">            methodMap.put(methodDesc, method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Protocol的export就是启动一个netty server，提供对外服务。</p>
<h2 id="register-注册服务"><a href="#register-注册服务" class="headerlink" title="register 注册服务"></a>register 注册服务</h2><p>按上面export()，先启动一个netty server，服务一切就绪后，再向注册中心进行注册了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void register(List&lt;URL&gt; registryUrls, URL serviceUrl) &#123;</span><br><span class="line"></span><br><span class="line">        for (URL url : registryUrls) &#123;</span><br><span class="line">            // 根据check参数的设置，register失败可能会抛异常，上层应该知晓</span><br><span class="line">            RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getExtension(url.getProtocol());</span><br><span class="line">            if (registryFactory == null) &#123;</span><br><span class="line">                throw new MotanFrameworkException(new MotanErrorMsg(500, MotanErrorMsgConstant.FRAMEWORK_REGISTER_ERROR_CODE,</span><br><span class="line">                        &quot;register error! Could not find extension for registry protocol:&quot; + url.getProtocol()</span><br><span class="line">                                + &quot;, make sure registry module for &quot; + url.getProtocol() + &quot; is in classpath!&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">            Registry registry = registryFactory.getRegistry(url);</span><br><span class="line">            registry.register(serviceUrl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>根据注册协议选择注册中心<br>RegistryFacotry有三种：1. direct 2.local 3.zookeeper</p>
<p>对应的registry也是这三种</p>
<p>在zookeeperregistry里面，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protected void doRegister(URL url) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            serverLock.lock();</span><br><span class="line">            // 防止旧节点未正常注销</span><br><span class="line">            removeNode(url, ZkNodeType.AVAILABLE_SERVER);</span><br><span class="line">            removeNode(url, ZkNodeType.UNAVAILABLE_SERVER);</span><br><span class="line">            createNode(url, ZkNodeType.UNAVAILABLE_SERVER);</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            throw new MotanFrameworkException(String.format(&quot;Failed to register %s to zookeeper(%s), cause: %s&quot;, url, getUrl(), e.getMessage()), e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            serverLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这儿注册后，这个服务还是unavailable，需要调用<br>MotanSwitcherUtil.setSwitcherValue(MotanConstants.REGISTRY_HEARTBEAT_SWITCHER, true);才能变成available</p>
<h1 id="NettyServer"><a href="#NettyServer" class="headerlink" title="NettyServer"></a>NettyServer</h1><p>一样的套路，有一个默认ChannelHandler，其实什么事都不干，只是包装一下自定义Handler</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">final NettyChannelHandler handler = new NettyChannelHandler(NettyServer.this, messageHandler,</span><br><span class="line">				standardThreadExecutor);</span><br><span class="line"></span><br><span class="line">		bootstrap.setPipelineFactory(new ChannelPipelineFactory() &#123;</span><br><span class="line">			// FrameDecoder非线程安全，每个连接一个 Pipeline</span><br><span class="line">			public ChannelPipeline getPipeline() &#123;</span><br><span class="line">				ChannelPipeline pipeline = Channels.pipeline();</span><br><span class="line">				pipeline.addLast(&quot;channel_manage&quot;, channelManage);</span><br><span class="line">				pipeline.addLast(&quot;decoder&quot;, new NettyDecoder(codec, NettyServer.this, maxContentLength));</span><br><span class="line">				pipeline.addLast(&quot;encoder&quot;, new NettyEncoder(codec, NettyServer.this));</span><br><span class="line">				pipeline.addLast(&quot;handler&quot;, handler);</span><br><span class="line">				return pipeline;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br></pre></td></tr></table></figure>

<p>这儿有个有意思的MessageHandler:ProviderProtectedMessageRouter<br>从名字看，有保护功能</p>
<blockquote>
<ol>
<li>如果接口只有一个方法，那么直接return true </li>
<li>如果接口有多个方法，那么如果单个method超过 maxThread &#x2F; 2 &amp;&amp; totalCount &gt;  (maxThread * 3 &#x2F; 4)，那么return false;</li>
<li>如果接口有多个方法(4个)，同时总的请求数超过 maxThread * 3 &#x2F; 4，同时该method的请求数超过 maxThead * 1 &#x2F; 4， 那么return false</li>
<li>其他场景return true</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">protected boolean isAllowRequest(int requestCounter, int totalCounter, int maxThread, Request request) &#123;</span><br><span class="line">        if (methodCounter.get() == 1) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 该方法第一次请求，直接return true</span><br><span class="line">        if (requestCounter == 1) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 不简单判断 requsetCount &gt; (maxThread / 2) ，因为假如有2或者3个method对外提供，</span><br><span class="line">        // 但是只有一个接口很大调用量，而其他接口很空闲，那么这个时候允许单个method的极限到 maxThread * 3 / 4</span><br><span class="line">        if (requestCounter &gt; (maxThread / 2) &amp;&amp; totalCounter &gt; (maxThread * 3 / 4)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果总体线程数超过 maxThread * 3 / 4个，并且对外的method比较多，那么意味着这个时候整体压力比较大，</span><br><span class="line">        // 那么这个时候如果单method超过 maxThread * 1 / 4，那么reject</span><br><span class="line">        return !(methodCounter.get() &gt;= 4 &amp;&amp; totalCounter &gt; (maxThread * 3 / 4) &amp;&amp; requestCounter &gt; (maxThread * 1 / 4));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>拒绝的结果就是放一个异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private Response reject(String method, int requestCounter, int totalCounter, int maxThread) &#123;</span><br><span class="line">        DefaultResponse response = new DefaultResponse();</span><br><span class="line">        MotanServiceException exception =</span><br><span class="line">                new MotanServiceException(&quot;ThreadProtectedRequestRouter reject request: request_counter=&quot; + requestCounter</span><br><span class="line">                        + &quot; total_counter=&quot; + totalCounter + &quot; max_thread=&quot; + maxThread, MotanErrorMsgConstant.SERVICE_REJECT);</span><br><span class="line">        exception.setStackTrace(new StackTraceElement[0]);</span><br><span class="line">        response.setException(exception);</span><br><span class="line">        LoggerUtil.error(&quot;ThreadProtectedRequestRouter reject request: request_method=&quot; + method + &quot; request_counter=&quot; + requestCounter</span><br><span class="line">                + &quot; =&quot; + totalCounter + &quot; max_thread=&quot; + maxThread);</span><br><span class="line">        return response;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="other"><a href="#other" class="headerlink" title="other"></a>other</h1><h2 id="RpcContext"><a href="#RpcContext" class="headerlink" title="RpcContext"></a>RpcContext</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static final ThreadLocal&lt;RpcContext&gt; localContext = new ThreadLocal&lt;RpcContext&gt;() &#123;</span><br><span class="line">        protected RpcContext initialValue() &#123;</span><br><span class="line">            return new RpcContext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public static RpcContext getContext() &#123;</span><br><span class="line">        return localContext.get();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个ThreadLocal尽然还可以设置默认初始值，以前尽然没用过</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>服务端相对客户端还是很简单的。</p>
<p>没有ha,loadbalance，就是原生netty就把请求处理完了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://www.zhuxingsheng.com/blog/motan-client.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="朱兴生">
      <meta itemprop="description" content="彪悍的人生需要书写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码农戏码">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/motan-client.html" class="post-title-link" itemprop="url">motan客户端</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-01-20 16:01:00" itemprop="dateCreated datePublished" datetime="2017-01-20T16:01:00+08:00">2017-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-29 15:24:30" itemprop="dateModified" datetime="2021-09-29T15:24:30+08:00">2021-09-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/source/" itemprop="url" rel="index"><span itemprop="name">源码解读</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="RPC的本质"><a href="#RPC的本质" class="headerlink" title="RPC的本质"></a>RPC的本质</h1><p>方法调用对于程序员来讲是再正常不过的事了，object.method()，RPC的使用也一样，但底层对这一过程又切分开，有client和server两端，也就是调用者与实现者</p>
<p>因为他们不再在同一进程中，需要通过网络跨JVM实现这一调用过程</p>
<p>在java中的实现手法：动态代理+socket通信；这就是个套路，上层怎么封装实现，但底层就是这样，概莫能外</p>
<h1 id="请求过程"><a href="#请求过程" class="headerlink" title="请求过程"></a>请求过程</h1><h2 id="motan的调用实现"><a href="#motan的调用实现" class="headerlink" title="motan的调用实现"></a>motan的调用实现</h2><p>先画个简单的序列图，理清一下调用过程<br><img src="http://qnimages.zhuxingsheng.com/motan-proxy-handle.png?imageView2/0/q/75%7Cwatermark/2/text/emh1eGluZ3NoZW5nLmNvbQ==/font/6buR5L2T/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt="image"></p>
<p>motan与spring的结合，后面再写了，spring的扩展也很简单。</p>
<p>基于对RPC本质的认识，可以先找到InvocationHandler的实现类RefererInvocationHandler</p>
<p>这个接口就一个方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">        throws Throwable;</span><br></pre></td></tr></table></figure>
<p>在这个方法里面就是去构造socket传输的request对象，request主要就是方法的签名信息与参数，传输到server端，去执行对应的实现方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        if(isLocalMethod(method))&#123;</span><br><span class="line">            if(&quot;toString&quot;.equals(method.getName()))&#123;</span><br><span class="line">                return clustersToString();</span><br><span class="line">            &#125;</span><br><span class="line">            throw new MotanServiceException(&quot;can not invoke local method:&quot; + method.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        DefaultRequest request = new DefaultRequest();</span><br><span class="line"></span><br><span class="line">        request.setRequestId(RequestIdGenerator.getRequestId());</span><br><span class="line">        request.setArguments(args);</span><br><span class="line">        request.setMethodName(method.getName());</span><br><span class="line">        request.setParamtersDesc(ReflectUtil.getMethodParamDesc(method));</span><br><span class="line">        request.setInterfaceName(clz.getName());</span><br><span class="line">        request.setAttachment(URLParamType.requestIdFromClient.getName(), String.valueOf(RequestIdGenerator.getRequestIdFromClient()));</span><br><span class="line"></span><br><span class="line">        // 当 referer配置多个protocol的时候，比如A,B,C，</span><br><span class="line">        // 那么正常情况下只会使用A，如果A被开关降级，那么就会使用B，B也被降级，那么会使用C</span><br><span class="line">        for (Cluster&lt;T&gt; cluster : clusters) &#123;</span><br><span class="line">            String protocolSwitcher = MotanConstants.PROTOCOL_SWITCHER_PREFIX + cluster.getUrl().getProtocol();</span><br><span class="line"></span><br><span class="line">            Switcher switcher = switcherService.getSwitcher(protocolSwitcher);</span><br><span class="line"></span><br><span class="line">            if (switcher != null &amp;&amp; !switcher.isOn()) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            request.setAttachment(URLParamType.version.getName(), cluster.getUrl().getVersion());</span><br><span class="line">            request.setAttachment(URLParamType.clientGroup.getName(), cluster.getUrl().getGroup());</span><br><span class="line">            // 带上client的application和module</span><br><span class="line">            request.setAttachment(URLParamType.application.getName(), ApplicationInfo.getApplication(cluster.getUrl()).getApplication());</span><br><span class="line">            request.setAttachment(URLParamType.module.getName(), ApplicationInfo.getApplication(cluster.getUrl()).getModule());</span><br><span class="line">            Response response = null;</span><br><span class="line">            boolean throwException =</span><br><span class="line">                    Boolean.parseBoolean(cluster.getUrl().getParameter(URLParamType.throwException.getName(),</span><br><span class="line">                            URLParamType.throwException.getValue()));</span><br><span class="line">            try &#123;</span><br><span class="line">                //真正执行</span><br><span class="line">                response = cluster.call(request);</span><br><span class="line">                return response.getValue();</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>invoke交给了Cluster.call，而Cluster又给了HAStragy.call，HA策略通过loadbalance选择负载均衡策略得到Referer</p>
<h2 id="Cluster是什么"><a href="#Cluster是什么" class="headerlink" title="Cluster是什么"></a>Cluster是什么</h2><p>在InvocationHandler里面,调用了Cluster的call方法，从代码上看，它的本质就是Referer的集合，并且提供了HA服务以及负载均衡。而Referer是提供服务的一个抽象</p>
<h2 id="HA与LoadBalance"><a href="#HA与LoadBalance" class="headerlink" title="HA与LoadBalance"></a>HA与LoadBalance</h2><p><img src="http://qnimages.zhuxingsheng.com/motan-ha-loadbalance.jpg" alt="image"></p>
<h3 id="HA"><a href="#HA" class="headerlink" title="HA"></a>HA</h3><p>HA策略，就提供了两种，</p>
<h4 id="fail-fast"><a href="#fail-fast" class="headerlink" title="fail-fast"></a>fail-fast</h4><p>fail-fast很简单，调用失败就抛异常；</p>
<h4 id="fail-over"><a href="#fail-over" class="headerlink" title="fail-over"></a>fail-over</h4><p>fail-over相对fail-fast多了重试次数，如果失败，就重试一个referer</p>
<h3 id="LoadBalance"><a href="#LoadBalance" class="headerlink" title="LoadBalance"></a>LoadBalance</h3><p>这倒提供了不少</p>
<h4 id="Round-Robin"><a href="#Round-Robin" class="headerlink" title="Round-Robin"></a>Round-Robin</h4><p>这个很简单，一个一个往下轮询就行了，<br>但需要记住上一次的位置</p>
<h4 id="random"><a href="#random" class="headerlink" title="random"></a>random</h4><p>随机</p>
<h4 id="Least-Load"><a href="#Least-Load" class="headerlink" title="Least Load"></a>Least Load</h4><p>这个motan实现有点意思</p>
<blockquote>
<p>由于Referer List可能很多，比如上百台，如果每次都要从这上百个Referer或者最低并发的几个，性能有些损耗，因此 random.nextInt(list.size())获取一个起始的index，然后获取最多不超过MAX_REFERER_COUNT的 状态是isAvailable的referer进行判断activeCount.</p>
</blockquote>
<h4 id="localFirst"><a href="#localFirst" class="headerlink" title="localFirst"></a>localFirst</h4><blockquote>
<p>本地服务优先获取策略：对referers根据ip顺序查找本地服务，多存在多个本地服务，获取Active最小的本地服务进行服务。当不存在本地服务，但是存在远程RPC服务，则根据ActivWeight获取远程RPC服务;当两者都存在，所有本地服务都应优先于远程服务，本地RPC服务与远程RPC服务内部则根据ActiveWeight进行</p>
</blockquote>
<h2 id="NettyClient"><a href="#NettyClient" class="headerlink" title="NettyClient"></a>NettyClient</h2><p>上层不管怎么选择服务，最后都需要传输层去传输，nettyclient就是传输作用。</p>
<p>在DefaultRpcReferer中创建了一个nettyClient。向server发送远程调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private Response request(Request request, boolean async) throws TransportException &#123;</span><br><span class="line">		Channel channel = null;</span><br><span class="line"></span><br><span class="line">		Response response = null;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			// return channel or throw exception(timeout or connection_fail)</span><br><span class="line">			channel = borrowObject();</span><br><span class="line"></span><br><span class="line">			if (channel == null) &#123;</span><br><span class="line">				LoggerUtil.error(&quot;NettyClient borrowObject null: url=&quot; + url.getUri() + &quot; &quot;</span><br><span class="line">						+ MotanFrameworkUtil.toString(request));</span><br><span class="line">				return null;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// async request</span><br><span class="line">			response = channel.request(request);</span><br><span class="line">			// return channel to pool</span><br><span class="line">			returnObject(channel);</span><br></pre></td></tr></table></figure>
<p>使用了common-pool连接池</p>
<p>在这儿是委托给了nettychannel.request()，nettyclient与nettychannel是什么关系呢？<br>client有server地址,channel就是这个地址连接的通道。<br>在nettychannel中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public Response request(Request request) throws TransportException &#123;</span><br><span class="line">	    int timeout = nettyClient.getUrl().getMethodParameter(request.getMethodName(), request.getParamtersDesc(),</span><br><span class="line">	            URLParamType.requestTimeout.getName(), URLParamType.requestTimeout.getIntValue());</span><br><span class="line">		if (timeout &lt;= 0) &#123;</span><br><span class="line">               throw new MotanFrameworkException(&quot;NettyClient init Error: timeout(&quot; + timeout + &quot;) &lt;= 0 is forbid.&quot;,</span><br><span class="line">                       MotanErrorMsgConstant.FRAMEWORK_INIT_ERROR);</span><br><span class="line">           &#125;</span><br><span class="line">		NettyResponseFuture response = new NettyResponseFuture(request, timeout, this.nettyClient);</span><br><span class="line">		this.nettyClient.registerCallback(request.getRequestId(), response);</span><br><span class="line"></span><br><span class="line">		ChannelFuture writeFuture = this.channel.write(request);</span><br><span class="line"></span><br><span class="line">		boolean result = writeFuture.awaitUninterruptibly(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">		if (result &amp;&amp; writeFuture.isSuccess()) &#123;</span><br><span class="line">			response.addListener(new FutureListener() &#123;</span><br><span class="line">				@Override</span><br><span class="line">				public void operationComplete(Future future) throws Exception &#123;</span><br><span class="line">					if (future.isSuccess() || (future.isDone() &amp;&amp; ExceptionUtil.isBizException(future.getException()))) &#123;</span><br><span class="line">						// 成功的调用 </span><br><span class="line">						nettyClient.resetErrorCount();</span><br><span class="line">					&#125; else &#123;</span><br><span class="line">						// 失败的调用 </span><br><span class="line">						nettyClient.incrErrorCount();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">			return response;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>到此，整个请求过程已经完成。</p>
<h1 id="返回处理"><a href="#返回处理" class="headerlink" title="返回处理"></a>返回处理</h1><p>调用完成之后，总得得到结果才行</p>
<h2 id="motan返回过程"><a href="#motan返回过程" class="headerlink" title="motan返回过程"></a>motan返回过程</h2><p>在上面nettychannel.request方法，会返回一个response，NettyResponseFuture这个类名就说明了一切，使用了Future模式。</p>
<p>在返回response时，构造真实response</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private Response asyncResponse(Response response, boolean async) &#123;</span><br><span class="line">		if (async || !(response instanceof NettyResponseFuture)) &#123;</span><br><span class="line">			return response;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return new DefaultResponse(response);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<p>真实response里面，使用futureresponse去取值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public DefaultResponse(Response response) &#123;</span><br><span class="line">        this.value = response.getValue();</span><br><span class="line">        this.exception = response.getException();</span><br><span class="line">        this.requestId = response.getRequestId();</span><br><span class="line">        this.processTime = response.getProcessTime();</span><br><span class="line">        this.timeout = response.getTimeout();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在futureresponse里面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public Object getValue() &#123;</span><br><span class="line">		synchronized (lock) &#123;</span><br><span class="line">			if (!isDoing()) &#123;</span><br><span class="line">				return getValueOrThrowable();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (timeout &lt;= 0) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					lock.wait();</span><br><span class="line">				&#125; catch (Exception e) &#123;</span><br><span class="line">					cancel(new MotanServiceException(&quot;NettyResponseFuture getValue InterruptedException : &quot;</span><br><span class="line">							+ MotanFrameworkUtil.toString(request) + &quot; cost=&quot;</span><br><span class="line">							+ (System.currentTimeMillis() - createTime), e));</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				// don&#x27;t need to notifylisteners, because onSuccess or</span><br><span class="line">				// onFailure or cancel method already call notifylisteners</span><br><span class="line">				return getValueOrThrowable();</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				long waitTime = timeout - (System.currentTimeMillis() - createTime);</span><br><span class="line"></span><br><span class="line">				if (waitTime &gt; 0) &#123;</span><br><span class="line">					for (;;) &#123;</span><br><span class="line">						try &#123;</span><br><span class="line">							lock.wait(waitTime);</span><br><span class="line">						&#125; catch (InterruptedException e) &#123;</span><br><span class="line">						&#125;</span><br><span class="line"></span><br><span class="line">						if (!isDoing()) &#123;</span><br><span class="line">							break;</span><br><span class="line">						&#125; else &#123;</span><br><span class="line">							waitTime = timeout - (System.currentTimeMillis() - createTime);</span><br><span class="line">							if (waitTime &lt;= 0) &#123;</span><br><span class="line">								break;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				if (isDoing()) &#123;</span><br><span class="line">					timeoutSoCancel();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			return getValueOrThrowable();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>没有使用java.util.concurrent包中Condition,CountDownLatch之类的工具类，而是使用原始的wait,notify组合</p>
<p>在NettyClient中,得到返回对象后，对responsefuter进行赋值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pipeline.addLast(&quot;handler&quot;, new NettyChannelHandler(NettyClient.this, new MessageHandler() &#123;</span><br><span class="line">					@Override</span><br><span class="line">					public Object handle(Channel channel, Object message) &#123;</span><br><span class="line">					    //得到返回对象</span><br><span class="line">						Response response = (Response) message;</span><br><span class="line">                        //得到对应request的future</span><br><span class="line">						NettyResponseFuture responseFuture = NettyClient.this.removeCallback(response.getRequestId());</span><br><span class="line"></span><br><span class="line">						if (responseFuture == null) &#123;</span><br><span class="line">							LoggerUtil.warn(</span><br><span class="line">									&quot;NettyClient has response from server, but resonseFuture not exist,  requestId=&#123;&#125;&quot;,</span><br><span class="line">									response.getRequestId());</span><br><span class="line">							return null;</span><br><span class="line">						&#125;</span><br><span class="line"></span><br><span class="line">						if (response.getException() != null) &#123;</span><br><span class="line">							responseFuture.onFailure(response);</span><br><span class="line">						&#125; else &#123;</span><br><span class="line">							responseFuture.onSuccess(response);</span><br><span class="line">						&#125;</span><br><span class="line"></span><br><span class="line">						return null;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;));</span><br></pre></td></tr></table></figure>

<p>responseFuture的onsuccess方法,进行赋值并notify</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void onSuccess(Response response) &#123;</span><br><span class="line">		this.result = response.getValue();</span><br><span class="line">		this.processTime = response.getProcessTime();</span><br><span class="line"></span><br><span class="line">		done();</span><br><span class="line">	&#125;</span><br><span class="line">private boolean done() &#123;</span><br><span class="line">		synchronized (lock) &#123;</span><br><span class="line">			if (!isDoing()) &#123;</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			state = FutureState.DONE;</span><br><span class="line">			lock.notifyAll();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		notifyListeners();</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到此，客户端部分已经完成，主要就是两方面</p>
<ol>
<li>调用请求</li>
<li>返回处理</li>
</ol>
<p>还有一些问题：</p>
<ol>
<li>客户端怎么服务发现的？</li>
<li>服务降低怎么处理的？</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://www.zhuxingsheng.com/blog/motan-extension-mechanism.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="朱兴生">
      <meta itemprop="description" content="彪悍的人生需要书写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码农戏码">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/motan-extension-mechanism.html" class="post-title-link" itemprop="url">motan扩展机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-01-08 16:04:00" itemprop="dateCreated datePublished" datetime="2017-01-08T16:04:00+08:00">2017-01-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-29 15:24:30" itemprop="dateModified" datetime="2021-09-29T15:24:30+08:00">2021-09-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/source/" itemprop="url" rel="index"><span itemprop="name">源码解读</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>motan第二篇,本来想写motan的rpc调用过程的，但项目中的需求需要对motan进行扩展，所以就先记录下</p>
<h2 id="引导"><a href="#引导" class="headerlink" title="引导"></a>引导</h2><p>在写一个框架或者在项目中提供一些底层服务时，都会有这种情况，会有一些默认的实现，但你知道这些默认实现只是很满足很基本的自身需求，开发人员可能会扩展，想自定义一个实现</p>
<p>处理方式</p>
<ol>
<li>提供一个设置实现类的setter，开发者在初始化时调用一下</li>
<li>提供配置入口，给个key,配置上自定义类名</li>
<li>类似slf4j一样，提供桥接类</li>
</ol>
<h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><p>motan使用了spi的方式</p>
<p>SPI(Service Provider Interface),服务提供接口；也是一种服务发现机制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">系统里抽象的各个模块，往往有很多不同的实现方案，</span><br><span class="line">比如日志模块的方案，xml解析模块、jdbc模块的方案等。面向的对象的设计里，</span><br><span class="line">我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码</span><br><span class="line">。一旦代码里涉及具体的实现类，就违反了可拔插的原则，</span><br><span class="line">如果需要替换一种实现，就需要修改代码。</span><br><span class="line"></span><br><span class="line">为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。</span><br><span class="line">java spi就是提供这样的一个机制：为某个接口寻找服务实现的机制。</span><br><span class="line">有点类似IOC的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要。</span><br></pre></td></tr></table></figure>

<p>在JDK6之前，你可能会自己定义一种服务提供的约定，在JDK6之后，java也提供了标准约定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">扩展者在jar包的META-INF/services/目录下放置与接口同名的文本文件 </span><br><span class="line">内容为接口实现类名，多个实现类名用换行符分隔</span><br></pre></td></tr></table></figure>
<p>java.util.ServiceLoader类来实现从配置文件中加载子类或者接口的实现类</p>
<h4 id="SPI与API的区别"><a href="#SPI与API的区别" class="headerlink" title="SPI与API的区别"></a>SPI与API的区别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">What is the difference between Service Provider Interface (SPI) and Application Programming Interface (API)?</span><br><span class="line">More specifically, for Java libraries, what makes them an API and/or SPI?</span><br><span class="line">the API is the description of classes/interfaces/methods/... </span><br><span class="line">that you call and use to achieve a goal</span><br><span class="line">the SPI is the description of classes/interfaces/methods/... </span><br><span class="line">that you extend and implement to achieve a goal</span><br><span class="line">Put differently, the API tells you what a specific class/method does for you and the SPI tells you what you must do to conform.</span><br><span class="line">Sometimes SPI and API overlap. </span><br><span class="line">For example in JDBC the Driver class is part of the SPI: </span><br><span class="line">If you simply want to use JDBC, you don&#x27;t need to use it directly, but everyone who implements a JDBC driver must implement that class.</span><br><span class="line">The Connection interface on the other hand is both SPI and API: </span><br><span class="line">You use it routinely when you use a JDBC driver and it needs to be implemented by the developer of the JDBC driver。</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h2 id="JDK-spi"><a href="#JDK-spi" class="headerlink" title="JDK spi"></a>JDK spi</h2><p>使用jdk自带的ServiceLoader写一个示例：</p>
<p>一个接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Spi &#123;</span><br><span class="line"></span><br><span class="line">    public void provide();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个实现类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultSpi implements Spi&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void provide() &#123;</span><br><span class="line">        System.out.println(&quot;默认spi实现&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>入口类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 一个spi的demo</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class SpiDemoMain</span><br><span class="line">&#123;</span><br><span class="line">    public static void main( String[] args )</span><br><span class="line">    &#123;</span><br><span class="line">        ServiceLoader&lt;Spi&gt; spiServiceLoader = ServiceLoader.load(Spi.class);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Spi&gt; spiIterator = spiServiceLoader.iterator();</span><br><span class="line"></span><br><span class="line">        while ( spiIterator.hasNext()) &#123;</span><br><span class="line">            spiIterator.next().provide();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在META-INF文件夹里面新建个services文件夹，在services文件夹里面新建一个<br>com.jjk.spi.Spi文件</p>
<p>完整的代码可从<a href="https://github.com/zhuxingsheng/spidemo">https://github.com/zhuxingsheng/spidemo</a>下载</p>
<h4 id="ServiceLoader源码解析"><a href="#ServiceLoader源码解析" class="headerlink" title="ServiceLoader源码解析"></a>ServiceLoader源码解析</h4><p>原理很简单，一个类实现这个SPI机制</p>
<p>它的本质，也就是从某个地方加载服务实现类，文件名是服务接口名</p>
<p>定义存放文件的地方</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final String PREFIX = &quot;META-INF/services/&quot;;</span><br></pre></td></tr></table></figure>

<p>类内部使用了延迟加载LazyIterator，在使用到了实现类时，才去实例化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private S nextService() &#123;</span><br><span class="line">            if (!hasNextService())</span><br><span class="line">                throw new NoSuchElementException();</span><br><span class="line">            String cn = nextName;</span><br><span class="line">            nextName = null;</span><br><span class="line">            Class&lt;?&gt; c = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                </span><br><span class="line">                c = Class.forName(cn, false, loader);</span><br><span class="line">            &#125; catch (ClassNotFoundException x) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     &quot;Provider &quot; + cn + &quot; not found&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     &quot;Provider &quot; + cn  + &quot; not a subtype&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">            // 调用next方法时，才实例化</span><br><span class="line">                S p = service.cast(c.newInstance());</span><br><span class="line">                providers.put(cn, p);</span><br><span class="line">                return p;</span><br><span class="line">            &#125; catch (Throwable x) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     &quot;Provider &quot; + cn + &quot; could not be instantiated&quot;,</span><br><span class="line">                     x);</span><br><span class="line">            &#125;</span><br><span class="line">            throw new Error();          // This cannot happen</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="motan-spi"><a href="#motan-spi" class="headerlink" title="motan spi"></a>motan spi</h2><p>motan的spi，跟java spi差不多，但做了一些加强</p>
<p>先看官方文档</p>
<blockquote>
<ol>
<li>实现SPI扩展点接口</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>实现类增加注解<br>@Spi(scope &#x3D; Scope.SINGLETON)  &#x2F;&#x2F;扩展加载形式，单例或多例<br>@SpiMeta(name &#x3D; “motan”)  &#x2F;&#x2F;name表示扩展点的名称，根据name加载对应扩展<br>@Activation(sequence &#x3D; 100) &#x2F;&#x2F;同类型扩展生效顺序，部分扩展点支持。非必填<br>增加SPI实现声明 ${classpath}&#x2F;MATA-INF&#x2F;services&#x2F;${SPI interface fullname}文件中添加对应SPI接口实现类全名。 可参照motan-core模块&#x2F;MATA-INF&#x2F;services&#x2F;下的配置</li>
</ol>
</blockquote>
<p>主要类就是com.weibo.api.motan.core.extension.ExtensionLoader<br>代码在<a href="https://github.com/zhuxingsheng/motan/blob/master/motan-core/src/main/java/com/weibo/api/motan/core/extension/ExtensionLoader.java#L100-99">https://github.com/zhuxingsheng/motan/blob/master/motan-core/src/main/java/com/weibo/api/motan/core/extension/ExtensionLoader.java#L100-99</a><br>其实代码很简单，不需要额外的解读，都能看明白</p>
<p>还有几个注解类</p>
<p>@Spi  指定类生命周期</p>
<p>@SpiMeta 给类一个别名，方便配置时使用</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://www.zhuxingsheng.com/blog/introduction-to-motan.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="朱兴生">
      <meta itemprop="description" content="彪悍的人生需要书写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码农戏码">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/introduction-to-motan.html" class="post-title-link" itemprop="url">motan入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-01-04 11:05:00" itemprop="dateCreated datePublished" datetime="2017-01-04T11:05:00+08:00">2017-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-29 15:24:30" itemprop="dateModified" datetime="2021-09-29T15:24:30+08:00">2021-09-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/source/" itemprop="url" rel="index"><span itemprop="name">源码解读</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://github.com/weibocom/motan/">motan</a> weibo的RPC框架，Motan是一套高性能、易于使用的分布式远程服务调用(RPC)框架</p>
<p>这次在项目中引入了此框架。</p>
<p>在使用中学习。研读下源码。记录下使用学习过程。</p>
<h3 id="RPC原理"><a href="#RPC原理" class="headerlink" title="RPC原理"></a>RPC原理</h3><p><img src="https://www.cs.rutgers.edu/~pxk/417/notes/images/rpc-flow.png" alt="image"></p>
<p>什么是Stub？</p>
<p>Stub是一段代码，用来转换RPC过程中传递的参数。处理内容包括不同OS之间的大小端问题。另外，Client端一般叫Stub，Server端一般叫Skeleton。</p>
<p>生产方式：1）手动生成，比较麻烦；2）自动生成，使用IDL（InterfaceDescriptionLanguate），定义C&#x2F;S的接口。</p>
<p>交互机制标准：一般采用IDL，生成IDL的工具 RPCGEN（）。</p>
<h3 id="为什么引入motan"><a href="#为什么引入motan" class="headerlink" title="为什么引入motan"></a>为什么引入motan</h3><p>引入它，主要是因为它能满足项目需求；</p>
<ol>
<li>它比较牛，支撑了整个weibo</li>
<li>集成了spring,基本无侵入</li>
<li>具有集群功能，支持zookeeper</li>
</ol>
<p>还有别的优点了，官方文档写得很漂亮，但这几点已经足以吸引我</p>
<h3 id="motan-demo"><a href="#motan-demo" class="headerlink" title="motan demo"></a>motan demo</h3><p>直接官方示例吧，也可以</p>
<p><a href="https://github.com/zhuxingsheng/motan">fork me</a></p>
<p>我会在阅读源码的过程中，加上注释</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://www.zhuxingsheng.com/blog/the-clean-coder-reading-notes.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="朱兴生">
      <meta itemprop="description" content="彪悍的人生需要书写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码农戏码">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/the-clean-coder-reading-notes.html" class="post-title-link" itemprop="url">The clean coder 读书笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-12-11 14:24:00" itemprop="dateCreated datePublished" datetime="2016-12-11T14:24:00+08:00">2016-12-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-01-21 20:17:46" itemprop="dateModified" datetime="2024-01-21T20:17:46+08:00">2024-01-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/readbook/" itemprop="url" rel="index"><span itemprop="name">读书</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="http://images.zhuxingsheng.com/201811211420_706.png"></p>
<p>这本书不厚，但都是干货。</p>
<p>在前言中，就写了本书的目的：</p>
<blockquote>
<ol>
<li>什么是软件专业人士</li>
<li>软件专业人士如何行事</li>
<li>软件专业人士如何处理冲突，应对很紧的工期，如何和不讲道理的管理人员打交道</li>
<li>软件专业人士何时应该说”不”？怎么说？</li>
<li>软件专业人士如何应对压力？</li>
</ol>
</blockquote>
<p>这些问题，也正是一名软件开发人员需要去了解的问题。</p>
<blockquote>
<p>所谓专业人士：就是能对自己犯下错误负责的人，哪怕那些错误实际上在所难免</p>
</blockquote>
<p>专业人士有哪些特性呢？</p>
<ol>
<li>不担当，比如代码测试的全覆盖</li>
<li>不随便承诺</li>
<li>不会阻止别人修改自己的代码</li>
<li>满足雇主的需求</li>
<li>需要专门训练提升自己的技能</li>
</ol>
<p>摘录一些干货，再对比一下当下的开发环境，那是相当贴切</p>
<blockquote>
<p>为什么大多数开发人员不敢不断修改他的代码呢？因为他们害怕会改坏代码！为什么会有这样的担心呢？因为他们没有做过测试</p>
</blockquote>
<p>这个对于现在的开发环境太真实了，在一个项目上线后，其实在开发中后期，就已经出现这样的情况</p>
<ol>
<li>一个方法，代码很乱，逻辑看着有点不通，出于对代码整洁的追求，重构起来，结果发布之后，出现了bug，原先功能已经不能正常运作了，而这个bug，得等很多才会被发现，因为这个功不在本期开发版本计划中，过了测试期了</li>
<li>一个方法里面有行代码，看似无用，删除了吧，结果又出了一个隐形的bug</li>
</ol>
<p>正是以上问题，所以项目中的人越来越不敢动代码，不能删，不能改，只能加，有新需求，就只能加点代码，只要能正常工作，就不要管别的代码了，管了就得挂。</p>
<p>这就是完全没有测试的问题。</p>
<blockquote>
<p>要用这些自动化单元测试去测多少代码呢？还要说吗？全部！全部都要测</p>
</blockquote>
<p>这一种方法，就是TDD，来规避这个问题。</p>
<p>作者是TDD的践行者</p>
<blockquote>
<p>如果连所有代码是否都可以正常运行都不知道，还算什么专业人士？</p>
</blockquote>
<p>如果说多年前，很多人对TDD有疑问，当然现在还是有人有疑问，有疑问的原因，就是你还没有践行TDD。</p>
<p>对于TDD：</p>
<blockquote>
<ol>
<li>此事已有定论</li>
<li>争论已经结束</li>
<li>GOTO是有害的</li>
<li>TDD确实可行</li>
</ol>
</blockquote>
<p>有此人事先写代码，事后再写测试，这种方法相对于TDD来讲呢？</p>
<blockquote>
<p>如果很仔细地来看，也许后写测试还可以达到较高的覆盖率真。但是事后写的测试只是一种防守。而先行编写的测试则是进攻，事后编写测试的作者已经受制于已有代码，他已经知道问题是如何解决的。与采用测试先行的方式编写的测试代码比起来，后写的测试在深度和捕获错误的灵敏度方面要逊色很多</p>
</blockquote>
<p>一个开发方法，业界已经得到普遍认可，但国内有多少公司实施了？至少我所经历的公司都没有。<br>聪明的开发者们宁可在出了问题花大量的精力去一步步调试，也不愿花一点点的时间去写单元测试，执行TDD。</p>
<p>曾经在读云风博客时，发现一段有共鸣的话</p>
<blockquote>
<p>反感围绕着调试的开发方式，也是不断的在测试，试错，纠正的循环中奔波，好的程序员应该努力的在编写的过程中，在头脑中排错，在预感到坏味道时，就赶紧重写，而坏味道就是代码陷入了复杂度太高的境地，无法一眼看潜在的问题。对付复杂度最好的武器是简化代码</p>
</blockquote>
<blockquote>
<p>在遇到bug时，应该仔细浏览代码，设想各种出错的可能。而不是将错误代码运行起来，查看运行中的状态变化</p>
</blockquote>
<p>这段话中不赞成的解决问题方式，其实是很多开发人员普遍具备的。</p>
<p>作者在对编码也有相似的体会</p>
<blockquote>
<p>我发现，要精熟掌握每项技艺，关键都是要具备“信心”和“出错感知”能力。</p>
</blockquote>
<p>我想作者的“出错感知” 与 云风的“预感到坏味道” 是一样的</p>
<p>作者给了一套了编码规则与原则</p>
<ul>
<li><p>做好准备</p>
<ol>
<li>快速响应，做出第一版本</li>
<li>深入需求分析</li>
<li>插件式，低耦合</li>
<li>可读性，可维护性</li>
</ol>
<p><strong>当感到疲劳，焦虑的时候，千万不要写代码</strong></p>
</li>
<li><p>流态区</p>
<p><strong>避免进入流态区</strong></p>
</li>
</ul>
<blockquote>
<p>这种意识状态并非真的极为高效，也绝非毫无错误。这其实只是一种“浅层冥想”状态，在这种状态下，为了追求所谓的速度，理性思考的能力会下降</p>
</blockquote>
<p>其实这不是我第一次听到的建议，不要进入流态区，只是一种精神酸爽，对于实质工作没有意义，因为进入了这种状态会出现只见树木不见森林，当时流线性的写出代码，事后经常会发现偏离了方向，不得不重写。</p>
<ul>
<li><p>中断</p>
<p>作者给出了两种方法</p>
</li>
</ul>
<blockquote>
<ol>
<li>结对编程，让搭档维护住中断的上下文</li>
<li>TDD，失败的测试能帮你维护住编码进度的上下文</li>
</ol>
</blockquote>
<ul>
<li><p>阻塞</p>
<p>当情绪低落，焦虑，恐惧时，最好的方法：找一个搭档结对编程</p>
</li>
</ul>
<p>作者是一个TDD以及结对编程的提倡与践行人，在书可你可以看到很多次作者对这两种方法的推荐，可惜国内很少！</p>
<p>书中有两个章节与近期订阅的李笑来老师文章有重合</p>
<ol>
<li>练习</li>
</ol>
<blockquote>
<p>任何事情，只要想做得快，都离不开练习。<br>两个武者搏斗，每个人都必须能够迅速识别出对方的意图，并且百分之一秒内正确应对。在搏斗中，你不可能有充足的时间来研究架势，思考如何应对，这时候你只能依靠身体的反应。实际上，真正做出反应的是你的身体，大脑是在更高级的层面上思考</p>
</blockquote>
<p>也就是李笑来老师提的刻意练习，如果程序员不去刻意练习，写各种demo,那么我想水平永远是hello world的水平了</p>
<ol start="2">
<li>注意力<blockquote>
<p>注意力是稀缺的资源，它类似魔力点数，如果你用光了自己的注意力点数，必须花一个小时或更多的时间都不需要注意的事情，来补充它。</p>
</blockquote>
</li>
</ol>
<p> 这是时间管理时提到的，李笑来也讲，注意力是你最宝贵的财富</p>
<blockquote>
<p>时间在本质上不属于你，你只能试着与它做朋友，让它为你所用。你的注意力才是你所拥有最重要、最宝贵的资源。你可以自己作主，要把它放在“成长”上。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/15/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/15/">15</a><span class="page-number current">16</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">朱兴生</p>
  <div class="site-description" itemprop="description">彪悍的人生需要书写</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
        
          <span class="site-state-item-count">160</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">朱兴生</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
