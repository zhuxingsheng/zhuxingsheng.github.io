<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 8.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.zhuxingsheng.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="彪悍的人生需要书写">
<meta property="og:type" content="website">
<meta property="og:title" content="码农戏码">
<meta property="og:url" content="http://www.zhuxingsheng.com/blog/page/11/index.html">
<meta property="og:site_name" content="码农戏码">
<meta property="og:description" content="彪悍的人生需要书写">
<meta property="og:locale">
<meta property="article:author" content="朱兴生">
<meta property="article:tag" content="DDD,DDD分层,SOLID,DIP,DDD依赖,领域驱动开，binding,微服务，Istio,service mesh,dapr,架构,DDD ACL,motain源码,spring源码,游戏开发,源码分析,java互联网">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://www.zhuxingsheng.com/blog/page/11/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>码农戏码</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">码农戏码</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">新生代农民工的自我修养</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog" rel="section"><i class="home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives" rel="section"><i class="archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags" rel="section"><i class="tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about" rel="section"><i class="user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-在线工具">

    <a href="/tools" rel="section"><i class="gavel fa-fw"></i>在线工具</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://www.zhuxingsheng.com/blog/development-process-specification.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="朱兴生">
      <meta itemprop="description" content="彪悍的人生需要书写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码农戏码">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/development-process-specification.html" class="post-title-link" itemprop="url">开发流程规范</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-09-18 23:20:00" itemprop="dateCreated datePublished" datetime="2019-09-18T23:20:00+08:00">2019-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-07 21:29:17" itemprop="dateModified" datetime="2021-11-07T21:29:17+08:00">2021-11-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这是近期在公司做的一次分享，这几年的互联网开发，算比较幸运，团队一直践行完善这套规范，没有太多的阻碍，得益于公司整体氛围，以及团队对规范和写文档的不排斥，形成了良好的开发习惯</p>
<p>在这次分享后，发现好些大V也在谈规范，写文档，估计是前段时间阿里又发布了开发手册(华山版)，借鉴于一下，对一些细节做些补充，整理出来</p>
<h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p><img src="http://images.zhuxingsheng.com/201908192235_181.png"></p>
<p>这个流程整体分为三个大阶段：需求阶段，开发阶段，上线阶段</p>
<h3 id="需求阶段"><a href="#需求阶段" class="headerlink" title="需求阶段"></a>需求阶段</h3><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><p>这个阶段主要是产品主导，收集痛点，归集需求，制定目标，与架构师讨论架构方案，与安全评估业务安全性</p>
<p>这儿可根据需求大小，具体行事，比如有些需求涉及方比较多，可能需要多次分组开会，不管是可行性分析，还是讨论方案，不是一次就能完成的</p>
<h4 id="需求评审"><a href="#需求评审" class="headerlink" title="需求评审"></a>需求评审</h4><p>当产品已经确定好这些方面，开始输出PRD，与研发、测试一起评审需求</p>
<p>研发与测试需要理解需求，更要挑战需求；</p>
<p>挑战需求的目的不是砍需求，而是确认产品在需求分析阶段的工作完备程度，比如遗留数据处理，对当前系统的影响层面，是否与当前系统重复度过高，业务价值</p>
<p>只有经过充分讨论，才能理解需求，完善需求，防止后期需求返工，某个细节没有考虑，影响整体设计实现</p>
<p>这儿各个团队实践方式各不相同，比如有些是所有团队成员都要参与，而有些只有具体参与开发测试参与</p>
<p>个人推崇所有成员都参与，这样一是讨论可以更充分，二是信息共享，防止因某成员个人原因，推迟需求进度</p>
<h4 id="需求排期"><a href="#需求排期" class="headerlink" title="需求排期"></a>需求排期</h4><p>对需求大家都达成了共识，此时就需要产品去需求确定优先级，排期开发</p>
<p>确定开发周期，这儿也有很多具体做法，有些团队是TL根据需求难易程序，变动大小，结合具体开发人员直接给出时间；有些团队是具体开发自行评估时间</p>
<p>一般都是由开发人员自行评估，只要在合理范围内，都给予认同</p>
<p>当然在确定开发周期时，必须给出依据，依据来源于详细设计，对于详细设计文档具体形式后面再谈，至少开发人员知道需要增加多少接口，修改多少接口，大概逻辑；不然评估时长就是一个空谈，造成整个项目的失控</p>
<h3 id="开发阶段"><a href="#开发阶段" class="headerlink" title="开发阶段"></a>开发阶段</h3><p>需求阶段，从产品需求分析到开发人员评估出开发周期就已经结束了；下一个阶段进入开发阶段</p>
<p>开发阶段的进度，可以说八成是依赖第一阶段的成果。编码速度，实现手段只要是正常业务需求，一般都不会拖延时长</p>
<p>第一阶段成果，对于开发人员来讲，就是详细设计文档，文档中有了相应流程图，伪代码，具体涉及接口也有了，此时就是一个代码翻译过程</p>
<p>此阶段测试，需要输出测试用例，进行冒烟，回归测试；</p>
<p>自动化脚本完善</p>
<h3 id="上线阶段"><a href="#上线阶段" class="headerlink" title="上线阶段"></a>上线阶段</h3><p>测试完成之后，就准备上线了。</p>
<p>根据确定的上线日期，提前核对checklist</p>
<p>对一些需要提前的变更开始申请审批流程</p>
<p>配合监控系统，需要对一些业务监控项进行配置</p>
<p>产品开始对预发布环境进行验收，验收成功后；发布正式环境</p>
<h4 id="上线收尾"><a href="#上线收尾" class="headerlink" title="上线收尾"></a>上线收尾</h4><p>收尾工作，这个阶段，还有大量工作需要去做</p>
<ol>
<li>产品对需求进行总结，收集数据，分析效果，为下一期需求做准备</li>
<li>开发需要对代码进行整理，比如有些是为了灰度而生的无用代码可以删除</li>
</ol>
<hr>
<p>一个完整的需求开发流程到此结束，当然这只是理想状态，还有很多不可预测问题，当然你也会吐槽，这是典型的瀑布开发模型，在敏捷大行其道时，是不是太守旧，太迟钝，都2091年了，为什么还在玩这一套</p>
<p>理想是丰满的，现实是骨感的。好比敏捷开发的参与者是一群开发经验丰富和才华横溢的开发人员，而这样的团队有多少？强硬为了敏捷而敏捷会不会造成项目的不可控呢？</p>
<p>当然瀑布模型也有天生的缺点：每个阶段的严格性，缺乏灵活性，而现实需求却是经常变化的</p>
<p>所以单纯地选择哪个模型是不可取的，只能根据实际情况出发，为业务提供最大化服务</p>
<hr>
<h2 id="细则规范"><a href="#细则规范" class="headerlink" title="细则规范"></a>细则规范</h2><p>很多人都在要规范，但好像从没思考过为什么需要规范？</p>
<blockquote>
<p>《阿里巴巴java开发手册》：手册的愿景是码出高效，码出质量</p>
</blockquote>
<blockquote>
<p>现代软件架构的复杂性需要协同开发完成，如何高效地协同呢？无规矩不成方圆，无规范难以协同，比如，制订交通法规表面上是要限制行车权，实际上是保障公众的人身安全，试想如果没有限速，没有红绿灯，谁还敢上路行驶？对软件来说，适当的规范和标准绝不是消灭代码内容的创造性、优雅性，而是限制过度个性化，以一种普遍认可的统一方式一起做事，提升协作效率，降低沟通成本。 代码的字里行间流淌的是软件系统的血液，质量的提<br>升是尽可能少踩坑，杜绝踩重复的坑，切实提升系统稳定性，码出质量</p>
</blockquote>
<p>从上段可以看出几个目的</p>
<ol>
<li>高效协同，降低沟通成本；书同文，车同轨</li>
<li>码出质量，降低故障率；</li>
<li>工匠精神，追求卓越</li>
</ol>
<hr>
<h3 id="评审会议"><a href="#评审会议" class="headerlink" title="评审会议"></a>评审会议</h3><p>很多开发人员最怕开会，更要命的是很多会议是效率低下的。主要表现：</p>
<ul>
<li>在没有基本的认知共识就被拉去开会：这可能是主持者没有提前知会，同步资料；以及没有在线下达到一定共识就开会，结果会上各种讨论;也可能是参会人员本身也没有提前准备</li>
<li>会后没有结论，或者结论不明确</li>
</ul>
<p>所以在参与评审后，需要有一份输出，文档或者邮件，主要包括以下内容</p>
<ol>
<li>评审日期与轮次</li>
<li>业务需求的目的及价值描述</li>
<li>参与人员及角色</li>
<li>评审附件（PRD或邮件）</li>
<li>评审结论</li>
<li>评审遗留问题及跟进人</li>
</ol>
<h3 id="需求PRD"><a href="#需求PRD" class="headerlink" title="需求PRD"></a>需求PRD</h3><p>开发人员，最烦就是口头需求，一句话需求，需要明文禁止</p>
<p>产品写PRD，其实是个基本职业素养，结果现在还要明文规定，也算是个悲哀。</p>
<p>为什么要出PRD，其实不是开发人员故意为难产品，而是让产品深刻理解需求，看这又是个怪事，产品还有不理解业务需求的，但就是常有产品自己都不理解业务，还一本正经给研发提开发需求。</p>
<p>写PRD的过程，就是梳理思考的过程，让需求更明确，流程更完整，细节更透彻，这样就不会出现提交给开发时，被开发一堆问题阻塞住。也可以防止在开发过程中，却发现整个业务没有形成闭环，造成返工，延时</p>
<p>那么开发如何拒绝口头需求，一句话需求呢？</p>
<p>有时产品比较强势，开发人员不好沟通，此时TL就应该对团队明确规定，禁止产品此类行为，也要禁止开发接受此类需求，不能为了一时快，而整个工期慢</p>
<p>在接受到此类需求时，也需要一定的沟通技巧：</p>
<ol>
<li><p>多问几个为什么：这比如你这个需求背后的目的和价值是什么？做了之后有什么预期的收益，为什么这么做就可以达到这个收益，你可以不直接问业务方，但是你也需要问自己，业务方的这个目标和做这个需求的路径是否可以匹配得上，如果实现路径存在逻辑漏洞或者不是最佳的则这个需求也就没有做的必要性</p>
</li>
<li><p>给出替代方案：经过上面的步骤，其实你会发现你已经过滤了一批无效的一句话需求，而有些需求可能是有一定的存在价值，但是可能业务方提到的点并不是有效的方案或者说成本太大的方案，这时你就需要思考替代方案，尽量通过现有方案或者小成本的方式来满足业务方，间接的达到“拒绝”的效果</p>
</li>
<li><p>不能直接说不，但可以有条件的说是：当你确定这个需求是ok的，但你确实暂时抽不出时间来搞定这个事情的时候，这时关键在于我们不能直接拒绝业务方，长此以往会影响到后续的合作关系，这种情况你可以说，这个需求我接受，但是我可能需要较长一些的缓冲时间或者砍一些需求(部分满足)，又或者必须要按时上的话，不能保证项目的上线后的效果、质量等，让业务方来做部分的取舍</p>
</li>
</ol>
<h3 id="详细设计文档"><a href="#详细设计文档" class="headerlink" title="详细设计文档"></a>详细设计文档</h3><p>首先禁止没有文档，直接修改代码；这跟需求PRD类似，强迫开发人员思考需求，完善需求，胸中有丘壑，下笔自有神；不能在编码过程，边写边思考，不仅慢，还会漏洞百出</p>
<p>其实让团队写文档，也是个难事，推动很难，尤其管理者没有引起重视，就更难。这是个怪事，不喜欢写文档，却喜欢被返工，在开发过程因需求逻辑不完备而加班赶点，从上到下默认了这种怪事的正常化</p>
<p>为什么要写设计文档？</p>
<ul>
<li>对自己，让自己在动手写代码之前，帮助自己想得更清楚；</li>
<li>对项目，保证信息的一致性，保证项目的可控性，减少项目风险；</li>
<li>对团队，确保知识的沉淀与传承；</li>
</ul>
<p>项目涉及多少个子系统，每个子系统涉及多少个模块，模块间的依赖关系如何，彼此要提供多少个接口，每个接口的参数如何，接口实现过程中上下游交互如何，核心逻辑用什么技术方案实现…</p>
<p>难道相关技术人都一清二楚么？很多自信的技术大神，“以为”懂了，但却讲不明白，其实就是不懂。很多“讲得明白”，却“写不清楚”，其实就是没懂透。把一个项目，一个技术问题，按照逻辑，用文字来一遍，才表示真正的想清楚了</p>
<p>这也是现在流行的，一解释都懂，一问都不知，一讨论就吵架</p>
<hr>
<p>不再写过多为什么要写文档了，一个习惯的改变不可能一下子就改变，这需要一个过程，也需要自我大胆尝试</p>
<p>这儿给出一些实践，详细设计文档写些什么</p>
<p>其实一份详细设计文档，整体分为两个部分：功能需求与非功能需求</p>
<p>1、需求信息</p>
<p>这儿包括需求背景，业务价值，预计上线时间，架构设计wiki,产品及开发负责人，涉及到的服务，上下游服务</p>
<p>2、系统流程图</p>
<p>阐述整体设计思路，涉及算法时，还需要详细算法思路</p>
<p>包含上下游系统交互和数据流向，建议viso或者astash图，要保存原图文件以防后期维护修改</p>
<p>当然最好还要把设计思路背景说明一下，有多种方案时也罗列一下，因为系统现有状况，进度安排，历史数据等等原因，而选择了当前方案，这样自我分析完整，也免将来别人接手时可以追溯 </p>
<p>3、接口列表</p>
<p>这儿列出所有涉及到的接口列表</p>
<p>标明新增加或者修改，以及接口详细入参，返回值</p>
<p>一般会有api doc，或者类似swagger工具，接口变化时，也可以相应变化；如果没有，那只能在文档中详细输出</p>
<p>4、定时任务</p>
<p>有些任务不需要，有些任务可能有很多，需要指出任务功能，频率</p>
<p>5、存储变更</p>
<p>比如缓存，数据结构，过期时间，预计数据增长</p>
<p>DB表设计，表修改，索引信息，数据增长量；有新的业务场景，一定要请DBA帮忙评估索引或者其他信息</p>
<p>6、配置组件</p>
<p>配置：比如配置中心，增加修改配置项，常为了灰度增加一些开关之类</p>
<p>组件：第三方依赖jar，不管是公司自研，还是外部开源；关注新特性给系统带来的变化；这个对开发工作量很小，只需要修改版本号，但测试可能需要一些回归量，尤其常出现的包冲突，造成日志不能正常输出</p>
<p>7、非功能需求</p>
<p>接口在日常和大促时的调用量评估，是否有降级方案，灰度方案，能不能重试，需不需要压测，这些都是围绕服务治理做预案</p>
<p>这其实是个很大的模块，很多已经深入骨髓，变成常态，比如灰度，现在都是7*24小时在线服务的，前后版本的兼容必须考虑到</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当然这些并不是必须的，可以根据实际情况变通，有增有减；当然你也可能从不写文档，很多人喜欢看源码，而不看文档；其实这有些本末倒置，源码只是告诉你了how,而文档才解释了what,why</p>
<p>架构师是很多码农的追求，架构师如何设计系统，如何让开发人员去实施呢？当然是文档，总不能直接给代码吧</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://www.zhuxingsheng.com/blog/monitored-traceid.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="朱兴生">
      <meta itemprop="description" content="彪悍的人生需要书写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码农戏码">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/monitored-traceid.html" class="post-title-link" itemprop="url">监控之traceid</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-10 10:41:00" itemprop="dateCreated datePublished" datetime="2019-05-10T10:41:00+08:00">2019-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-07-23 11:55:01" itemprop="dateModified" datetime="2022-07-23T11:55:01+08:00">2022-07-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>监控之前只总结了一篇<a href="http://www.zhuxingsheng.com/blog/microservice-monitoring.html">《微服务-监控》</a>，比较宏观。其中很多细节没有过深关注到，主要还是没有实践过，更没有去深度思考，所以很多有意思的技术点都错过了，比如traceid的生成，传递</p>
<p>大牛圈总的大作<a href="https://www.jianshu.com/p/95d9f9f3fdc5">《微服务系统架构之分布式traceId追踪参考实现》</a>已经给出解决方案，但还是再主动总结一下</p>
<h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>为什么需要traceid，为了查看完整的调用链，一旦调用过程中出现问题，可以第一时间定位到问题现场</p>
<p>整个调用链是一棵树形结构，traceid的传递涉及到主干与支干，进程内与进程外</p>
<h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><p><strong>原则是唯一不重复</strong>，比如现成的UUID</p>
<p>但UUID一是丑、无意义，二是string；</p>
<p>从字面意义以及未来落盘都不能说是最佳方案，比如想让traceid包含信息更丰富一些，能一眼看出此traceid是主干还是分支</p>
<p>此traceid有没有最终落盘(这儿涉及到落盘抽样率，每天服务处理海量请求，总不能每个traceid都落盘)</p>
<h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h3><p>这儿引申到如何更好地获取一个随机数又是一个课题，另开篇吧</p>
<h2 id="传递"><a href="#传递" class="headerlink" title="传递"></a>传递</h2><p>在<a href="http://www.zhuxingsheng.com/blog/micro-service-fuse-mechanism.html">《熔断机制》</a>中提过，服务调用是一个1-&gt;N扇出，调用链展现出对应的树形结构，但调用嵌套都不会深，一般两层就差不多了</p>
<ul>
<li>traceId1<ul>
<li>traceId1.1<ul>
<li>traceId1.1.1</li>
</ul>
</li>
<li>traceId2.1</li>
<li>traceId3.1</li>
</ul>
</li>
</ul>
<h3 id="进程外"><a href="#进程外" class="headerlink" title="进程外"></a>进程外</h3><p>服务之间的传递</p>
<p>serverA –&gt; serverB – serverC</p>
<p>这儿在设计传输协议时，在协议头里面带上traceid</p>
<h3 id="进程内"><a href="#进程内" class="headerlink" title="进程内"></a>进程内</h3><h4 id="主干"><a href="#主干" class="headerlink" title="主干"></a>主干</h4><p>这种场景ThreadLocal是最佳手法</p>
<h4 id="支干"><a href="#支干" class="headerlink" title="支干"></a>支干</h4><p>比如serviceA – &gt; remote.serviceB</p>
<p>trace是个树形结构，可以将remote.serviceB的traceId.parentId &#x3D; serviceA.traceId</p>
<h4 id="异步子任务"><a href="#异步子任务" class="headerlink" title="异步子任务"></a>异步子任务</h4><p>子线程可以通过InheritableThreadLocal传递traceid</p>
<p>顺带一下，InheritableThreadLocal的详细实现，先可补习一下ThreadLocal《解析ThreadLocal》</p>
<p>在创建Thread时，会从父线程的inheritableThreadLocals复制到子线程中去，这样在子线程中就能拿到在父线程中的赋值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* ThreadLocal values pertaining to this thread. This map is maintained</span><br><span class="line"> * by the ThreadLocal class. */</span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = null;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * InheritableThreadLocal values pertaining to this thread. This map is</span><br><span class="line"> * maintained by the InheritableThreadLocal class.</span><br><span class="line"> */</span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (parent.inheritableThreadLocals != null)</span><br><span class="line">        this.inheritableThreadLocals =</span><br><span class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br></pre></td></tr></table></figure>

<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>如果没有线程池，以上就算是解决所有问题了，可实现毕竟是实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 子线程从父线程中取值</span><br><span class="line"> * @throws InterruptedException</span><br><span class="line"> */</span><br><span class="line">private static void testThreadpool() throws InterruptedException &#123;</span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(1);</span><br><span class="line">    final ThreadLocal&lt;String&gt;  threadLocal = threadLocal();//new InheritableThreadLocal&lt;&gt;()</span><br><span class="line">    threadLocal.set(&quot;parent&quot;);</span><br><span class="line">    for(int i=0;i&lt;1;i++) &#123;</span><br><span class="line">        Runnable runnable = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +&quot; get parent value:&quot; + threadLocal.get());</span><br><span class="line">                threadLocal.set(&quot;sun&quot;);</span><br><span class="line">                System.out.println(Thread.currentThread().getId() + &quot;==&quot; + threadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        executorService.execute(runnable);</span><br><span class="line">        Thread.sleep(100);</span><br><span class="line">        executorService.execute(runnable);</span><br><span class="line">        Thread.sleep(100);</span><br><span class="line">        System.out.println(&quot;main:&quot; + threadLocal.get());</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了好重现问题，线程池大小为1，但会连续跑两次任务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1 get parent value:parent</span><br><span class="line">11==sun</span><br><span class="line">pool-1-thread-1 get parent value:sun</span><br><span class="line">11==sun</span><br><span class="line">main:parent</span><br></pre></td></tr></table></figure>
<p>在第二次取父线程值时，却是第一次任务线程中的赋值，在线程池中子线程不能正常获取父线程值</p>
<p>线程池中，线程会复用，线程中的inheritableThreadLocals没有被清空</p>
<p><strong>解决方法一是：池中线程数大于任务线程，让线程没有重用机会</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newFixedThreadPool(&gt;=[任务线程数])</span><br></pre></td></tr></table></figure>
<p>但在多线程应用中，明显不能解决问题，任务数肯定远远超过线程数</p>
<p><strong>解决方法二是：自定义实现在使用完线程主动清空inheritableThreadLocals</strong></p>
<p>阿里开源transmittable-thread-local就实现这样的功能</p>
<p>整体思路也是从主线程复制，使用，再清理</p>
<blockquote>
<p>TtlRunnable 构造方法中，调用了 TransmittableThreadLocal.Transmitter.capture() 获取当前线程中所有的上下文，并储存在 AtomicReference 中</p>
</blockquote>
<blockquote>
<p>当线程执行时，调用 TtlRunnable run 方法，TtlRunnable 会从 AtomicReference 中获取出调用线程中所有的上下文，并把上下文给 TransmittableThreadLocal.Transmitter.replay 方法把上下文复制到当前线程。并把上下文备份</p>
</blockquote>
<blockquote>
<p>当线程执行完，调用 TransmittableThreadLocal.Transmitter.restore 并把备份的上下文传入，恢复备份的上下文，把后面新增的上下文删除，并重新把上下文复制到当前线程</p>
</blockquote>
<p>transmittable-thread-local代码不多，但有很多亮点，可以自行膜拜</p>
<p>在此场景，transmittable-thread-local还是太重了，其实可以简单借鉴一下transmittable-thread-local的思路，自定义Runnable</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public TransRunnable(Runnable runnable)&#123;</span><br><span class="line">    this.runnable = runnable;</span><br><span class="line">    //在创建时，获取父traceId</span><br><span class="line">    this.parentId = TranceContext.getParentTrace();</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    //</span><br><span class="line">    String old = TranceContext.getParentTrace();</span><br><span class="line">    //设置父traceid</span><br><span class="line">    TranceContext.setParentTrace(parentId);</span><br><span class="line">    runnable.run();</span><br><span class="line">    //还原</span><br><span class="line">    TranceContext.setParentTrace(old);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在创建子线程时，把父traceId带进去，就能在子线程业务方法中拿到父traceId,这样整个调用链也不会断</p>
<h3 id="schedule"><a href="#schedule" class="headerlink" title="schedule"></a>schedule</h3><p>traceid生成，有主动请求时，会生成，但如果是个系统的定时任务呢？</p>
<ol>
<li>让taskService调用一下入口，类似模拟用户行为</li>
<li>主动生成一个parent traceId</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到此，对于traceid的知识结构丰满了很多</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://www.zhuxingsheng.com/blog/a-copy-of-jvm-parameters.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="朱兴生">
      <meta itemprop="description" content="彪悍的人生需要书写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码农戏码">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/a-copy-of-jvm-parameters.html" class="post-title-link" itemprop="url">一份JVM参数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-04-25 11:41:00" itemprop="dateCreated datePublished" datetime="2019-04-25T11:41:00+08:00">2019-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-12-07 23:02:19" itemprop="dateModified" datetime="2021-12-07T23:02:19+08:00">2021-12-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>想写个一份百万QPS系统的JVM参数，感觉太标题党了，虽然这的确是，但还是朴实点；</p>
<p>JVM参数调优是性能重器，安全第一，不可乱用，更不能因为网上推荐文章(此篇)而随便用</p>
<p>之前关于JVM的几篇文章<a href="http://www.zhuxingsheng.com/blog/does-active-gc-need.html">《是否需要主动GC》</a>、<a href="http://www.zhuxingsheng.com/blog/the-way-of-jit-optimization.html">《JIT优化》</a>、<a href="http://www.zhuxingsheng.com/blog/gc-and-jvm-parameters.html">《GC及JVM参数》</a>；</p>
<p>这些都涉及到JVM参数,然道理懂不少，还是配置不好参数；调优的确是个费劲的事。这儿直接给一份参数，可以直接拿来主义，当然也有些参数需要配合硬件及应用环境，斟酌使用，一切以实战为准</p>
<p>其实有很多现成的，如<a href="https://github.com/elastic/elasticsearch/blob/master/distribution/src/config/jvm.options">elasticsearch</a>、<a href="https://github.com/apache/cassandra/tree/trunk/conf">cassandra</a>、<a href="https://github.com/vipshop/vjtools/blob/master/vjstar/src/main/script/jvm-options/jvm-options.sh">VIP</a></p>
<p>jvm参数总体分两种：标准参数(以-开始)与非标准参数;</p>
<p>非标准参数又分了两种：不太标准(以-X开始)与特别不标准(以-XX开始)</p>
<p>参数列表就标准到非标准一一进行说明</p>
<h2 id="标准参数"><a href="#标准参数" class="headerlink" title="标准参数"></a>标准参数</h2><p>顾名思义，标准参数中包括功能和输出的参数都是很稳定的，很可能在将来的JVM版本中不会改变。你可以用java命令（或者是用 java -help）检索出所有标准参数</p>
<p><strong>-server</strong></p>
<p>这个参数涉及分层编译策略，简单讲，就是把更多的代码更早地编译成本地代码</p>
<p><strong>-D</strong></p>
<p>应用附加配置参数，通过System.getProperty读取</p>
<p>-Djava.security.egd&#x3D;file:&#x2F;dev&#x2F;.&#x2F;urandom </p>
<p>-Djava.net.preferIPv4Stack&#x3D;true </p>
<p>-Djava.awt.headless&#x3D;true </p>
<p>-Dspring.profiles.active&#x3D;dev</p>
<h2 id="非标准参数"><a href="#非标准参数" class="headerlink" title="非标准参数"></a>非标准参数</h2><p>非标准化的参数在将来的版本中可能会改变</p>
<p>在实际情况中X参数和XX参数并没有什么不同。X参数的功能是十分稳定的，然而很多XX参数仍在实验当中（主要是JVM的开发者用于debugging和调优JVM自身的实现）</p>
<h3 id="X参数"><a href="#X参数" class="headerlink" title="X参数"></a>X参数</h3><p><strong>-Xms2048m</strong></p>
<p><strong>-Xmx2048m</strong></p>
<p><strong>-Xmn2048m</strong></p>
<p><strong>-Xss512K</strong></p>
<p>这几个老面孔，设置堆大小</p>
<p>Xms和Xmx设置一样，可以减轻伸缩堆大小带来的压力;Xmn新年代大小</p>
<p>Xss规定了每个线程堆栈的大小。一般情况下256K是足够了； 如果线程数较多，函数的递归较少，线程栈内存可以调小节约内存，默认1M</p>
<p><strong>-Xloggc</strong></p>
<p>-Xloggc:&#x2F;dev&#x2F;shm&#x2F;gc.log</p>
<p>有人担心写GC日志会影响性能，但测试下来实在没什么影响，GC问题是Java里最常见的问题，没日志怎么行。</p>
<p>后来又发现如果遇上高IO的情况，GC时操作系统正在flush pageCache 到磁盘，也可能导致GC log文件被锁住，从而让GC结束不了。所以把它指向了&#x2F;dev&#x2F;shm 这种内存中文件系统，避免这种停顿，详见<a href="https://note.youdao.com/">Eliminating Large JVM GC Pauses Caused by Background IO Traffic</a></p>
<hr>
<h3 id="XX参数"><a href="#XX参数" class="headerlink" title="XX参数"></a>XX参数</h3><p>XX参数 虽然是最不稳定参数，但使用的最多，好神奇，很多特殊的性能调优都需要用到</p>
<ul>
<li>对于布尔类型的参数，我们有”+”或”-“，然后才设置JVM选项的实际名称。例如，-XX:+用于激活选项，而-XX:-用于注销选项</li>
<li>对于需要非布尔值的参数，如string或者integer，我们先写参数的名称，后面加上”&#x3D;”，最后赋值。例如， -XX:&#x3D;给赋值</li>
</ul>
<p>在使用此类参数时，可以使用两个命令先确认一下JVM默认值，防止JVM变动，最好还是明确设置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintFlagsInitial表示打印出所有XX选项的默认值</span><br><span class="line">-XX:+PrintFlagsFinal表示打印出XX选项在运行程序时生效的值</span><br></pre></td></tr></table></figure>

<p>这些参数从功能大体分类一下</p>
<ol>
<li>空间大小，类似-X参数，但这些空间各个JVM可能不同实现，如PermSize</li>
<li>监控类，帮助确定问题Trouble shooting Options</li>
<li>优化类，调优性能</li>
<li>GC策略类</li>
</ol>
<h4 id="内存类"><a href="#内存类" class="headerlink" title="内存类"></a>内存类</h4><p><strong>-XX:PermSize&#x3D;512m -XX:MaxPermSize&#x3D;512m</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize=200m; support was removed in 8.0</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=256m; support was removed in 8.0</span><br></pre></td></tr></table></figure>
<p>在JDK8之后，永久代向元空间的转换，配置项变成了</p>
<p><strong>-XX:MetaspaceSize&#x3D;200m -XX:MaxMetaspaceSize&#x3D;256m</strong></p>
<p>为什么需要这样转换？</p>
<blockquote>
<p>1、字符串存在永久代中，容易出现性能问题和内存溢出。<br>2、类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。<br>3、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。<br>4、Oracle 可能会将HotSpot 与 JRockit 合二为一。</p>
</blockquote>
<p><strong>-XX:MaxDirectMemorySize&#x3D;2048m</strong></p>
<p>堆外内存的最大值，默认为Heap区总内存减去一个Survivor区的大小；像使用netty之类框架，用得多些。</p>
<p>在DirectByteBuffer中，首先向Bits类申请额度，Bits类有一个全局的 totalCapacity变量，记录着全部DirectByteBuffer的总大小，每次申请，都先看看是否超限 – 堆外内存的限额默认与堆内内存(由-XMX 设定)相仿，可用 -XX:MaxDirectMemorySize 重新设定。</p>
<p>如果已经超限，会主动执行Sytem.gc()，期待能主动回收一点堆外内存。然后休眠一百毫秒，看看totalCapacity降下来没有，如果内存还是不足，就抛出大家最头痛的OOM异常；详细可见《堆外内存》</p>
<p><strong>-XX:ReservedCodeCacheSize&#x3D;240M</strong></p>
<p>JIT编译后二进制代码的存放区，满了之后就不再编译，对性能影响很大。JDK7默认不开多层编译48M，开了96M，而JDK8默认开多层编译240M。可以在JMX里看看CodeCache的大小，JDK7下的48M一般够了，也可以把它设大点，反正内存多</p>
<p><strong>-XX:NewRatio&#x3D;1</strong></p>
<p>这个参数，与-Xmn or (-XX:NewSize and -XX:MaxNewSize) or -XX:NewRatio并列，都是设置年轻代大小。默认值为2, 也就是新生代占堆大小的1&#x2F;3， 个人喜欢把对半分， 增大新生代的大小，能减少GC的频率（但也会加大每次GC的停顿时间），主要是看老生代里没多少长期对象的话，占2&#x2F;3太多了。可以用-Xmn 直接赋值(等于-XX:NewSize and -XX:MaxNewSize同值的缩写)，或把NewRatio设为1来对半分(但如果想设置新生代比老生代大就只能用-Xmn)</p>
<p>参数中带Ratio的还有一个-XX:SurvivorRatio，从字面意思看好像是新年代占比、survivor占比。<strong>其实是反的</strong>。</p>
<p><strong>-XX:NewRatio&#x3D;4表示年老代与年轻代的比值为4:1</strong></p>
<p><strong>-XX:SurvivorRatio&#x3D;8表示Eden区与Survivor区的大小比值是8:1:1</strong>, 因为Survivor区有两个</p>
<h4 id="监控类"><a href="#监控类" class="headerlink" title="监控类"></a>监控类</h4><p><strong>-XX:+PrintCommandLineFlags</strong></p>
<p>让JVM打印出那些已经被用户或者JVM设置过的详细的XX参数的名称和值，还会打印出以及因为这些参数隐式影响的参数</p>
<p>打印出来，需要核实线上运行状态时，有据可查</p>
<p><strong>-XX:-OmitStackTraceInFastThrow</strong></p>
<p>有时查线上问题时，看到有异常信息，但只有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">java.lang.NullPointerException</span><br><span class="line">java.lang.NullPointerException</span><br><span class="line">java.lang.NullPointerException</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>具体的异常栈没了，有时异常监控不位，人工发现这些异常时，却看不出哪里的问题，很是恼火</p>
<p>JVM对一些特定的异常类型做了Fast Throw优化，如果检测到在代码里某个位置连续多次抛出同一类型异常的话，C2会决定用Fast Throw方式来抛出异常，而异常Trace即详细的异常栈信息会被清空。这种异常抛出速度非常快，因为不需要在堆里分配内存，也不需要构造完整的异常栈信息</p>
<p>特定异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NullPointerException</span><br><span class="line">ArithmeticException</span><br><span class="line">ArrayIndexOutOfBoundsException</span><br><span class="line">ArrayStoreException</span><br><span class="line">ClassCastException</span><br></pre></td></tr></table></figure>

<p><strong>-XX:+PrintGCCause</strong></p>
<p>打印产生GC的原因，比如AllocationFailure什么的，在JDK8已默认打开，JDK7要显式打开一下</p>
<p><strong>-XX:+PrintGCApplicationStoppedTime</strong></p>
<p>这是个非常非常重要的参数，但它的名字没起好，其实除了打印清晰的完整的GC停顿时间外，还可以打印其他的JVM停顿时间，比如取消偏向锁，class 被agent redefine，code deoptimization等等，有助于发现一些原来没想到的问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-10-18T03:27:39.204+0800: 33729.026: Total time for which application threads were stopped: 0.0059280 seconds, Stopping threads took: 0.0001000 seconds</span><br></pre></td></tr></table></figure>

<p><strong>-XX:+PrintGCDateStamps</strong></p>
<p>输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）</p>
<p>用PrintGCDateStamps而不是PrintGCTimeStamps，打印可读的日期而不是时间戳</p>
<p><strong>-XX:+PrintGCDetails</strong></p>
<p>输出GC的详细日志</p>
<p><strong>-XX:ErrorFile</strong></p>
<p>-XX:ErrorFile&#x3D;${MYLOGDIR}&#x2F;jvmerr_%p.log</p>
<p>JVM crash时，hotspot 会生成一个error文件，提供JVM状态信息的细节。如前所述，将其输出到固定目录，避免到时会到处找这文件。文件名中的%p会被自动替换为应用的PID</p>
<p><strong>-XX:+HeapDumpOnOutOfMemoryError</strong></p>
<p>两个配合使用 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;${LOGDIR}&#x2F;</p>
<p>在Out Of Memory，JVM快死掉的时候，输出Heap Dump到指定文件。不然开发很多时候还真不知道怎么重现错误。</p>
<p>路径只指向目录，JVM会保持文件名的唯一性，叫java_pid${pid}.hprof。因为如果指向文件，而文件已存在，反而不能写入。</p>
<p>但在容器环境下，输出4G的HeapDump，在普通硬盘上会造成20秒以上的硬盘IO跑满，也是个十足的恶邻，影响了同一宿主机上所有其他的容器</p>
<hr>
<h4 id="优化类"><a href="#优化类" class="headerlink" title="优化类"></a>优化类</h4><p><strong>-XX:AutoBoxCacheMax</strong></p>
<p>-XX:AutoBoxCacheMax&#x3D;20000</p>
<p>这个参数的意义是缓存自动装箱最大值</p>
<blockquote>
<p>设为20000后，我们应用的QPS有足足4%的影响</p>
</blockquote>
<p>看代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer i = 129;</span><br><span class="line">Integer j = 129;</span><br><span class="line"></span><br><span class="line">i == j //true or false ?</span><br></pre></td></tr></table></figure>
<p>JDK默认只缓存 -128 ~ +127的Integer 和 Long，超出范围的数字就要即时构建新的Integer对象;</p>
<p>如果这儿配置了最大值20000，那就是[-128,20000]都不再创建新对象，但有点奇怪的时，你不能认为AutoBoxCacheMax的默认值是127</p>
<p>为什么配置值是20000呢，就得说到-XX:+AggressiveOpts参数，这是是一些还没默认打开的优化参数集合, -XX:AutoBoxCacheMax是其中的一项。但这个参数在关键系统里不建议打开</p>
<blockquote>
<p>There’s a JVM option -XX:+AggressiveOpts that supposedly makes your JVM faster. Lots of people turn this on in Eclipse to try to make it faster. But it makes your JVM less correct. Today I found it to be the cause of a longstanding bug in dx.<br><a href="http://code.google.com/p/android/issues/detail?id=5817">http://code.google.com/p/android/issues/detail?id=5817</a></p>
</blockquote>
<blockquote>
<p>-XX:+AggressiveOpts was deprecated in JDK 11 and should be removed in JDK 12</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-     bool AggressiveOpts                           := false           &#123;product&#125;</span><br><span class="line">+     bool AggressiveOpts                           := true            &#123;product&#125;</span><br><span class="line"></span><br><span class="line">-     intx AutoBoxCacheMax                           = 128             &#123;C2 product&#125;</span><br><span class="line">+     intx AutoBoxCacheMax                           = 20000           &#123;C2 product&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的打印设置配置值的参数，可以看出此项默认值是128,在打开AggressiveOpts参数时，是20000</p>
<p><strong>-XX:-UseCounterDecay</strong></p>
<p>禁止JIT调用计数器衰减。默认情况下，每次GC时会对调用计数器进行砍半的操作，导致有些方法一直温热，<br>永远都达不到触发C2编译的1万次（server默认值）的阀值，详细可参考《JIT优化》</p>
<p><strong>-XX:-UseBiasedLocking</strong></p>
<p>JDK1.6开始默认打开的偏向锁，会尝试把锁赋给第一个访问它的线程，取消同步块上的synchronized原语</p>
<p>如果始终只有一条线程在访问它，就成功略过同步操作以获得性能提升</p>
<p>为什么会有偏向锁出现？因为经验表明，其实大部分情况下，都会是同一个线程进入同一块同步代码块</p>
<p>但线上应用基本都是使用多线程，一旦出现锁竞争，就会锁膨胀，GC日志中有不少RevokeBiasd的纪录，像GC一样Stop The World的干活，虽然只是很短的停顿，但对于多线程并发的应用，取消掉它反而有性能的提升</p>
<p><strong>-XX:+PerfDisableSharedMem</strong></p>
<p>JVM经常会默默的在&#x2F;tmp&#x2F;hperf目录写上一点statistics数据，如果刚好遇到PageCache刷盘，把文件阻塞了，就不能结束这个Stop the World的安全点</p>
<p>禁止JVM写statistics数据的代价，是jps和jstat用不了；详细可看jstat的具体实现</p>
<p><strong>-XX:MaxTenuringThreshold&#x3D;4</strong></p>
<p>这是改动效果最明显的一个参数了。对象在Survivor区最多熬过多少次Young GC后晋升到年老代，JDK8里默认是15</p>
<p>Young GC是最大的应用停顿来源，而新生代里GC后存活对象的多少又直接影响停顿的时间，所以如果清楚Young GC的执行频率和应用里大部分临时对象的最长生命周期，可以把它设的更短一点，让其实不是临时对象的新生代对象赶紧晋升到年老代，别呆着。</p>
<p>用-XX:+PrintTenuringDistribution观察下，如果后面几代的大小总是差不多，证明过了某个年龄后的对象总能晋升到老生代，就可以把晋升阈值设小，比如JMeter里2就足够了</p>
<p><strong>-XX:+UnlockDiagnosticVMOptions -XX: ParGCCardsPerStrideChunk&#x3D;1024</strong></p>
<blockquote>
<p>Linkined的黑科技， 上一个版本的文章不建议打开，后来发现有些场景的确能减少YGC时间，详见<a href="https://toutiao.io/posts/hltb1e/preview/">《难道这些 Java 大牛说的都是真的？》</a>，简单说就是影响YGC时扫描老生代的时间，默认值256太小了，但32K也未必对，需要自己试验</p>
</blockquote>
<p><strong>-XX:+ExplicitGCInvokesConcurrent</strong></p>
<p>full gc时，使用CMS算法，不是全程停顿，必选</p>
<p><strong>-XX:+AlwaysPreTouch</strong></p>
<p>启动时访问并置零内存页面；启动时就把参数里说好了的内存全部舔一遍，可能令得启动时慢上一点，但后面访问时会更流畅，比如页面会连续分配，比如不会在晋升新生代到老生代时才去访问页面使得GC停顿时间加长。ElasticSearch和Cassandra都打开了它</p>
<hr>
<h4 id="GC策略"><a href="#GC策略" class="headerlink" title="GC策略"></a>GC策略</h4><p>配置-server时默认使用ParallelScavenge系的GC,是个吞吐量优先的收集器</p>
<p>虽然现在有了G1 GC,甚至JDK11后的ZGC,但在大型互联网项目上估计CMS还是主流</p>
<p>CMS三个基本配置</p>
<p><strong>-XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction&#x3D;75 -XX:+UseCMSInitiatingOccupancyOnly</strong></p>
<blockquote>
<p>因为我们的监控系统会通过JMX监控内存达到90%的状况（留点处理的时间），所以设置让它75%就开始跑了，早点开始也能避免Full GC等意外情况(概念重申，这种主动的CMS GC，和JVM的老生代、永久代、堆外内存完全不能分配内存了而强制Full GC是不同的概念)。为了让这个设置生效，还要设置-XX:+UseCMSInitiatingOccupancyOnly，否则75只被用来做开始的参考值，后面还是JVM自己算</p>
</blockquote>
<p><strong>-XX:+ParallelRefProcEnabled -XX:+CMSParallelInitialMarkEnabled</strong></p>
<p>并行的处理Reference对象，如WeakReference，默认为false，除非在GC log里出现Reference处理时间较长的日志，否则效果不会很明显，但我们总是要JVM尽量的并行，所以设了也就设了。同理还有-XX:+CMSParallelInitialMarkEnabled，JDK8已默认开启，但小版本比较低的JDK7甚至不支持</p>
<h2 id="建议参数"><a href="#建议参数" class="headerlink" title="建议参数"></a>建议参数</h2><p><strong>-XX:ParallelGCThreads&#x3D;? -XX:ConcGCThreads&#x3D;?</strong></p>
<p>-XX:ParallelGCThreads&#x3D;n	GC在并行处理阶段多少个线程，默认值和平台有关。（译者注：和程序一起跑的时候，使用多少个线程)</p>
<p>-XX:ConcGCThreads&#x3D;n	并发收集的时候使用多少个线程，默认值和平台有关。（译者注:stop-the-world的时候，并发处理的时候使用多少个线程)</p>
<p>ParallelGCThreads＝Processor &lt; 8 ? 8 : 8 +( Processor - 8 ) ( 5&#x2F;8 )；</p>
<p>ConcGCThreads &#x3D; (ParallelGCThreads + 3)&#x2F;4</p>
<p>24个处理器，小于8个处理器时ParallelGCThreads按处理器数量，大于时按上述公式YGC线程数＝18， CMS GC线程数＝5。</p>
<p>CMS GC线程数的公式太怪，也有人提议简单改为YGC线程数的1&#x2F;2。</p>
<p>一些不在乎停顿时间的后台辅助程序，比如日志收集的logstash，建议把它减少到2，避免在GC时突然占用太多CPU核，影响主应用。</p>
<p>而另一些并不独占服务器的应用，比如旁边跑着一堆sidecar的，也建议减少YGC线程数。</p>
<p>一个真实的案例，24核的服务器，默认18条YGC线程，但因为旁边有个繁忙的Service Mesh Proxy在跑着，这18条线程并不能100%的抢到CPU，出现了不合理的慢GC。把线程数降低到12条之后，YGC反而快了很多。 所以那些贪心的把YGC线程数＝CPU 核数的，通常弄巧成拙。</p>
<p><strong>不要-XX:+DisableExplicitGC</strong></p>
<p>像R大说的，System GC是保护机制（如堆外内存满时清理它的堆内引用对象），禁了system.gc() 未必是好事，只要没用什么特别烂的类库，真有人调了总有调的原因，所以不应该加这个烂大街的参数。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://calvin1978.blogcn.com/articles/jvmoption-7.html">关键业务系统的JVM参数推荐</a></p>
<p><a href="https://yq.aliyun.com/articles/62538">JVM源码分析之Jstat工具原理完全解读</a></p>
<p><a href="https://toutiao.io/posts/hltb1e/preview/">《难道这些 Java 大牛说的都是真的？》</a></p>
<p><a href="http://calvin1978.blogcn.com/articles/securerandom.html">SecureRandom的江湖偏方与真实效果</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://www.zhuxingsheng.com/blog/zookeeper-knowledge-structure-3-distributed-lock.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="朱兴生">
      <meta itemprop="description" content="彪悍的人生需要书写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码农戏码">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/zookeeper-knowledge-structure-3-distributed-lock.html" class="post-title-link" itemprop="url">zookeeper知识结构3-分布式锁</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-04-21 11:41:00" itemprop="dateCreated datePublished" datetime="2019-04-21T11:41:00+08:00">2019-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-12-07 22:59:50" itemprop="dateModified" datetime="2021-12-07T22:59:50+08:00">2021-12-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>zk相关文章已经有了三篇<br><a href="http://www.zhuxingsheng.com/blog/zookeeper-paxos.html">《zookeeper-paxos》</a>、<br><a href="http://www.zhuxingsheng.com/blog/zookeeper-knowledge-structure.html">《zookeeper知识结构》</a>、<br><a href="http://www.zhuxingsheng.com/blog/zookeeper-knowledge-structure-2-zab-protocol.html">《zookeeper知识结构2-zab协议》</a></p>
<p>但都没有到具体到应用，此篇弥补一下</p>
<blockquote>
<p>talk is cheap,show me the code</p>
</blockquote>
<h1 id="client"><a href="#client" class="headerlink" title="client"></a>client</h1><p>如何使用zk</p>
<p>除了zk提供原生客户端，还有能过编程方式</p>
<h2 id="zkcli"><a href="#zkcli" class="headerlink" title="zkcli"></a>zkcli</h2><p><strong>zkcli原生操作指令比较简单</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">zkcli    连接默认zookeeper服务器</span><br><span class="line"></span><br><span class="line">zkcli -server ip:port    连接指定的zookeeper服务器</span><br><span class="line"></span><br><span class="line">create -s -e path data [acl]    创建节点，-s表示顺序，-e表示临时，默认是持久节点，acl缺省表示不做任何权限限制</span><br><span class="line"></span><br><span class="line">ls path [watch]    显示path下的节点，不递归显示,watch注册监听，命令行可忽视</span><br><span class="line"></span><br><span class="line">ls2 path    显示当前节点下的节点和当前节点的属性信息</span><br><span class="line"></span><br><span class="line">get path [watch]    获取path的属性信息和数据内容</span><br><span class="line"></span><br><span class="line">set path data [version]    更新path的数据内容，version是做类似cas的功能的对应dataversion，命令行可忽略</span><br><span class="line"></span><br><span class="line">delete path [version]    删除节点，不能递归删除，只能删除叶子节点</span><br><span class="line"></span><br><span class="line">setacl path acl    设置节点acl,例子(scheme:id:password=:perm)-(digest:example:sha-1(base64(pwd))=:cdrwa) create delete read write admin</span><br><span class="line"></span><br><span class="line">getacl path    获取path节点的acl</span><br><span class="line"></span><br><span class="line">stat path    查看path的属性信息</span><br><span class="line"></span><br><span class="line">quit 退出zkcli</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="ZkClient-VS-Curator"><a href="#ZkClient-VS-Curator" class="headerlink" title="ZkClient VS Curator"></a>ZkClient VS Curator</h2><p>这两个常用的开源组件</p>
<p>相对zkclient,Curator已经成为Apache的顶级项目,不仅解决了非常底层的细节开发工作，包括连接重连、反复注册Watcher和NodeExistsException异常等,还提供了Zookeeper各种应用场景（Recipe，如共享锁服务、Master选举机制和分布式计算器等）的抽象封装</p>
<p>所以推荐使用curator</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>主要介绍两种常见情景，一是分布式锁，二是master选举</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>为什么zk能实现分布式锁？</p>
<p>像redis原理是通过全局key是否存，而zk则是通过其特定的数据结构来实现：<strong>利用节点名称的唯一性</strong></p>
<blockquote>
<p>ZooKeeper抽象出来的节点结构是一个和unix文件系统类似的小型的树状的目录结构。ZooKeeper机制规定：同一个目录下只能有一个唯一的文件名。例如：我们在Zookeeper目录&#x2F;jjk目录下创建，两个客户端创建一个名为Lock节点，只有一个能够成功</p>
</blockquote>
<h3 id="思路一：持久节点"><a href="#思路一：持久节点" class="headerlink" title="思路一：持久节点"></a>思路一：持久节点</h3><p>利用名称唯一性，加锁操作时，只需要所有客户端一起创建&#x2F;lock节点，只有一个创建成功，成功者获得锁。解锁时，只需删除&#x2F;lock节点，其余客户端再次进入竞争创建节点，直到所有客户端都获得锁</p>
<h4 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h4><p><strong>尝试加锁</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 尝试加锁,直接创建节点，如果节点创建失败，说明加锁失败</span><br><span class="line"> * @param lockName</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public boolean tryLock(String lockName) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //创建节点</span><br><span class="line">        String path = cf.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(getLockPath(lockName), lockName.getBytes());</span><br><span class="line">       logger.info(Thread.currentThread().getName()+ &quot;try lock  success ,path:&quot;+path+&quot; tid:&quot;+Thread.currentThread().getName());</span><br><span class="line">        return true;</span><br><span class="line">    &#125;catch (KeeperException.NodeExistsException e) &#123;</span><br><span class="line">       logger.info(&quot;try lock fail,&quot;+&quot; tid:&quot;+Thread.currentThread().getName());</span><br><span class="line">    &#125;catch (Exception ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>尝试加锁失败后，阻塞等待</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 尝试加锁失败后，阻塞等待</span><br><span class="line"> * @param lockName</span><br><span class="line"> * @throws Exception</span><br><span class="line"> */</span><br><span class="line">public void waitForLock(String lockName) throws Exception &#123;</span><br><span class="line">    //监听子节点</span><br><span class="line">    PathChildrenCache pathChildrenCache = new PathChildrenCache(cf, LOCK_PATH, false);</span><br><span class="line">    pathChildrenCache.start(PathChildrenCache.StartMode.BUILD_INITIAL_CACHE);</span><br><span class="line">    pathChildrenCache.getListenable().addListener(new PathChildrenCacheListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception &#123;</span><br><span class="line">            switch (event.getType()) &#123;</span><br><span class="line">                case CHILD_REMOVED:</span><br><span class="line">                    logger.info(&quot;path:&quot; + event.getData().getPath() + &quot; has removed,start to lock:&#123;&#125;&quot;,Thread.currentThread().getName());</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    //logger.info(&quot; has changeed,&#123;&#125;,start to lock:&#123;&#125;&quot;,event.getType(),Thread.currentThread().getName());</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    boolean hasLock = false;</span><br><span class="line">    while(!hasLock) &#123;</span><br><span class="line">        Stat stat = cf.checkExists().forPath(getLockPath(lockName));</span><br><span class="line">        //节点存在,此处与unlock非原子操作，如果在checkExists返回true时刻，成功unlock,那此端无限等待</span><br><span class="line">        if (stat == null) &#123;</span><br><span class="line">            logger.info(&quot;waitForLock not exists:&#123;&#125;&quot;, Thread.currentThread().getName());</span><br><span class="line">           hasLock = tryLock(lockName);</span><br><span class="line"></span><br><span class="line">           if(hasLock) &#123;</span><br><span class="line">               logger.info(&quot;waitForLock get lock :&#123;&#125;&quot;, Thread.currentThread().getName());</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            logger.info(&quot;waitForLock exists:&#123;&#125;&quot;, Thread.currentThread().getName());</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解锁</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public boolean unlock(String lockName) throws Exception &#123;</span><br><span class="line">        logger.info(&quot;start unlock:&quot; + lockName + &quot; tid:&quot; + Thread.currentThread().getName());</span><br><span class="line">        cf.delete().forPath(getLockPath(lockName));</span><br><span class="line">        logger.info(&quot;end unlock:&quot; + lockName + &quot; tid:&quot; + Thread.currentThread().getName());</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方案比较简单，但会出现两个问题：</p>
<ol>
<li>“惊群效应”，所有客户端都是监听这个节点变化，当一端释放锁时，别的端都会抢占</li>
<li>如果加锁成功的client突然崩溃，那么锁无法正常释放，全局进入死锁状态</li>
</ol>
<h3 id="思路二：临时有序节点"><a href="#思路二：临时有序节点" class="headerlink" title="思路二：临时有序节点"></a>思路二：临时有序节点</h3><p>为了应对上面的问题，可以使用临时有序节点：EPHEMERAL_SEQUENTIAL，之前的篇章中说明了临时节点特点，在client与zk断开连接时，临时节点会自动删除</p>
<p><strong>加锁算法：</strong></p>
<ol>
<li>客户端调用create()方法创建名为“&#x2F;lock”的节点，需要注意的是，这里节点的创建类型需要设置为EPHEMERAL_SEQUENTIAL</li>
<li>客户端调用getChildren(“lock”)方法来获取所有已经创建的子节点，同时在这个节点上注册上子节点变更通知的Watcher</li>
<li>客户端获取到所有子节点path之后，如果发现自己在步骤1中创建的节点是所有节点中序号最小的，那么就认为这个客户端获得了锁</li>
<li>如果在步骤3中发现自己并非是所有子节点中最小的，说明自己还没有获取到锁，就开始等待，直到下次子节点变更通知的时候，再进行子节点的获取，判断是否获取锁</li>
</ol>
<p><strong>解锁算法：</strong></p>
<ul>
<li>删除自己创建的那个子节点</li>
</ul>
<p><img src="http://images.zhuxingsheng.com/201904111339_161.png"></p>
<h4 id="代码片段-1"><a href="#代码片段-1" class="headerlink" title="代码片段"></a>代码片段</h4><p><strong>尝试加锁失败后，阻塞等待</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public void waitForLock(String lockName) throws Exception &#123;</span><br><span class="line">    logger.info(&quot;waitForLock &#123;&#125;:&#123;&#125;&quot;,beforeNode, Thread.currentThread().getName());</span><br><span class="line">    boolean hasLock = false;</span><br><span class="line">    while(!hasLock) &#123;</span><br><span class="line">       //是不是最小节点</span><br><span class="line">        boolean isMin = isMinNode();</span><br><span class="line">        if (isMin) &#123;//是 则成功获取锁</span><br><span class="line">            logger.info(&quot;waitForLock getLock:&#123;&#125;&quot;, Thread.currentThread().getName());</span><br><span class="line">            break;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                cf.getData().usingWatcher(new Watcher() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void process(WatchedEvent event) &#123;</span><br><span class="line">                        switch (event.getType()) &#123;</span><br><span class="line">                            case NodeDeleted:</span><br><span class="line">                                logger.info(&quot;path:&quot; + event.getPath() + &quot; has removed,before:&#123;&#125;,start to lock:&#123;&#125;&quot;, beforeNode, Thread.currentThread().getName());</span><br><span class="line">                                countDownLatch.countDown();</span><br><span class="line">                                break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).forPath(beforeNode);</span><br><span class="line">                logger.info(&quot;waitForLock waiting:&#123;&#125;&quot;, Thread.currentThread().getName());</span><br><span class="line">                countDownLatch.await();</span><br><span class="line">                logger.info(&quot;开始抢占:&#123;&#125;,&#123;&#125;&quot;, Thread.currentThread().getName(), currentNode);</span><br><span class="line">            &#125;catch (KeeperException.NoNodeException e)&#123;</span><br><span class="line">                logger.info(&quot;waitForLock has delete:&#123;&#125;,&#123;&#125;&quot;,beforeNode, Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方案解决了思路一中的问题</p>
<ol>
<li>只监听当前节点的上一个节点，这样就解决了“惊群”现象</li>
<li>临时节点，当连接断开后，就会自动删除，不会出现过期时间问题</li>
</ol>
<h2 id="完美了吗？"><a href="#完美了吗？" class="headerlink" title="完美了吗？"></a>完美了吗？</h2><p>再回看<a href="http://www.zhuxingsheng.com/blog/analysis-of-distributed-locks.html">《剖析分布式锁》</a>。zk实现方式完美了吗？</p>
<p>显然示例中没有达到好锁的标准，更完善的实现可以看看curator中的InterProcessLock</p>
<h3 id="单机"><a href="#单机" class="headerlink" title="单机"></a>单机</h3><p>此锁高可用了吗？对比一下Redis，哪种方案更完美？</p>
<p><img src="http://images.zhuxingsheng.com/201904192044_624.png"></p>
<p>客户端1发生GC停顿的时候，zookeeper检测不到心跳，也是有可能出现多个客户端同时操作共享资源的情形</p>
<p>redis的最新set指令,zk的临时节点两个性质都是一样的，解决了因过期时间问题引起的死锁</p>
<p>有了“续命丸”方案，在单机情况下，redis更完美些，至少不会出现zk临时节点因session超时提前删除问题</p>
<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>在集群下呢？ 线上环境，为了高可用不大会使用单点</p>
<p>如redis的cluster，哨兵模式;但由于Redis的主从复制（replication）是异步的，这可能会出现在数据同步过程中，<strong>master宕机，slave来不及同步数据就被选为master，从而数据丢失</strong></p>
<ol>
<li>客户端1从Master获取了锁</li>
<li>Master宕机了，存储锁的key还没有来得及同步到Slave上</li>
<li>Slave升级为Master</li>
<li>客户端2从新的Master获取到了对应同一个资源的锁</li>
</ol>
<h4 id="RedLock算法"><a href="#RedLock算法" class="headerlink" title="RedLock算法"></a>RedLock算法</h4><p>为了应对这个情形， redis的作者antirez提出了<strong>RedLock算法</strong>，步骤如下(该流程出自官方文档)，假设我们有N个master节点(官方文档里将N设置成5，其实大等于3就行)</p>
<ol>
<li>获取当前时间（单位是毫秒）</li>
<li>轮流用相同的key和随机值在N个节点上请求锁，在这一步里，客户端在每个master上请求锁时，会有一个和总的锁释放时间相比小的多的超时时间。比如如果锁自动释放时间是10秒钟，那每个节点锁请求的超时时间可能是5-50毫秒的范围，这个可以防止一个客户端在某个宕掉的master节点上阻塞过长时间，如果一个master节点不可用了，我们应该尽快尝试下一个master节点</li>
<li>客户端计算第二步中获取锁所花的时间，只有当客户端在大多数master节点上成功获取了锁（在这里是3个），而且总共消耗的时间不超过锁释放时间，这个锁就认为是获取成功了</li>
<li>如果锁获取成功了，那现在锁自动释放时间就是最初的锁释放时间减去之前获取锁所消耗的时间</li>
<li>如果锁获取失败了，不管是因为获取成功的锁不超过一半（N&#x2F;2+1)还是因为总消耗时间超过了锁释放时间，客户端都会到每个master节点上释放锁，即便是那些他认为没有获取成功的锁</li>
</ol>
<p><strong>缺陷</strong></p>
<p>比如一下场景，两个客户端client 1和client 2，5个redis节点nodes (A, B, C, D and E)。</p>
<ol>
<li>client 1从A、B、C成功获取锁，从D、E获取锁网络超时</li>
<li>节点C的时钟不准确(如时钟跳跃)，导致锁快速超时(算法第4点)</li>
<li>client 2从C、D、E成功获取锁，从A、B获取锁网络超时</li>
<li>这样client 1和client 2都获得了锁</li>
</ol>
<p>对于步骤2，还有一种情况，比如节点C崩溃重启了，但客户端1在C上加的锁没有持久化下来，丢失了；节点C重启后，client2从C、D、E成功获取锁</p>
<p>对于这两种情况，redis作者antirez给出了两种人为补偿措施</p>
<ul>
<li>一时钟问题，不允许人员修改时间</li>
<li>二节点重启，提出延迟重启的概念，即一个节点崩溃后，先不立即重启它，而是等待一段时间再重启，等待的时间大于锁的有效时间。采用这种方式，这个节点在重启前所参与的锁都会过期，它在重启后就不会对现有的锁造成影响</li>
</ul>
<blockquote>
<p>Redlock的问题，最关键的一点在于Redlock需要客户端去保证写入的一致性，后端5个节点完全独立，所有的客户端都得操作这5个节点。如果5个节点有一个leader，客户端只要从leader获取锁，其他节点能同步leader的数据，这样，分区、超时、冲突等问题都不会存在。所以为了保证分布式锁的正确性，我觉得使用强一致性的分布式协调服务能更好的解决问题</p>
</blockquote>
<p>而强一致问题，zk可以完成，zk是个CP系统，zk内部机制就保证了各数据的一致性</p>
<h2 id="分布式锁-1"><a href="#分布式锁-1" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>到此，对分布式锁的实现可以总结一下</p>
<p>zookeeper可靠性比redis强太多，只是效率低了点，如果并发量不是特别大，<strong>追求可靠性，首选zookeeper</strong></p>
<p><strong>为了效率，则首选redis实现</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>除了分布式锁，还有一个常用场景:master选举。在curator中也有相应封装：LeaderSelector；具体实现可以自行阅读源码</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/nevermorewang/p/8306903.html">基于zookeeper的分布式锁</a></p>
<p><a href="http://antirez.com/news/101">《Is Redlock safe?》</a></p>
<p><a href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html">《How to do distributed locking》</a></p>
<p><a href="https://www.zifangsky.cn/1367.html">curator使用说明</a></p>
<p><a href="http://www.cnblogs.com/zourui4271/p/9802231.html">分布式锁实现抉择</a></p>
<p><a href="http://weizijun.cn/2016/03/17/%E8%81%8A%E4%B8%80%E8%81%8A%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E8%AE%BE%E8%AE%A1/">聊一聊分布式锁的设计</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://www.zhuxingsheng.com/blog/technicians,-please-stay-away-from-technology.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="朱兴生">
      <meta itemprop="description" content="彪悍的人生需要书写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码农戏码">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/technicians,-please-stay-away-from-technology.html" class="post-title-link" itemprop="url">技术人请远离技术</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-03-25 19:34:42" itemprop="dateCreated datePublished" datetime="2019-03-25T19:34:42+08:00">2019-03-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-29 15:24:30" itemprop="dateModified" datetime="2021-09-29T15:24:30+08:00">2021-09-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>一本正经的胡说八道</p>
</blockquote>
<p>对错自在你心，可能就是个饭后闲扯</p>
<h3 id="所得"><a href="#所得" class="headerlink" title="所得"></a>所得</h3><p>以前同事问，什么时候跳槽？或者什么时候会出去看看机会呢？我都会回答做到有所得的时候。有所得，当然不是说拷贝公司几份源码，那可是公司资产，不可误入歧途。但知识是自己的，成长是自己的</p>
<p>一直也是这么践行的，从出校门不懂的书生到能把书本知识灵活运用到一线工作，从毫无经验到开发工业级产品，从职场小白到带队主导开发流程，虽然经历的大多数公司已经倒闭了，但自己是实实在在的成长了。</p>
<p>是的，是所有得再考虑外面机会的，小池塘不能满足成长时，就要去大池塘</p>
<p>前些天跟老同事见面聊游戏开发周期，我问现在立项时还是提议半年开发一款产品吗？同事呵呵两声回答，半年开发一款早就得卷地铺走人了，现在两周就得上线。着实吓了我一跳，原来他们现在是主攻小游戏，依赖完备的微信生态，快速产品，快速变现</p>
<p>去年同事项目出了个爆款，公司整年有近3亿纯利，开发自然奖金不菲，当然也没有想像中那么多</p>
<p>我思考他们的开发模式，直接模仿国外游戏，改头换皮，再稍加修改，上线。大多数产品肯定是上得快，死得也快。如此环境，对技术人员的成长有多少帮助</p>
<p>绝大多数收益进入老板口袋，开发人员一直重复再重复，甚至有些游戏只是改了个名字，最后他们能得到什么？</p>
<p>此类游戏业务简单，公司组织也扁平，尤其服务端，平台提供了各种服务，小游戏前端已经在喊着要干掉服务端的口号，不 管哪个开发岗位，在几年后，当面对新机会时，怎么阐述自己的价值，是抄得更快速？还是因为运气，出了多少爆款？</p>
<p>由他而又思考到自己所谓的大公司，有人评价阿里工程师，说普遍被中间件惯坏了</p>
<p>不是背后说人坏话，只是一种现象，可能是大公司人的普遍问题<br>，进阿里是大多数技术人的梦想，包括我，但估计此生无缘，能力实在达不到阿里要求</p>
<p>面试造火箭，入职拧螺丝；公司越成熟，基础建设就越完备、基建设施模块化程度越高，工具体验做得越好，平台做得越完善，那么对上层做业务来讲，底层细节也就屏蔽越多</p>
<p>对业务来说本身是件好事，但对业务开发技术人员呢？有些领域技术变化很快，两三年可能迭代了好几轮，在深度、广度上有了质的飞跃，而你该怎么办，削足适履追求新技术吗？</p>
<p>回顾自己技术实力时，脱离了这些基础设施，还有多少生产力？尤其微服务会打散各个业务线，可能一条完整的业务链路都理不清</p>
<p>此时，还能有所得吗？得多少？褪去头顶公司光环，酒桌上的牛还能吹多大？</p>
<h3 id="所思"><a href="#所思" class="headerlink" title="所思"></a>所思</h3><p>有人说技术人就像丢在大海里的漂流瓶，努力漂泊，孤傲不羁，却怎么也不能融入大海，装不满自己空空如也的肚腩，因为他们不知道身体倾斜一点，才是最佳姿势，才有最快的装水速度</p>
<p>也许真是远离技术看技术，才有更大的格局</p>
<p>从事游戏开发很多年，一直觉得自己对游戏开发还是有见解的，但好像只是开发阶段的把握，而不是游戏本身的整体把握。</p>
<p>早些年总是抱怨，为什么我们技术这么好，为什么游戏总是死呢？其实考虑面太窄，没想过运营，商务，维护，推广等等事项，手上有把锤子，到处只看到钉子了</p>
<p>对于游戏类型，也很局限，最近看到一个外行人总结游戏类型，特别的汗颜</p>
<blockquote>
<p>依据不同的投入类型，我们可以把游戏分成三大类：</p>
<p>1）反应。这类游戏，需要实时观察周围环境，并快速作出操作和应对。最典型的就是各种射击、动作、即时战略类游戏。</p>
<p>2）策略。这类游戏，需要综合考虑各种可能性，对未来作出规划，并安排好下一步行动。典型如各种策略模拟游戏。</p>
<p>3）沉浸。这类游戏，需要代入角色，理解和接受其世界观，阅读、记忆大量剧情，探索故事线。典型就是各种角色扮演游戏。</p>
<p>游戏的玩法可以千奇百怪，类型可以随意组合，但好的游戏，对玩家的要求，基本都不出这三类</p>
</blockquote>
<p>这些只是单机玩法，大型网络游戏，还涉及到群体心理等等</p>
<p>在游戏行业打拼多年，尽然没有一个外行总结到位，抽象高度太低太低</p>
<p>技术里的世界不小，但技术外的世界更大</p>
<p>是该放下手中的技术，抬头看看外面的世界</p>
<p>功夫在诗外，也许再回头看技术时，别有一番天</p>
<p>当然千万别一时亢奋放弃技术，远离技术是在追求技术无法再提升格局的时候，跳出来，回头看</p>
<p>是从简入繁完成后，由繁化简的过程中的技法；无法打开一把锁时，不能只盯着锁看，因为钥匙可能在远离锁的地方</p>
<p>那么如何远离技术呢？远离程度呢？也许多读书是个切入口，《关于读书》这篇文章也许对你有所帮助，如果能找到牛人指点更好。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://www.zhuxingsheng.com/blog/zookeeper-knowledge-structure-2-zab-protocol.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="朱兴生">
      <meta itemprop="description" content="彪悍的人生需要书写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码农戏码">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/zookeeper-knowledge-structure-2-zab-protocol.html" class="post-title-link" itemprop="url">zookeeper知识结构2-zab协议</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-03-25 11:40:00" itemprop="dateCreated datePublished" datetime="2019-03-25T11:40:00+08:00">2019-03-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-07 21:29:17" itemprop="dateModified" datetime="2021-11-07T21:29:17+08:00">2021-11-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>通过<a href="http://www.zhuxingsheng.com/blog/zookeeper-knowledge-structure.html">《zookeeper知识结构1》</a>了解了zookeeper是什么？为什么使用zookeeper? 以及zookeeper内部数据结构，选举机制</p>
<h1 id="zab定义"><a href="#zab定义" class="headerlink" title="zab定义"></a>zab定义</h1><p>ZAB全称ZooKeeper Atomic Broadcast protocol</p>
<p>ZooKeeper原子广播协议，实现了主备模式下的系统架构，保持集群中各个副本之间的数据同步(数据最新，一致性)</p>
<hr>
<h1 id="原子广播"><a href="#原子广播" class="headerlink" title="原子广播"></a>原子广播</h1><p>在具体深入zab之前，先搞明白原子广播</p>
<p>原子性好理解，不管是事务的ACID，还是多线程中，都有这个概念；广播也好理解，像系统中常引入消息队列进行消息广播</p>
<p>但两者合在一起，有点犯晕了，广播怎么需要原子性？哪部分操作不可分割呢？</p>
<blockquote>
<p>所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的,也就是说,要么整个集群所有机器都成功应用了某一个事务, 要么就都没应用.</p>
</blockquote>
<p>按照上面的解释，原子性体现在所有机器事务一致性,要么都接受广播，要么都不接受；为了更深入理解，从头开始深入一下这个机制的大致流程</p>
<p>在分布式中，这个机制有很多具体实现，比如2PC,3PC，paxos等等</p>
<h2 id="副本"><a href="#副本" class="headerlink" title="副本"></a>副本</h2><p>在这个机制介绍前，需要先介绍下分布式中的副本(Replication)</p>
<p>副本简直是处理故障恢复的的万能钥匙</p>
<p>数据副本的收益：</p>
<ol>
<li>提升系统可用性，需要挂更多的节点才会导致数据丢失</li>
<li>提升系统性能，多个副本可以同时处理或者交给更快的机器处理</li>
</ol>
<p>分布式系统采用副本可以获得可扩展性，高性能，可用性，容错性</p>
<ol>
<li>害怕数据不可用，采用副本吧，多副本能确保数据由于故障丢失的概率大大降低；</li>
<li>计算太慢，采用副本吧，将计算散布到多台机器上；</li>
<li>I&#x2F;O太慢，采用副本吧，将数据cache到local机器上，可以极大的提升吞吐</li>
</ol>
<p><strong>正常多副本，可以从任何副本请求数据</strong></p>
<p><img src="http://images.zhuxingsheng.com/201904021755_419.png"></p>
<h2 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h2><p>为了多个副本上的数据同步，一般会加一个dispatche,client请求到dispatche上，dispatche会对请求进行排序，并<strong>按同样的顺序分发</strong>到各个副本，保持各副本数据一致</p>
<p><img src="http://images.zhuxingsheng.com/201904021901_696.png"></p>
<p>此时，dispatche成了系统中的单点，不具备高可用，所以会部署多个dispatch</p>
<p><img src="http://images.zhuxingsheng.com/201904021911_461.png"></p>
<p>每个dispatche相互通信，并且每个dispatche都可以分发到各个副本；此时就会出现上图中的并发更新一致性问题，类似于<a href="https://mp.weixin.qq.com/s/SH-JVdcTmwUPoax1lo0-cw">《深入浅出事务》</a>中的第二类更新丢失</p>
<p>在并发操作时，应用本身对于数据的先后都是可以接受的，但在各个副本中的数据必须保持一致，也就是下图中的结果都是可以的</p>
<p><img src="http://images.zhuxingsheng.com/201904021918_734.png"></p>
<p>也就是讲，各个dispatche得以相同的顺序进行更新副本</p>
<h3 id="顺序同步"><a href="#顺序同步" class="headerlink" title="顺序同步"></a>顺序同步</h3><p>解决并发更新不一致问题，思路就是对请求操作进行排序，按顺序执行</p>
<p><img src="http://images.zhuxingsheng.com/201904031256_336.png"></p>
<p>数据更新的过程如下：</p>
<ol>
<li>客户发送操作请求到任意一个节点的分发器上</li>
<li>分发器接收到请求后，将请求广播到其他节点上的分发器，并且这些分发器之间会对所有的并发请求进行排序。最终每个节点的分发器上都会有一份完全一样的请求列表。这个功能通常称作<strong>原子广播（Atomic Broadcast）</strong> 或者 <strong>全局排序广播（Total Order Broadcast)</strong></li>
<li>分发器将列表中的操作请求按照顺序送给本节点的数据副本</li>
</ol>
<p>在这个模型中，原子广播的逻辑和业务逻辑是分开的。这么做的好处是非常明显的，业务逻辑的实现不再受分布式需求的限制，原子广播的逻辑则不需要考虑业务逻辑的具体需求。独立的原子广播的逻辑可以被重用到很多的分布式的应用上</p>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>根据上面的推导，得出一个最简单的原型</p>
<p><img src="http://images.zhuxingsheng.com/201904031751_747.png"></p>
<p>dispatche增加一个队列，也可以把它设计成日志文件（顺序追加的文件）或者管道等等，当有请求时，会按顺序存储到队列，但<strong>这个队列中的每个位置只能存储一次数据，存储后不能进行更改</strong></p>
<h3 id="请求操作"><a href="#请求操作" class="headerlink" title="请求操作"></a>请求操作</h3><p><img src="http://images.zhuxingsheng.com/201904040941_489.png"></p>
<ol>
<li>收到客户端的数据存储请求后，选择一个存储位置。发送数据储存指令给其他的分发器，同时将数据存储到自己的存储队列中</li>
<li>当收到其他分发器发送的存储指令后，将数据存储到自己的存储队列。如果该位置已经存储了数据，则返回失败</li>
</ol>
<ul>
<li>数据存储指令的内容:<strong>[存储位置，数据]</strong></li>
<li>存储位置的选择:<strong>选择最小的空存储位</strong></li>
</ul>
<h3 id="并发更新"><a href="#并发更新" class="headerlink" title="并发更新"></a>并发更新</h3><p><img src="http://images.zhuxingsheng.com/201904041307_497.png"></p>
<p>当两个client分别发到不同到dispatche上请求，两个dispatche相互同步时，出现了不一致，<strong>违背了各个队列的每个位置只能存储一次元素，不能更改的原则</strong></p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>对于并发问题，首先想到就是加锁，对于分布式系统怎么加锁呢？</p>
<p>2PC提供了好的思路</p>
<p><img src="http://images.zhuxingsheng.com/201903281845_163.png"></p>
<p>借鉴一下2pc，加锁过程如下：</p>
<p><strong>第一步：加锁</strong></p>
<p><img src="http://images.zhuxingsheng.com/201904041325_224.png"></p>
<ol>
<li>接受到请求，选择本地队列位置，并加锁</li>
<li>发送加锁指令到别的dispatche2，dipatche2进行相同位置加锁，并回返lock ack</li>
</ol>
<ul>
<li>加锁指令：<strong>[位置]</strong></li>
</ul>
<p><strong>第二步：更新</strong></p>
<p><img src="http://images.zhuxingsheng.com/201904040941_489.png"></p>
<ol>
<li>收到所有dispatche都返回lock ack</li>
<li>数据写入队列位置上，并发送存储指令给所有disptache</li>
<li>dispatche收到存储指令，把数据写入队列相应位置</li>
</ol>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>并发考虑的两个问题：安全性与活跃性</p>
<p><img src="http://images.zhuxingsheng.com/201904041912_11.png"></p>
<p>dispatche1与dispatche2分别接收到请求，在第一步加锁时，先给自己队列加锁，再发送加锁指令给其它dispatche</p>
<p>此时，就出现死锁：如dispathe1对自身队列位置1加锁，再发送指令给disptache2的队列位置1加锁，但disptache2的队列位置1被自己锁住了，反之disptache1队列位置1也一样，此时双方进入死锁，永远阻塞</p>
<h4 id="优先级锁"><a href="#优先级锁" class="headerlink" title="优先级锁"></a>优先级锁</h4><p>有一种策略，就是给锁增加一个优化级</p>
<ul>
<li>每个锁请求都有一个优先级，优先级高的锁请求可以撤销优先级低的锁。</li>
<li>如果一个存储指令的锁被撤销了，就不能被执行</li>
</ul>
<p><img src="http://images.zhuxingsheng.com/201904041934_12.png"></p>
<p>如图所示，两个dispatche分别接收到请求，p1 p2是各自锁的优先级，p1高于p2</p>
<ol>
<li>dispatch1接收请求后，自己队列加锁；收到dispatch2的加锁请求，但p2优先级低于p1，所以被阻塞</li>
<li>dispatche2自身加锁后，收到dispatche1的加锁请求，由于p1高于p2，dispatche2撤销p2操作，p1成功加锁</li>
<li>dispatche1成功在所有dispatche上加锁</li>
</ol>
<p><strong>优先级：</strong></p>
<ol>
<li>有先后次序,优先级不能相等</li>
<li>不可重复</li>
</ol>
<p>比如以dispatche的id作为优先级值，dispatcheId是不同的，也能区分优先级，但这样会出现不平衡，以id大的优先级高，那永远id为大的优先获取锁，加锁成功处理请求</p>
<p>为了更好的均衡各个客户的请求处理，可以采用下面的优先级定义：<strong>[数值，dispatcheID]</strong></p>
<p>数值可以由各个dispatche指定，比如所有disptache都原子累加，这样可以保证每个dispathe的均衡，当数值相等时，再比较dispatcheId</p>
<h3 id="节点故障"><a href="#节点故障" class="headerlink" title="节点故障"></a>节点故障</h3><p>故障可能发生在每个阶段，一是加锁阶段，二是数据更新阶段；再细节大概有三种情况：</p>
<ol>
<li>加锁成功，但没有写入数据</li>
<li>部分节点写入了数据</li>
<li>故障dispatche已经写入数据，但没有同步到别的dispatche</li>
</ol>
<h4 id="加锁成功，没有写入数据"><a href="#加锁成功，没有写入数据" class="headerlink" title="加锁成功，没有写入数据"></a>加锁成功，没有写入数据</h4><p>这个很好解决，通过优先级锁，另的节点发起一个更高优先级操作就可以覆盖先前的记录</p>
<h4 id="部分节点写入数据"><a href="#部分节点写入数据" class="headerlink" title="部分节点写入数据"></a>部分节点写入数据</h4><p>解决这个问题，需要加强一下更新操作，之前的更新操作，发送<strong>存储指令</strong>给各个节点，就结束了</p>
<p>现在不单单发送指令，还需要再广播</p>
<p>也就是节点接受到存储指令，如果节点已经有数据写入，则与数据一起返回；这样当所有节点返回加锁成功后，检查是否有数据返回，如果有数据返回，则将数据放入存储指令，发送给所有节点</p>
<h4 id="没有同步别的dispatche"><a href="#没有同步别的dispatche" class="headerlink" title="没有同步别的dispatche"></a>没有同步别的dispatche</h4><p>需要增加一个“预存储队列”，预写入机制</p>
<p>当dispatche1发生故障时，其它的dispatche的预存储队列中已经存入了数据。其它节点接管dispatche1时，会先重发预存储队列中的数据到所有dispatche</p>
<p>预写入过程可以保证：如果数据被写入了任意的存储队列，那么所有节点的预存储队列都有这个数据</p>
<h3 id="多数派"><a href="#多数派" class="headerlink" title="多数派"></a>多数派</h3><p>上面的广播机制中，加锁以及预写入都需要所有节点返回成功。如果任意一个节点有故障都会失败。在复杂网络环境下，整个系统很脆弱，不能高可用</p>
<p>因此可以改进为半数以上节点成功回复就可以</p>
<p>大多数派机制下，会带来一些更复杂的中间状态，整个过程：</p>
<ol>
<li>发送加锁指令</li>
<li>收到加锁指令后，检查指定存储位置是否已经加锁，如没有，则返回加锁成功；如被加锁，则比较锁优先级，如果优先级更高，就撤销原有锁，重新加锁返回成功；如果已经预写入数据，则将数据一并返回</li>
<li>当超过半数节点返回加锁成功后，检查是否有数据返回。如果有数据返回，则将优先级最高的数据存入预存储指令。如果没有数据返回，则将自己的数据写入预存储指令。发送预存储指令给所有dispatche,并写入自己的预存储队列</li>
<li>收到预存储指令，将数据写入预存储队列。如果预存储锁被撤销，则返回失败</li>
<li>当超过半数返回预存储成功，刚发送存储指令给所有dispatche，并写入自己的存储队列</li>
<li>当收到存储队列，将数据写入自己存储队列中</li>
</ol>
<h1 id="ZAB详细"><a href="#ZAB详细" class="headerlink" title="ZAB详细"></a>ZAB详细</h1><p>有了上面的原型，理解其它的具体协议就会轻松很多，在具体实现时，都会看到原型中的概念</p>
<p>ZAB协议是为分布式协调服务 Zookeeper 专门设计的一种支持 <strong>崩溃恢复</strong> 和 <strong>原子广播</strong> 协议</p>
<p>ZAB协议定义了选举（election）、发现（discovery）、同步（sync）、广播(Broadcast)四个阶段</p>
<p><img src="http://images.zhuxingsheng.com/201903271732_437.png"></p>
<h2 id="原型抽象"><a href="#原型抽象" class="headerlink" title="原型抽象"></a>原型抽象</h2><p>根据上面的原型，结合zk的源码，梳理一下源码中对应原型的抽象</p>
<h3 id="投票对象"><a href="#投票对象" class="headerlink" title="投票对象"></a>投票对象</h3><p>这个对象对应着原型中的存储指令，优先级加锁指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Vote(long id, long zxid) &#123;</span><br><span class="line">    this.id = id;</span><br><span class="line">    this.zxid = zxid;</span><br><span class="line">    this.electionEpoch = -1;</span><br><span class="line">    this.peerEpoch = -1;</span><br><span class="line">    this.state = ServerState.LOOKING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>id：被推举的Leader的SID</p>
<p>zxid：被推举的Leader事务ID</p>
<p><img src="http://images.zhuxingsheng.com/201903271646_456.png"></p>
<p>为了保证事务的顺序一致性，zookeeper 采用了递增的事 务 id 号（zxid）来标识事务。</p>
<p>所有的提议（proposal）都在被提出的时候加上了 zxid。</p>
<p>实现中 zxid 是一个 64 位的数字</p>
<p>它高32 位是 epoch（ZAB 协议通过 epoch 编号来区分 Leader 周期变化的策略）用来标识 leader关系是否改变，每次一个 leader 被选出来，它都会有一个新的epoch&#x3D;（原来的 epoch+1），标识当前属于那个 leader 的统治时期。</p>
<p>低 32 位用于递增计数</p>
<p>可以想象为中国古代的年号，例如万历十五年，万历是epoch，十五年是id</p>
<p>electionEpoch：逻辑时钟，用来判断多个投票是否在同一轮选举周期中，该值在服务端是一个自增序列，每次进入新一轮的投票后，都会对该值进行加1操作</p>
<p>peerEpoch：被推举的Leader的epoch</p>
<p>electionEpoch和peerEpoch的区别在于，electionEpoch记录的选举的轮次，而peerEpoch则指的是当前leader的任期</p>
<p>state：当前服务器的状态</p>
<h2 id="FastLeaderElection"><a href="#FastLeaderElection" class="headerlink" title="FastLeaderElection"></a>FastLeaderElection</h2><p>zk默认的选举算法，为什么需要选举可以参照《zookeeper知识结构1》</p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul>
<li>外部投票：特指其他服务器发来的投票。</li>
<li>内部投票：服务器自身当前的投票。</li>
<li>选举轮次：Zookeeper服务器Leader选举的轮次，即logicalclock</li>
<li>PK：对内部投票和外部投票进行对比来确定是否需要变更内部投票</li>
</ul>
<blockquote>
<p>electionEpoch和logicalclock的区别在于，electionEpoch指的是发出server的logicalclock，而logicalclock则指的是当前Server所处的选举的轮次</p>
</blockquote>
<p><img src="http://images.zhuxingsheng.com/201904091257_850.png"></p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul>
<li>sendqueue：选票发送队列，用于保存待发送的选票。</li>
<li>recvqueue：选票接收队列，用于保存接收到的外部投票。</li>
<li>WorkerReceiver：选票接收器。其会不断地从QuorumCnxManager中获取其他服务器发来的选举消息，并将其转换成一个选票，然后保存到recvqueue中，在选票接收过程中，如果发现该外部选票的选举轮次小于当前服务器的，那么忽略该外部投票，同时立即发送自己的内部投票。</li>
<li>WorkerSender：选票发送器，不断地从sendqueue中获取待发送的选票，并将其传递到底层QuorumCnxManager中</li>
</ul>
<h3 id="QuorumCnxManager"><a href="#QuorumCnxManager" class="headerlink" title="QuorumCnxManager"></a>QuorumCnxManager</h3><p>ClientCnxn是ZooKeeper客户端中用于处理网络I&#x2F;O的一个管理器</p>
<p>在Leader选举的过程中也有类似的角色，那就是QuorumCnxManager——每台服务器启动的时候都会启动一个QuorumCnxManager，负责各台服务器之间的底层Leader选举过程中的网络通信</p>
<p>QuorumCnxManager这个类内部维护了一系列的队列，用于保存接收到的、待发送的消息，以及消息的发送器。</p>
<p>除接收队列以外，这里提到的所有队列都有一个共同点——按SID分组形成队列集合，我们以发送队列为例来说明这个分组的概念。</p>
<p>假设集群中除自身外还有4台机器，那么当前服务器就会为这4台服务器分别创建一个发送队列，互不干扰。</p>
<ul>
<li>queueSendMap：消息发送队列，用于保存那些待发送的消息。queueSendMap是一个Map，按照SID进行分组，分别为集群中的每台机器分配了一个单独队列，从而保证各台机器之间的消息发送互不影响。</li>
<li>senderWorkerMap：发送器集合。每个SendWorker消息发送器，都对应一台远程ZooKeeper服务器，负责消息的发送。同样，在sendWorkerMap中，也按照SID进行了分组。</li>
<li>lastMessageSent：最近发送过的消息。在这个集合中，为每个SID保留最近发送过的一个消息</li>
</ul>
<blockquote>
<p>在SendWorker的具体实现中，有一个细节需要我们注意一下：一旦ZooKeeper发现针对当前远程服务器的消息发送队列为空，那么这个时候就需要从lastMessageSent中取出一个最近发送过的消息来进行再次发送。这个细节的处理主要为了解决这样一类分布式问题：接收方在消息接收前，或者是在接收到消息后服务器挂掉了，导致消息尚未被正确处理。那么如此重复发送是否会导致其他问题呢？当然，这里可以放心的一点是，ZooKeeper能够保证接收方在处理消息的时候，会对重复消息进行正确的处理</p>
</blockquote>
<p>lastMessageSent接近原型中的预存储队列</p>
<h3 id="选票过程"><a href="#选票过程" class="headerlink" title="选票过程"></a>选票过程</h3><p><img src="http://images.zhuxingsheng.com/201904091834_884.png"></p>
<ul>
<li>1.自增选举轮次。Zookeeper规定所有有效的投票都必须在同一轮次中，在开始新一轮投票时，会首先对logicalclock进行自增操作。</li>
<li>2.初始化选票。在开始进行新一轮投票之前，每个服务器都会初始化自身的选票，并且在初始化阶段，每台服务器都会将自己推举为Leader</li>
<li>3.发送初始化选票。完成选票的初始化后，服务器就会发起第一次投票。Zookeeper会将刚刚初始化好的选票放入sendqueue中，由发送器WorkerSender负责发送出去。</li>
<li>4.接收外部投票。每台服务器会不断地从recvqueue队列中获取外部选票。如果服务器发现无法获取到任何外部投票，那么就会立即确认自己是否和集群中其他服务器保持着有效的连接，如果没有连接，则马上建立连接，如果已经建立了连接，则再次发送自己当前的内部投票</li>
<li>5.判断选举轮次。在发送完初始化选票之后，接着开始处理外部投票。在处理外部投票时，会根据选举轮次来进行不同的处理。<ul>
<li>5.1.外部投票的选举轮次大于内部投票。若服务器自身的选举轮次落后于该外部投票对应服务器的选举轮次，那么就会立即更新自己的选举轮次(logicalclock)，并且清空所有已经收到的投票，然后使用初始化的投票来进行PK以确定是否变更内部投票。最终再将内部投票发送出去。</li>
<li>5.2.外部投票的选举轮次小于内部投票。若服务器接收的外选票的选举轮次落后于自身的选举轮次，那么Zookeeper就会直接忽略该外部投票，不做任何处理，并返回步骤4。</li>
<li>5.3.外部投票的选举轮次等于内部投票。此时可以开始进行选票PK</li>
</ul>
</li>
<li>6.选票PK。在进行选票PK时，符合任意一个条件就需要变更投票<ul>
<li>6.1.若外部投票中推举的Leader服务器的选举轮次大于内部投票，那么需要变更投票。</li>
<li>6.2.若选举轮次一致，那么就对比两者的ZXID，若外部投票的ZXID大，那么需要变更投票。</li>
<li>6.3.若两者的ZXID一致，那么就对比两者的SID，若外部投票的SID大，那么就需要变更投票。</li>
</ul>
</li>
<li>7.变更投票。经过PK后，若确定了外部投票优于内部投票，那么就变更投票，即使用外部投票的选票信息来覆盖内部投票，变更完成后，再次将这个变更后的内部投票发送出去。</li>
<li>8.选票归档。无论是否变更了投票，都会将刚刚收到的那份外部投票放入选票集合recvset中进行归档。recvset用于记录当前服务器在本轮次的Leader选举中收到的所有外部投票（按照服务队的SID区别，如{(1, vote1), (2, vote2)…}）。</li>
<li>9.统计投票。完成选票归档后，就可以开始统计投票，统计投票是为了统计集群中是否已经有过半的服务器认可了当前的内部投票，如果确定已经有过半服务器认可了该投票，则终止投票。否则返回步骤4</li>
<li>10.更新服务器状态。若已经确定可以终止投票，那么就开始更新服务器状态，服务器首选判断当前被过半服务器认可的投票所对应的Leader服务器是否是自己，若是自己，则将自己的服务器状态更新为LEADING，若不是，则根据具体情况来确定自己是FOLLOWING或是OBSERVING。</li>
</ul>
<p>以上10个步骤就是FastLeaderElection的核心，其中步骤4-9会经过几轮循环，直到有Leader选举产生。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过对原子广播原型的理解，更容易理解zab，对于paxos也一样</p>
<p>当然zab还有很多的细节，还能再深入，挖出很多知识点。但只看理论终归有些空洞，下一篇实践一下，详述zk版本分布式锁</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/en_joker/article/details/79400289">Leader选举</a></p>
<p><a href="https://blog.csdn.net/lpstudy/article/details/83685997">分布式系统</a></p>
<p><a href="https://mp.weixin.qq.com/s/IjULLfI5QjhKXVa_91no4A">由浅入深理解Paxos协议</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://www.zhuxingsheng.com/blog/zookeeper-knowledge-structure.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="朱兴生">
      <meta itemprop="description" content="彪悍的人生需要书写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码农戏码">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/zookeeper-knowledge-structure.html" class="post-title-link" itemprop="url">zookeeper知识结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-03-11 19:33:00" itemprop="dateCreated datePublished" datetime="2019-03-11T19:33:00+08:00">2019-03-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-07 21:29:17" itemprop="dateModified" datetime="2021-11-07T21:29:17+08:00">2021-11-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前写过关于zookeeper的一篇文章<a href="http://www.zhuxingsheng.com/blog/zookeeper-paxos.html">《zookeeper-paxos》</a>，paxos太难理解了，当时理解了，但现在又忘记了，机械学习果然是不行的</p>
<p>虽然曾经有一篇文章讲阿里不使用zk做服务发现，但大多数公司的分布式架构中基本都能看到zk的身影，而且他躲在里面，你可能看不到他，感受不到他的存在</p>
<p>对于架构体系中的这样一位选手，了解，学习，研究是相当有必要的</p>
<h1 id="ZK是什么"><a href="#ZK是什么" class="headerlink" title="ZK是什么"></a>ZK是什么</h1><p>ZooKeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby 一个开源的实现</p>
<p>ZooKeeper 是集群的管理者，监视着集群中各节点的状态，根据节点提交的反馈进行下 一步合理的操作。最终，将简单易用的接口和功能稳定，性能高效的系统提供给用户</p>
<blockquote>
<p>zooKeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services</p>
</blockquote>
<p>这大概描述了Zookeeper的作用，配置管理，名字服务，提供分布式同步以及集群管理</p>
<h1 id="为什么需要ZK"><a href="#为什么需要ZK" class="headerlink" title="为什么需要ZK"></a>为什么需要ZK</h1><p>知道了zk的定义，其实跟不知道差不多，还是要追根溯源，看看zk今世因缘，存在的意义</p>
<p>zk的历史很多地方都有介绍，这儿就不赘述了</p>
<p>相对历史，更想知道为什么需要zk？</p>
<p>以前经历的系统，都是使用redis做为服务中心了，不管使用single redis,还是redis cluster，能胜任架构需求，全局命名服务、订阅发布监听服务列表、分布式锁足矣</p>
<p>一度怀疑zk的价值，也阻碍了进一步学习的热情，但存在即合理</p>
<p><strong>设计 ZooKeeper 的目的是为了减轻分布式应用程序所承担的协调任务</strong></p>
<p>还是从ZK的定义追溯它的作用</p>
<h3 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h3><p>在我们的应用中除了代码外，还有一些就是各种配置。比如数据库连接等</p>
<p>一般我们都是使用配置文件的方式，在代码中引入这些配置文件。但是当我们只有一种配置，只有一台服务器，并且不经常修改的时候，使用配置文件是一个很好的做法，但是如果我们配置非常多，有很多服务器都需要这个配置，而且还可能是动态的话使用配置文件就不是个好主意了。</p>
<p>这个时候往往需要寻找一种集中管理配置的方法，我们在这个集中的地方修改了配置，所有对这个配置感兴趣的都可以获得变更。比如我们可以把配置放在数据库里，然后所有需要配置的服务都去这个数据库读取配置</p>
<p>但是，因为很多服务的正常运行都非常依赖这个配置，所以需要这个集中提供配置服务的服务具备很高的可靠性。</p>
<p>一般我们可以用一个集群来提供这个配置服务，但是用<strong>集群提升可靠性</strong>，那如何保证配置在集群中的一致性呢？ 这个时候就需要使用一种实现了一致性协议的服务了。Zookeeper就是这种服务，它使用Zab这种一致性协议来提供<strong>一致性</strong></p>
<h3 id="名字服务"><a href="#名字服务" class="headerlink" title="名字服务"></a>名字服务</h3><p>比如为了通过网络访问一个系统，我们得知道对方的IP地址，但是IP地址对人非常不友好，这个时候我们就需要使用域名来访问。</p>
<p>但是计算机是不能是别域名的。</p>
<p>怎么办呢？</p>
<p>如果我们每台机器里都备有一份域名到IP地址的映射，这个倒是能解决一部分问题，但是如果域名对应的IP发生变化了又该怎么办呢？于是我们有了DNS这个东西。</p>
<p>我们只需要访问一个大家熟知的(known)的点，它就会告诉你这个域名对应的IP是什么。</p>
<p>在我们的应用中也会存在很多这类问题，特别是在我们的服务特别多的时候，如果我们在本地保存服务的地址的时候将非常不方便，但是如果我们只需要访问一个大家都熟知的访问点，这里提供统一的入口，那么维护起来将方便得多了</p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>比如在一个分布式环境中，为了提高可靠性，我们的集群的每台服务器上都部署着同样的服务</p>
<p>但是，一件事情如果集群中的每个服务器都进行的话，那相互之间就要协调，编程起来将非常复杂。而如果我们只让一个服务进行操作，那又存在单点。通常还有一种做法就是使用分布式锁，在某个时刻只让一个服务去干活，当这台服务出问题的时候锁释放，立即fail over到另外的服务</p>
<p>这在很多分布式系统中都是这么做，这种设计有一个更好听的名字叫Leader Election(leader选举)。比如HBase的Master就是采用这种机制。但要注意的是分布式锁跟同一个进程的锁还是有区别的，所以使用的时候要比同一个进程里的锁更谨慎的使用</p>
<p>这儿其实说了两个作用</p>
<ol>
<li>传统意义的锁，如<a href="http://zhuxingsheng.com/blog/analysis-of-distributed-locks.html">《剖析分布式锁》</a>，保护对共享资料操作</li>
<li>master选举，像JOB，为了高可用，会有多台服务器部署同一套JOB程序，但在运行时，只有一台服务器真正执行业务，此时，需要选择一台服务器，如果这台机器挂了，别的机器需要顶替上来</li>
</ol>
<h3 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h3><p>在分布式的集群中，经常会由于各种原因，比如硬件故障，软件故障，网络问题，有些节点会进进出出。有新的节点加入进来，也有老的节点退出集群。这个时候，集群中其他机器需要感知到这种变化，然后根据这种变化做出对应的决策</p>
<p>比如我们是一个分布式存储系统，有一个中央控制节点负责存储的分配，当有新的存储进来的时候我们要根据现在集群目前的状态来分配存储节点</p>
<p>这个时候我们就需要<strong>动态感知到集群目前的状态</strong>，这也就是<strong>注册中心</strong></p>
<h1 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h1><p>分布式系统在设计时，都会考虑一下CAP，在现有理论下，CAP是不能同时满足的，所以需要根据业务场景选择合适的设计要求</p>
<p>CAP定义在<a href="http://www.zhuxingsheng.com/blog/zookeeper-paxos.html">《zookeeper-paxos》</a>中有详细说明</p>
<p><img src="http://images.zhuxingsheng.com/201903131427_915.png"></p>
<p>ZooKeeper是个CP（一致性+分区容错性）的，即任何时刻对ZooKeeper的访问请求能得到一致的数据结果，同时系统对网络分割具备容错性；但是它不能保证每次服务请求的可用性。也就是在极端环境下，ZooKeeper可能会丢弃一些请求，消费者程序需要重新请求才能获得结果。</p>
<p>ZooKeeper是分布式协调服务，<strong>它的职责是保证数据在其管辖下的所有服务之间保持同步、一致；所以就不难理解为什么ZooKeeper被设计成CP而不是AP特性的了</strong></p>
<p>而且， 作为ZooKeeper的核心实现算法Zab，就是解决了分布式系统下数据如何在多个服务之间保持同步问题的</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>顺序一致性：从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。</li>
<li>原子性：所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。</li>
<li>单一系统映像：无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。</li>
<li>可靠性：一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。</li>
</ul>
<h1 id="znode"><a href="#znode" class="headerlink" title="znode"></a>znode</h1><p>在谈到分布式的时候，我们通常说的“节点”是指组成集群的每一台机器<br>然而，在 ZooKeeper 中，“节点”分为两类：</p>
<ol>
<li>第一类同样是指构成集群的机器，我们称之为机器节点。</li>
<li>第二类则是指数据模型中的数据单元，我们称之为数据节点一ZNode</li>
</ol>
<p>与Linux文件系统不同的是，Linux文件系统有目录和文件的区别，而Zookeeper的数据节点称为ZNode，ZNode是Zookeeper中数据的最小单元，每个ZNode都可以保存数据，同时还可以挂载子节点，因此构成了一个层次化的命名空间，称为树</p>
<p><img src="http://images.zhuxingsheng.com/201903191400_762.png"></p>
<ul>
<li><p>每一个znode默认能够存储1MB的数据（对于记录状态性质的数据来说，够了）</p>
</li>
<li><p>可以使用zkCli命令，登录到zookeeper上，并通过ls、create、delete、sync等命令操作这些znode节点</p>
</li>
</ul>
<p>znode除了名称、数据以外，还有一套属性：zxid</p>
<p>ZooKeeper状态的每一次改变, 都对应着一个递增的Transaction id, 该id称为zxid. 由于zxid的递增性质, 如果zxid1小于zxid2, 那么zxid1肯定先于zxid2发生</p>
<p>创建任意节点, 或者更新任意节点的数据, 或者删除任意节点, 都会导致Zookeeper状态发生改变, 从而导致zxid的值增加</p>
<p><img src="http://images.zhuxingsheng.com/201903191401_941.png"></p>
<p>此外，znode还有操作权限。如果我们把以上几类属性细化，又可以得到以下属性的细节：</p>
<ul>
<li>czxid：创建节点的事务的zxid</li>
<li>mzxid：对znode最近修改的zxid</li>
<li>ctime：以距离时间原点(epoch)的毫秒数表示的znode创建时间</li>
<li>mtime：以距离时间原点(epoch)的毫秒数表示的znode最近修改时间</li>
<li>version：znode数据的修改次数</li>
<li>cversion：znode子节点修改次数</li>
<li>aversion：znode的ACL修改次数</li>
<li>ephemeralOwner：如果znode是临时节点，则指示节点所有者的会话ID；如果不是临时节点，则为零。</li>
<li>dataLength：znode数据长度。</li>
<li>numChildren：znode子节点个数。</li>
</ul>
<p>znode是由客户端创建的，它和创建它的客户端的内在联系，决定了它的存在性：</p>
<ol>
<li>PERSISTENT-持久化节点：创建这个节点的客户端在与zookeeper服务的连接断开后，这个节点也不会被删除（除非您使用API强制删除）。</li>
<li>PERSISTENT_SEQUENTIAL-持久化顺序编号节点：当客户端请求创建这个节点A后，zookeeper会根据parent-znode的zxid状态，为这个A节点编写一个全目录唯一的编号（这个编号只会一直增长）。当客户端与zookeeper服务的连接断开后，这个节点也不会被删除。</li>
<li>EPHEMERAL-临时目录节点：创建这个节点的客户端在与zookeeper服务的连接断开后，这个节点（还有涉及到的子节点）就会被删除。</li>
<li>EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点：当客户端请求创建这个节点A后，zookeeper会根据parent-znode的zxid状态，为这个A节点编写一个全目录唯一的编号（这个编号只会一直增长）。当创建这个节点的客户端与zookeeper服务的连接断开后，这个节点被删除。</li>
</ol>
<p>另外，无论是EPHEMERAL还是EPHEMERAL_SEQUENTIAL节点类型，在zookeeper的client异常终止后，节点也会被删除。</p>
<h1 id="服务的四种状态"><a href="#服务的四种状态" class="headerlink" title="服务的四种状态"></a>服务的四种状态</h1><p>服务器具有四种状态，分别是LOOKING,FOLLOWING,LEADING,OBSERVING </p>
<ul>
<li>LOOKING<br>寻找leader状态<br>当前服务器处于该状态时，它会认为当前集群中没有leader，因此需要进入leader选举状态</li>
<li>FOLLOWING<br>跟随者状态<br>表示当前服务器的角色是Follower角色 </li>
<li>LEADING<br>领导者状态<br>表示当前服务器是Leader </li>
<li>OBSERVING<br>观察者状态<br>表示当前服务器角色是Observer</li>
</ul>
<p><img src="http://images.zhuxingsheng.com/201903201659_835.png"><br><img src="http://images.zhuxingsheng.com/201903201700_506.png"></p>
<h1 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h1><p>最典型集群模式：Master&#x2F;Slave 模式（主备模式）</p>
<p>在这种模式中，通常 Master 服务器作为主服务器提供写服务，其他的 Slave 服务器从服务器通过异步复制的方式获取 Master 服务器最新的数据提供读服务</p>
<p>zookeeper都是集群形式部署的，而zk服务又分为不同角色来执行不同的任务,ZooKeeper中没有选择传统的 Master&#x2F;Slave 概念</p>
<p>而是引入了Leader、Follower 和 Observer 三种角色</p>
<p><img src="http://images.zhuxingsheng.com/201903201349_193.png"></p>
<p>在区分zk服务器角色之前，需要解释几个概念： </p>
<ul>
<li><strong>事务请求</strong><br>在zk中，那些会改变服务器状态的请求称为事务请求（创建节点、更新数据、删除节点、创建会话等等） </li>
<li><strong>非事务请求</strong><br>从zk读取数据但是不对状态进行任何修改的请求称为非事务请求</li>
</ul>
<h3 id="领导者Leader"><a href="#领导者Leader" class="headerlink" title="领导者Leader"></a>领导者Leader</h3><ol>
<li>事务请求的唯一调度和处理者，保证集群事务处理的顺序性； 	</li>
<li>集群内部各服务器的调度者</li>
<li>只有一个</li>
</ol>
<h3 id="跟随者（Follower）"><a href="#跟随者（Follower）" class="headerlink" title="跟随者（Follower）"></a>跟随者（Follower）</h3><ol>
<li>处理客户端非事务请求，转发事务请求给Leader服务器 	</li>
<li>参与事务请求Proposal的投票</li>
<li>参与Leader选举的投票</li>
</ol>
<h3 id="观察者（Observer"><a href="#观察者（Observer" class="headerlink" title="观察者（Observer):"></a>观察者（Observer):</h3><ol>
<li>Follower 和 Observer 唯一的区别在于 Observer 机器不参与 Leader 的选举过程</li>
<li>也不参与写操作的“过半写成功”策略，因此 Observer </li>
<li>机器可以在不影响写性能的情况下提升集群的读性能</li>
</ol>
<h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p><img src="http://images.zhuxingsheng.com/201903201744_259.png"></p>
<ol>
<li>在Client向Follwer发出一个写的请求</li>
<li>Follwer把请求发送给Leader</li>
<li>Leader接收到以后开始发起投票并通知Follwer进行投票</li>
<li>Follwer把投票结果发送给Leader</li>
<li>Leader将结果汇总后如果需要写入，则开始写入同时把写入操作通知给Leader，然后commit;</li>
<li>Follwer把请求结果返回给Client</li>
</ol>
<h1 id="leader选举"><a href="#leader选举" class="headerlink" title="leader选举"></a>leader选举</h1><p>选举(election)是分布式系统实践中常见的问题，通过打破节点间的对等关系，选得的leader(或叫master、coordinator)有助于实现事务原子性、提升决议效率</p>
<h2 id="为什么需要选举"><a href="#为什么需要选举" class="headerlink" title="为什么需要选举"></a>为什么需要选举</h2><p>集群本身有很多种类，如tomcat集群，集群里面每一台机器是对等的，所以其自身不存在leader之说</p>
<p>另外一类，如fastDfs，其依赖于独特的HASH算法，建立文件名和路径之间的映射关系，写操作都是通过namenode分发到各台datanode之上，算法保证了文件名的独一无二，也不存在leader的说法</p>
<p>还有memcache集群，集群里面的机器之间彼此无心跳，通过一致性hash尽可能将key值的存储分散化，降低单一memcahe服务器down机的影响。</p>
<p>还有一类是主从复制，主节点负责写，从节点负责读，提高读的性能。从节点定期通过心跳与主节点沟通，一旦主节点挂掉了，从节点马上接手主节点的任务</p>
<p>对于分布式应用，难以避免出现网络的抖动。比如，<br>主节点暂时失去响应，如瞬时负载过高，网络拥塞或者其他原因导致主节点暂时失去响应，超过响应超时时间，这个时候从节点启动，承担起leader的职责，但是原先的主节点又恢复了服务。这个时候，如果没有选举机制（不能仅仅自己宣告自己是leader，还要广而告之，让其他服务器或者客户端知道自己是leader），有可能会存在两个leader节点，导致集群发生混乱</p>
<p><strong>上图示例一下此类场景</strong></p>
<p><img src="http://images.zhuxingsheng.com/201903141616_475.png"></p>
<p>主节点出现问题，那就是单点故障</p>
<p><img src="http://images.zhuxingsheng.com/201903141619_300.png" alt="单点故障"></p>
<p>传统方式是采用一个备用节点，这个备用节点定期给当前主节点发送ping包，主节点收到ping包以后向备用节点发送回复Ack，当备用节点收到回复的时候就会认为当前主节点还活着，让他继续提供服务</p>
<p><img src="http://images.zhuxingsheng.com/201903251441_478.png"></p>
<p>当主节点挂了，这时候备用节点收不到回复了，然后他就认为主节点挂了接替他成为主节点如下图</p>
<p><img src="http://images.zhuxingsheng.com/201903251440_977.png"></p>
<p>但是这种方式就是有一个隐患，就是网络问题，来看一网络问题会造成什么后果，如下图</p>
<p><img src="http://images.zhuxingsheng.com/201903251446_99.png"></p>
<p>也就是说我们的主节点的并没有挂，只是在回复的时候网络发生故障，这样我们的备用节点同样收不到回复，就会认为主节点挂了，然后备用节点将他的Master实例启动起来，</p>
<p><strong>这样我们的分布式系统当中就有了两个主节点也就是—双Master</strong>，</p>
<p>出现Master以后我们的从节点就会将它所做的事一部分汇报给了主节点，一部分汇报给了从节点，这样服务就全乱了</p>
<h2 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h2><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>在哪些场景下需要进行leader选举</p>
<ol>
<li>服务器初始化启动</li>
<li>服务器运行期间无法和Leader保持连接</li>
</ol>
<h4 id="初始化时"><a href="#初始化时" class="headerlink" title="初始化时"></a>初始化时</h4><p>若进行Leader选举，则至少需要两台机器，这里选取3台机器组成的服务器集群为例。在集群初始化阶段，当有一台服务器Server1启动时，其单独无法进行和完成Leader选举，当第二台服务器Server2启动时，此时两台机器可以相互通信，每台机器都试图找到Leader，于是进入Leader选举过程。选举过程如下</p>
<ul>
<li>1.每个Server发出一个投票。由于是初始情况，Server1和Server2都会将自己作为Leader服务器来进行投票，每次投票会包含所推举的服务器的myid和ZXID，使用(myid, ZXID)来表示，此时Server1的投票为(1, 0)，Server2的投票为(2, 0)，然后各自将这个投票发给集群中其他机器。</li>
<li>2.接受来自各个服务器的投票。集群的每个服务器收到投票后，首先判断该投票的有效性，如检查是否是本轮投票、是否来自LOOKING状态的服务器</li>
<li>3.处理投票。针对每一个投票，服务器都需要将别人的投票和自己的投票进行PK，PK规则如下<ul>
<li>3.1.优先检查ZXID。ZXID比较大的服务器优先作为Leader</li>
<li>3.2.如果ZXID相同，那么就比较myid。myid较大的服务器作为Leader服务器</li>
</ul>
</li>
</ul>
<p>对于Server1而言，它的投票是(1, 0)，接收Server2的投票为(2, 0)，首先会比较两者的ZXID，均为0，再比较myid，此时Server2的myid最大，于是更新自己的投票为(2, 0)，然后重新投票，对于Server2而言，其无须更新自己的投票，只是再次向集群中所有机器发出上一次投票信息即可。</p>
<ul>
<li>4.统计投票。每次投票后，服务器都会统计投票信息，判断是否已经有过半机器接受到相同的投票信息，对于Server1、Server2而言，都统计出集群中已经有两台机器接受了(2, 0)的投票信息，此时便认为已经选出了Leader。</li>
<li>5.改变服务器状态。一旦确定了Leader，每个服务器就会更新自己的状态，如果是Follower，那么就变更为FOLLOWING，如果是Leader，就变更为LEADING。</li>
</ul>
<h4 id="Leader挂掉"><a href="#Leader挂掉" class="headerlink" title="Leader挂掉"></a>Leader挂掉</h4><p>在Zookeeper运行期间，Leader与非Leader服务器各司其职，即便当有非Leader服务器宕机或新加入，此时也不会影响Leader，但是一旦Leader服务器挂了，那么整个集群将暂停对外服务，进入新一轮Leader选举，其过程和启动时期的Leader选举过程基本一致。假设正在运行的有Server1、Server2、Server3三台服务器，当前Leader是Server2，若某一时刻Leader挂了，此时便开始Leader选举。选举过程如下</p>
<ul>
<li>1.变更状态。Leader挂后，余下的非Observer服务器都会讲自己的服务器状态变更为LOOKING，然后开始进入Leader选举过程</li>
<li>2.每个Server会发出一个投票。在运行期间，每个服务器上的ZXID可能不同，此时假定Server1的ZXID为123，Server3的ZXID为122；在第一轮投票中，Server1和Server3都会投自己，产生投票(1, 123)，(3, 122)，然后各自将投票发送给集群中所有机器。</li>
<li>3.接收来自各个服务器的投票。与启动时过程相同。</li>
<li>4.处理投票。与启动时过程相同，此时，Server1将会成为Leader。</li>
<li>5.统计投票。与启动时过程相同。</li>
<li>6.改变服务器的状态。与启动时过程相同</li>
</ul>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p><img src="http://images.zhuxingsheng.com/201903191356_615.png"></p>
<h4 id="理想状态"><a href="#理想状态" class="headerlink" title="理想状态"></a>理想状态</h4><p><img src="http://images.zhuxingsheng.com/201903151853_684.png"></p>
<ol>
<li>在第一轮中，按照“我最牛逼，我怕谁”的原则，每个节点都推荐它自己为集群的leader节点</li>
<li>按照我们假设的理想条件，节点S1首先收到了S2发送来的推荐者“2”，节点S1发现“2”要比它之前推荐的“1”（也就是它自己）牛。根据谁牛推荐谁的原则，“S1”清空自己的票箱，重新选举“2”（注意，此时“S1”的新票箱中已经有两票选举“2”了，一票是它自己，另外一票是”S2”，并且所有节点都是Looking状态）</li>
<li>同样的事情发生在“S2”身上：”S2”收到了”S3”发过来的推荐信息，发现“3”这个被推举者比之前自己推举的“2”要牛，于是也清空自己的票箱，发起一轮新的投票，此时“S2”选举“3”。依次类推”S3”、”S4”</li>
<li>这里要注意S5这个节点，在第一轮接受到了来源于“S1”——“S4”的推举者（一定注意，每一次接受信息，都会广播一次“我坚持推举的人”），发现“还是推荐的5最牛”，于是“我继续推举S5吧”</li>
<li>以上这个过程在整个理想的网络环境上一直持续。到了第四轮，“S1”收到了“S2”发送来的推举者“5”，发现“5”要比当前“S1”推荐的“4”要牛。所以“S1”清空了自己的票箱，重新推举“5”（发送给其他所有节点）</li>
<li>关键的第五轮来了，我们再重复一下，经过之前的选举，现在“S2”——“S5”都已经推举“5”为Leader了，而且都处于第四轮。这时他们收到了”S1”发来的新的“第五轮”投票，于是都和之前一样，做相同的一件事：清空自己的票箱，重新向其他所有节点广播自己的第五轮投票“5”</li>
<li>于是，节点X，收到了大于N &#x2F; 2 +１的选举“5”的投票，且都是第五轮投票。这样每个节点就都知道了自己的角色。，选举结束。所有将成为Follower状态的节点，向将要成为Leader的节点发起最后一次“工作是否正常”的询问。得到肯定的ack后，整个集群的工作状态就确认了</li>
</ol>
<h4 id="非理想状态"><a href="#非理想状态" class="headerlink" title="非理想状态"></a>非理想状态</h4><p>过程中出现了宕机、网络延迟、网络物理层断开等情况</p>
<p><img src="http://images.zhuxingsheng.com/201903191352_733.png"></p>
<p>在第三轮的选举过程后，“S1”,“S2”两个节点就断开了，他们的投票信息根本没有发送出去</p>
<ul>
<li>“S3”收到了“S4”,“S5”发来的投票信息，这时“S3”的票箱处于第3轮，并且发现了占大多数的投票结果：大家选举“S5”为Leader节点</li>
<li>同样的事情也发生在“S4”身上。这样“S3”,“S4”两个节点率先知道了投票结果，在最后一次询问Leader节点是否能正常工作，并得到了肯定的ACK之后，“S3”,“S4”两个节点变成了Follower状态</li>
<li>之后，无论“S3”,“S4”两个节点收到了任何节点的投票信息，都直接向源节点反馈投票结果，不会再进行投票了。</li>
<li>在投票完成后，“S1”,“S2”重新连入后，虽然他们发起了投票，但是不会再收到投票反馈了。直接根据“S3”或者“S4”发来的结果状态，变成Follower状态</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>此篇zookeeper的基础内容基本都包含了</p>
<p>了解这些基本已经入门</p>
<p>下一篇学习其中最核心的zab协议，理解原子性广播概念，以及zab的实现过程</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/hxpjava1/article/details/81003125">面试问题，请说明zookeeper的选举机制</a></p>
<p><a href="https://blog.csdn.net/yinwenjie/article/details/4761330">zookeeper选举机制</a></p>
<p><a href="http://www.cnblogs.com/leesf456/p/6107600.html">Zookeeper的Leader选举</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://www.zhuxingsheng.com/blog/restart-three-chaos.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="朱兴生">
      <meta itemprop="description" content="彪悍的人生需要书写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码农戏码">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/restart-three-chaos.html" class="post-title-link" itemprop="url">再起航三混沌</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-03-03 19:33:26" itemprop="dateCreated datePublished" datetime="2019-03-03T19:33:26+08:00">2019-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-29 15:24:30" itemprop="dateModified" datetime="2021-09-29T15:24:30+08:00">2021-09-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>再起航系列,一枚互联网菜鸟的成长历程</p>
</blockquote>
<p>春风三月，却是很多职场人的混沌时节</p>
<p>总结性文章，让人难以落笔。可能观察生活、体察自己不够细心；也许是成长缓慢，后知后觉；更可能本身就是平庸，普通人平平淡淡，没有什么轰烈可期的事情。但不管多难，终需落笔，无论什么原因，总得回顾总结</p>
<p>来到互联网行业已经两年，在这个时间节点，可能再次处于混沌</p>
<p>在第一年里，从好奇，新鲜，无知，疑惑 到 熟悉，充足；再到第二年，可能就是重复，机械，麻木，厌烦了。</p>
<p>在刚换行时，一切都是新鲜，好奇的。经过一年时间的积累，对业务已经熟悉，能够应对各种业务需求，并能很好地实践业务场景中的技术栈，自己的能力圈在扩大，给人一种很充实的感觉</p>
<p>慢慢地，从刚开始还能对技术栈的细节，深度保持一颗期待之心，陷入了各种业务需求中，毕竟是要解决问题体现价值的，不能仅仅学习新鲜事物，这也是前辈们常讲的不要抱着进大公司学习技术的心态，热爱学习的人在哪儿都能学习，并且学好</p>
<p>你也是这么被洗脑的，因此你熟悉了各种业务场景，处理各样的业务咨询以及各环境的故障，帮上下游解决问题，开始重复生活，机械操作，厌烦了，总会厌烦，也有能力厌烦，毕竟你支撑了团队，混熟了业务线上的同事，老油条诞生了，大公司的螺丝钉也铸成了</p>
<p>这些感受都是来自外界的刺激，似乎是常理的周期反应，此时需要一丝保持平静，进步的心，都会向外寻找答案，寻求机会。一切都得向外扩张</p>
<p>但不管如何向外，都会落空，不踏实，终需回归自我，向内而问。不忘初心，方得始终</p>
<p>从工作之初，有一种思想一直占据内心，那就是跟随团队，公司成长，是最夯实，也是最快的成长试。奈何，在实现中，几任老东家都走向了末路，而我也付之东流。尤其这次，完全换了行业，一切从零开始，命也，运也？</p>
<p>以前厌倦了项目总是失败，总是从头开始，总想着能有一个成功的项目，不停地迭代，走向完美。这一次终于满足了，就一个项目不停地迭代，让你迭代个够。每一次迭代，历史包袱特别大，想想都替命运着急，过去走在创新的路上，嫌弃没有积累，现在迭代，又抱怨历史包袱了，人真难伺候</p>
<p>混沌期总是迷茫，没有方向。牛人总有规划，人生规划。普通人总是在寻找方向，选择方向，而又没有方向</p>
<p>在《再起航三转行互联网》中，提到程序员分为两类：技术型和产品型</p>
<p>技术型，一直在路上，只要没有脱离技术型公司，这永远在路上，技术人不可能，也不能丢弃技术。不管老酒装新瓶，还是新酒装老瓶，都是保持与技术的距离。但也得认清自己，不可能做到技术大牛，技术领跑者。智商，经历沉淀都已经让我无法走上这条路</p>
<p>产品型，但你能跨越三十五岁魔咒吗？体力，精力方面是得向年轻人低头的。</p>
<p>那前途在何方？哪片土地是你希望的田野？</p>
<p>管理领导？但现在不在其位置，考虑学习太多理论，都是形而上学。终归要落实到形而下学上</p>
<p>路在何方呢？</p>
<p>何时拨开云雾，走出混沌！</p>
<p>可能需要未来的你给出答案</p>
<hr>
<p>现在可以没有答案，甚至说未来也没有答案，但行动不能停止，思考更不能停止</p>
<p>从第二年的开始，已经开始关注速度《再起航二成长速度》，第一年得以业务为核心，了解熟悉业务，把手头工作处理好。第二年就得把在第一年关注好奇的技术进行深入研究了，所以开始以组件为单位，一个一个了解学习，以微服务为基架，深入每一个环节</p>
<p>是的，来大公司不是学习的，老板聘用你，不是让你来学习的，但自己得知道，学习一刻都不能停，到大公司，的确不是学习的，在哪儿都能学习，主要是有一个场景，一个能更加深入层次学习的场景，好比之前的《剖析分布式锁》，在一般公司错误的写法，准确的说，不严谨的实现也能胜任，但更大业务量时，能不能胜任，需要思考，更多的时候，需要一个场景告诉你，你当下的完美，可能是个大大的残次品</p>
<p>现在不管是外部大环境，还是公司内部小环境，都不理想，尤其公司现在的体量，是不需要我的陪伴成长的，所以前方还有别的路，创业别想，成熟条件完全没有，那只能去一家与自己相匹配的公司，一起成长</p>
<p>公司不能大，也不能小。中型有成长的公司，核心业务部门，深入业务；或者基础架构，让面试造火箭，名副其实</p>
<hr>
<p>可能现在格局太小，总是以技术为一切；此篇只是总结当前的一种状态，不抱怨，不迷信，何时开悟走出混沌，尽人事，知天命，一切随缘</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://www.zhuxingsheng.com/blog/algorithm---sorting---summary.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="朱兴生">
      <meta itemprop="description" content="彪悍的人生需要书写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码农戏码">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/algorithm---sorting---summary.html" class="post-title-link" itemprop="url">算法渣-排序-总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-03-01 15:36:00" itemprop="dateCreated datePublished" datetime="2019-03-01T15:36:00+08:00">2019-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-07 21:29:17" itemprop="dateModified" datetime="2021-11-07T21:29:17+08:00">2021-11-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="http://images.zhuxingsheng.com/201810301458_422.png"></p>
<p>从第一篇<a href="http://www.zhuxingsheng.com/blog/algorithm-summary.html">《算法概要》</a>开始，到此篇已经经历了将近四个月时间，常见的基础排序已经温习完成</p>
<h1 id="内外排序"><a href="#内外排序" class="headerlink" title="内外排序"></a>内外排序</h1><p><strong>内部排序</strong>：待排序记录存放在计算机随机存储器中（说简单点，就是内存）进行的排序过程</p>
<p><strong>外部排序</strong>：待排序记录的数量很大，以致于内存不能一次容纳全部记录，所以在排序过程中需要对外存进行访问的排序过程</p>
<h2 id="衡量效率"><a href="#衡量效率" class="headerlink" title="衡量效率"></a>衡量效率</h2><p>内部排序：比较次数，也就是时间复杂度</p>
<p>外部排序：IO次数，也就是读写外存的次数</p>
<p>IO对排序的影响可以阅读<a href="http://www.zhuxingsheng.com/blog/deep-and-shallow-index.html">《深入浅出索引》</a>体会</p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p><img src="http://images.zhuxingsheng.com/201811291044_498.png" alt="排序导图"></p>
<h2 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h2><p><a href="http://www.zhuxingsheng.com/blog/algorithmic-slag-sort-bubble.html">算法渣-排序-冒泡</a></p>
<p>冒泡排序，应该是很多人会且只会的算法；两两比较交换</p>
<p>为了减小比较与交换的次数，通过双向比较(鸡尾酒排序)、设定是否交换位实现</p>
<p><a href="http://www.zhuxingsheng.com/blog/algorithmic-slag-sorting-fast.html">算法渣-排序-快速排序</a></p>
<p>快速排序，相对冒泡又改进了，都是交换，但引入了分治思想</p>
<hr>
<p><a href="http://www.zhuxingsheng.com/blog/algorithmic-slag-sorting-insertion.html">算法渣-排序-插入</a></p>
<p>插入排序，像打牌时，整理牌一样，通过比较、移动来达到排序</p>
<p><a href="http://www.zhuxingsheng.com/blog/algorithmic-slag-sorting-hill.html">算法渣-排序-希尔</a></p>
<p>希尔，相对插入做了改进，不是一步一步的移动，而是大步大步的移动</p>
<hr>
<p><a href="http://www.zhuxingsheng.com/blog/algorithmic-slag-sorting-selection.html">算法渣-排序-选择</a></p>
<p>选择，类似插入的反向操作；插入排序是边读边排，每当读入一个新的数时，目前的数组一定是排好序的。而选择排序不同，它必须是读完所有的数据之后才能开始排序的</p>
<p><a href="http://www.zhuxingsheng.com/blog/algorithmic-slag-sort-heap-sort.html">算法渣-排序-堆排序</a></p>
<p>堆排序，借助堆数据结构，构造堆结构，选取堆顶元素，不再需要遍历所有元素选择</p>
<hr>
<p><a href="http://www.zhuxingsheng.com/blog/algorithmic-slag-sort-merge-sort.html">算法渣-排序-归并排序</a></p>
<p>归并排序，也是分治思想，但与快速有些区别；归并排序是由下向上的，先处理子数组然后再合并。而快速排序正好相反，它的过程是由上向下的，先分出两个子区间，再对子区间进行排序</p>
<hr>
<p><a href="http://www.zhuxingsheng.com/blog/algorithmic-slag-sorting-cardinal-sorting.html">算法渣-排序-基数排序</a></p>
<p><a href="http://www.zhuxingsheng.com/blog/algorithmic-slag-sort-bucket-sort.html">算法渣-排序-桶排序</a></p>
<p><a href="http://www.zhuxingsheng.com/blog/algorithmic-slag-sort-count-sort.html">算法渣-排序-计数排序</a></p>
<p>线性排序算法,非基于比较的排序算法，性能很高，但都有限制才能达到线性排序的效果</p>
<p><img src="http://images.zhuxingsheng.com/201902230959_258.png"></p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>对于排序算法选择，不能单从时间复杂上看，简单算法都是O(n^2),就不考虑，只选择改进算法</p>
<h3 id="插入排序-vs-快速排序-vs-归并排序"><a href="#插入排序-vs-快速排序-vs-归并排序" class="headerlink" title="插入排序  vs 快速排序 vs 归并排序"></a>插入排序  vs 快速排序 vs 归并排序</h3><p>由下图可以看出，在输入规模小于100时，插入排序要好于归并和快速排序。在输入规模小于200时，插入排序优于归并排序。规模在30以下时，插入排序效率要比快速排序高50%以上，规模在50以下时，插入排序比归并排序效率高90%以上</p>
<p><img src="http://images.zhuxingsheng.com/201902221922_368.png"></p>
<h3 id="改进算法"><a href="#改进算法" class="headerlink" title="改进算法"></a>改进算法</h3><p>在数据量大时，使用改进算法</p>
<p><img src="http://images.zhuxingsheng.com/201902231041_416.png"></p>
<ol>
<li>就时间性能而言， 希尔排序、快速排序、树形选择排序、堆排序和归并排序都是较为先进的排序方法。耗时远小于O(N^2)级别的算法。</li>
<li>先进算法之中，快排的效率是最高的。 但其缺点十分明显：在待排序列基本有序的情况下，会蜕化成起泡排序，时间复杂度接近 O(N^2)。</li>
<li>希尔排序的性能让人有点意外，这种增量插入排序的高效性完全说明了：在基本有序序列中，直接插入排序绝对能达到令人吃惊的效率。但是希尔排序对增量的选择标准依然没有较为满意的答案，要知道增量的选取直接影响排序的效率。</li>
<li>归并排序的效率非常不错，在数据规模较大的情况下，它比希尔排序和堆排序都要好。</li>
<li>堆排序在数据规模较小的情况下还是表现不错的，但是随着规模的增大，时间代价也开始和上面两种排序拉开的距离。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的来说，并不存在“最佳”的排序算法。必须针对待排序列自身的特点来选择“良好”的算法。下面有一些指导性的意见：</p>
<ol>
<li>数据规模很小，而且待排序列基本有序的情况下，选择直接插入排序绝对是上策。不要小看它O(N^2)级别</li>
<li>数据规模不是很大，完全可以使用内存空间。而且待排序列杂乱无序(越乱越开心)，快排永远是不错的选择，当然付出log(N)的额外空间是值得的。</li>
<li>海量级别的数据，必须按块存放在外存(磁盘)中。此时的归并排序是一个比较优秀的算法</li>
</ol>
<h1 id="试题"><a href="#试题" class="headerlink" title="试题"></a>试题</h1><p>【京东】假设你只有100Mb的内存，需要对1Gb的数据进行排序，最合适的算法是（ ）</p>
<p>A. 归并排序　　B. 插入排序　　C. 快速排序　　D. 冒泡排序</p>
<blockquote>
<p>根据题目，我们可以知道，我们现有的内存限制使得我们无法把数据一次性加载到内存中，所以我们只能先加载一部分数据，对其排序后存入磁盘中。然后再加载一些数据，把它们“合并”到已排序的数据集中去，重复这个过程直到排序完成，显然最能胜任这个工作的是归并排序。</p>
</blockquote>
<p>【2016阿里巴巴校招笔试题】现有1GB数据进行排序，计算资源只有1GB内存可用，下列排序方法中最可能出现性能问题的是（ ）</p>
<p>A. 堆排序　　B. 插入排序　　C. 归并排序　　D. 快速排序　　E. 选择排序　　F. 冒泡排序</p>
<blockquote>
<p>根据题目的描述，我们能够很明确的知道这道题考察我们的是原地排序的概念，这里我们只需要选择非原地排序的占用额外空间最大的算法，显然答案是”C. 归并排序”。</p>
</blockquote>
<p>【2015阿里巴巴研发工程师笔试题】个数约为50K的数列需要进行从小到大排序，数列特征是基本逆序(多数数字从大大小，个别乱序)，以下哪种排序算法在事先不了解数列特征的情况下性能最优</p>
<p>A. 冒泡排序　　B. 改进冒泡排序　　C. 选择排序　　D. 快速排序　　E. 堆排序　　F.插入排序</p>
<blockquote>
<p>根据题目中的描述，首先我们可以排除A、B、C，因为它们的时间复杂度都是O(n^2)。接下来我们看下D选项，我们前面提到过，快速排序在最坏情况下的时间复杂度会退化至O(n^2)，F选项的插入排序在逆序数很大时性能也很差（O(n^2)）。而堆排序在最坏情况下的复杂度也为O(logn)，所以这里我们应该选择堆排序</p>
</blockquote>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://hxraid.iteye.com/blog/646760">基于比较的内部排序总结</a></p>
<p><a href="https://www.cnblogs.com/stormli/p/sort.html">常见比较排序算法的耗时测试</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://www.zhuxingsheng.com/blog/consistent-hashing-.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="朱兴生">
      <meta itemprop="description" content="彪悍的人生需要书写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码农戏码">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/consistent-hashing-.html" class="post-title-link" itemprop="url">一致性哈希</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-02-27 19:31:00" itemprop="dateCreated datePublished" datetime="2019-02-27T19:31:00+08:00">2019-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-07 21:29:17" itemprop="dateModified" datetime="2021-11-07T21:29:17+08:00">2021-11-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>图片分库存储时，每一张图片都可以定位到特定的服务器</p>
<p><img src="http://images.zhuxingsheng.com/201902271827_53.png"></p>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>上图中，假设我们查找的是”a.png”，由于有4台服务器（排除从库），因此公式为hash(a.png) % 4 &#x3D; 2 ，可知定位到了第2号服务器，这样的话就不会遍历所有的服务器，大大提升了性能！</p>
<p>一切都运行正常，再考虑如下的两种情况；</p>
<ol>
<li>一个 cache 服务器 m down 掉了（在实际应用中必须要考虑这种情况），这样所有映射到 cache m 的对象都会失效，怎么办，需要把 cache m 从 cache 中移除，这时候 cache 是 N-1 台，映射公式变成了 hash(object)%(N-1) ；</li>
<li>由于访问加重，需要添加 cache ，这时候 cache 是 N+1 台，映射公式变成了 hash(object)%(N+1) ；</li>
</ol>
<p>1 和 2 意味着什么？</p>
<p>这意味着突然之间几乎所有cache 都失效了。缓存雪崩，这是一场灾难</p>
<h1 id="一致性hash"><a href="#一致性hash" class="headerlink" title="一致性hash"></a>一致性hash</h1><p>有什么方法可以改变这个状况呢，这就是 consistent hashing</p>
<p>比如有{N0, N1, N2}三个节点，陆续有多个资源要分配到这三个节点上，如何尽可能均匀的分配到这些节点上</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>一致性哈希算法的思路为：先构造出一个长度为2^32 整数环，根据N0-3的节点名称的hash值（分布为[0,2^32 -1]）放到这个环上</p>
<p><img src="http://images.zhuxingsheng.com/201902281713_666.png"></p>
<p>整个空间按顺时针方向组织，圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2^32 -1，也就是说0点左侧的第一个点代表2^32 -1， 0和2^32 -1在零点中方向重合，我们把这个由2^32个点组成的圆环称为<strong>Hash环</strong></p>
<p>下一步将各个服务器使用Hash进行一个哈希，具体<strong>可以选择服务器的ip或主机名作为关键字进行哈</strong>希，这样每台机器就能确定其在哈希环上的位置，这里假设四台服务器使用ip地址哈希后在环空间的位置如下：</p>
<p><img src="http://images.zhuxingsheng.com/201902281721_753.png"></p>
<p>接下来使用如下算法定位数据访问到相应服务器：<strong>将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器！</strong></p>
<p>例如我们有Object A、Object B、Object C、Object D四个数据对象，经过哈希计算后，在环空间上的位置如下： </p>
<p><img src="http://images.zhuxingsheng.com/201902281729_75.png"></p>
<p>根据一致性Hash算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上</p>
<h2 id="容错性"><a href="#容错性" class="headerlink" title="容错性"></a>容错性</h2><p>如果一个节点宕机了，会引起系统故障吗？</p>
<p><img src="http://images.zhuxingsheng.com/201902281853_789.png"></p>
<p>如上图，Node C不幸宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。一般的，在一致性Hash算法中，如果一台服务器不可用，<strong>则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据</strong>，其它不会受到影响</p>
<h2 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h2><p>如果在系统中增加一台服务器Node X</p>
<p><img src="http://images.zhuxingsheng.com/201902281900_632.png"></p>
<p>此时对象Object A、B、D不受影响，只有对象C需要重定位到新的Node X ！一般的，在一致性Hash算法中，如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它数据也不会受到影响</p>
<p><strong>综上所述，一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性</strong>。</p>
<h2 id="数据倾斜"><a href="#数据倾斜" class="headerlink" title="数据倾斜"></a>数据倾斜</h2><p>一致性Hash算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜（被缓存的对象大部分集中缓存在某一台服务器上）问题，例如系统中只有两台服务器，其环分布如下： </p>
<p><img src="http://images.zhuxingsheng.com/201902281901_404.png"></p>
<p>此时必然造成大量数据集中到Node A上，而只有极少量会定位到Node B上</p>
<p>然而，这又会造成一个“雪崩”的情况，即A节点由于承担了B节点的数据，所以A节点的负载会变高，A节点很容易也宕机，这样依次下去，这样造成整个集群都挂了</p>
<h2 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h2><blockquote>
<p>计算机的任何问题都可以通过增加一个虚拟层来解决</p>
</blockquote>
<p>解决上述数据倾斜问题，也可能通过使用虚拟层的手段：将每台物理缓存服务器虚拟为一组虚拟缓存服务器，将虚拟服务器的hash值放置在hash环上，Key在环上先找到虚拟服务器节点，再得到物理服务器的信息</p>
<p>例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点： </p>
<p><img src="http://images.zhuxingsheng.com/201903011045_472.png"></p>
<p>同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到Node A上。这样就解决了服务节点少时数据倾斜的问题</p>
<p>那么在实践中，一台物理服务器虚拟为多少个虚拟服务器节点合适呢？太多会影响性能，太少又会导致负载不均衡，一般说来，经验值是150，当然根据集群规模和负载均衡的精度需求，这个值应该根据具体情况具体对待</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>判定哈希算法好坏的四个定义：</p>
<ol>
<li><strong>平衡性(Balance)</strong>：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件</li>
<li><strong>单调性(Monotonicity)</strong>：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区</li>
<li><strong>分散性(Spread)</strong>：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性</li>
<li><strong>负载(Load)</strong>：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷</li>
</ol>
<p>在具体实现时，主要考虑点选择适合的数据结构构造hash环</p>
<p>此数据结构的特点：插入与删除性能、快速找到特定元素的下一位</p>
<p>常见算法结构可以有回顾：</p>
<p><a href="http://www.zhuxingsheng.com/blog/algorithmic-slag-sorting-summary.html">《一篇解决排序算法》</a></p>
<p><a href="http://www.zhuxingsheng.com/blog/tree-overview.html">《树结构概述》</a></p>
<p>从时间复杂度方面选择，使用平衡二叉树数据结构，可以使得查找的时间复杂度降低为O(logN)</p>
<p>使用java，以TreeMap为例，TreeMap本身还提供了一个<strong>tailMap</strong>(K fromKey)方法，支持从红黑树中查找比fromKey大的值的集合，但并不需要遍历整个数据结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.SortedMap;</span><br><span class="line">import java.util.TreeMap;</span><br><span class="line"></span><br><span class="line">public class ConsistentHash&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line"> private final HashFunction hashFunction;</span><br><span class="line"> private final int numberOfReplicas;</span><br><span class="line"> private final SortedMap&lt;Integer, T&gt; circle = new TreeMap&lt;Integer, T&gt;();</span><br><span class="line"></span><br><span class="line"> public ConsistentHash(HashFunction hashFunction, int numberOfReplicas,</span><br><span class="line">     Collection&lt;T&gt; nodes) &#123;</span><br><span class="line">   this.hashFunction = hashFunction;</span><br><span class="line">   this.numberOfReplicas = numberOfReplicas;</span><br><span class="line"></span><br><span class="line">   for (T node : nodes) &#123;</span><br><span class="line">     add(node);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public void add(T node) &#123;</span><br><span class="line">   for (int i = 0; i &lt; numberOfReplicas; i++) &#123;</span><br><span class="line">     circle.put(hashFunction.hash(node.toString() + i), node);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public void remove(T node) &#123;</span><br><span class="line">   for (int i = 0; i &lt; numberOfReplicas; i++) &#123;</span><br><span class="line">     circle.remove(hashFunction.hash(node.toString() + i));</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public T get(Object key) &#123;</span><br><span class="line">   if (circle.isEmpty()) &#123;</span><br><span class="line">     return null;</span><br><span class="line">   &#125;</span><br><span class="line">   int hash = hashFunction.hash(key);</span><br><span class="line">   if (!circle.containsKey(hash)) &#123;</span><br><span class="line">     SortedMap&lt;Integer, T&gt; tailMap = circle.tailMap(hash);</span><br><span class="line">     hash = tailMap.isEmpty() ? circle.firstKey() : tailMap.firstKey();</span><br><span class="line">   &#125;</span><br><span class="line">   return circle.get(hash);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="dubbo实现"><a href="#dubbo实现" class="headerlink" title="dubbo实现"></a>dubbo实现</h2><p>理解完理论，再扒一下工业级产品的运用，dubbo负载均衡策略之一ConsistentHashLoadBalance</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private final TreeMap&lt;Long, Invoker&lt;T&gt;&gt; virtualInvokers;</span><br><span class="line"></span><br><span class="line">ConsistentHashSelector(List&lt;Invoker&lt;T&gt;&gt; invokers, String methodName, int identityHashCode) &#123;</span><br><span class="line">    this.virtualInvokers = new TreeMap&lt;Long, Invoker&lt;T&gt;&gt;();</span><br><span class="line">    this.identityHashCode = identityHashCode;</span><br><span class="line">    URL url = invokers.get(0).getUrl();</span><br><span class="line">    this.replicaNumber = url.getMethodParameter(methodName, &quot;hash.nodes&quot;, 160);</span><br><span class="line">    String[] index = Constants.COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, &quot;hash.arguments&quot;, &quot;0&quot;));</span><br><span class="line">    argumentIndex = new int[index.length];</span><br><span class="line">    for (int i = 0; i &lt; index.length; i++) &#123;</span><br><span class="line">        argumentIndex[i] = Integer.parseInt(index[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    for (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">        String address = invoker.getUrl().getAddress();</span><br><span class="line">        for (int i = 0; i &lt; replicaNumber / 4; i++) &#123;</span><br><span class="line">            byte[] digest = md5(address + i);</span><br><span class="line">            for (int h = 0; h &lt; 4; h++) &#123;</span><br><span class="line">                long m = hash(digest, h);</span><br><span class="line">                virtualInvokers.put(m, invoker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体思想是一样的，虚拟节点+TreeMap,但实现得更精致，使用MD5加密KEY，更加平衡性，整体的思路解释：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//对所有节点，生成nCopies个虚拟结点  </span><br><span class="line">for(Node node : nodes) &#123;  </span><br><span class="line">    //每四个虚拟结点为一组，为什么这样？下面会说到  </span><br><span class="line">    for(int i=0; i&lt;nCopies / 4; i++) &#123;  </span><br><span class="line">        //getKeyForNode方法为这组虚拟结点得到惟一名称  </span><br><span class="line">        byte[] digest=HashAlgorithm.computeMd5(getKeyForNode(node, i));  </span><br><span class="line">    /** Md5是一个16字节长度的数组，将16字节的数组每四个字节一组，分别对应一个虚拟结点，这就是为什么上面把虚拟结点四个划分一组的原因*/  </span><br><span class="line">        for(int h=0;h&lt;4;h++) &#123;  </span><br><span class="line">          //对于每四个字节，组成一个long值数值，做为这个虚拟节点的在环中的惟一key</span><br><span class="line">          //结果转换为long类，这是因为生成的结果是一个32位数，若用int保存可能会产生负数。而一致性hash生成的逻辑环其hashCode的范围是在 0 - MAX_VALUE之间。因此为正整数，所以这里要强制转换为long类型，避免出现负数。</span><br><span class="line">            Long k = ((long)(digest[3+h*4]&amp;0xFF) &lt;&lt; 24)  </span><br><span class="line">                | ((long)(digest[2+h*4]&amp;0xFF) &lt;&lt; 16)  </span><br><span class="line">                | ((long)(digest[1+h*4]&amp;0xFF) &lt;&lt; 8)  </span><br><span class="line">                | (digest[h*4]&amp;0xFF);  </span><br><span class="line">            allNodes.put(k, node);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><blockquote>
<p>为什么hash一致性的数据空间范围是2^32次方？</p>
</blockquote>
<p>这个问题有两种答案，一是技术限制、一是实际场景：</p>
<ol>
<li>因为，java中int的最大值是2^31-1最小值是-2^31,2^32刚好是无符号整形的最大值</li>
<li>因为一致性hash算法是来做服务器的负载均衡，而服务器的IP地址是32位，所以是2^32-1次方的数值空间</li>
</ol>
<blockquote>
<p>进一步追尾基础，为什么java中int的最大值是2^31-1最小值是-2^31？</p>
</blockquote>
<p>因为，int的最大值最小值范围设定是因为一个int占4个字节，一个字节占8位，二进制中刚好是32位</p>
<p>根据算法特性，一致性hash是最好的选择吗？</p>
<p>下一篇介绍另一种实现google maglev hashing算法</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《大型网站技术架构》</p>
<p>对一致性Hash算法，Java代码实现的深入研究</p>
<p><a href="https://stackoverflow.com/questions/7111256/in-voldemort-why-does-the-hash-ring-only-extend-to-231-1">为什么hash环是32位</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/10/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/blog/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/16/">16</a><a class="extend next" rel="next" href="/blog/page/12/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">朱兴生</p>
  <div class="site-description" itemprop="description">彪悍的人生需要书写</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
        
          <span class="site-state-item-count">160</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">朱兴生</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
