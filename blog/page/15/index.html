<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 8.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.zhuxingsheng.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="彪悍的人生需要书写">
<meta property="og:type" content="website">
<meta property="og:title" content="码农戏码">
<meta property="og:url" content="http://www.zhuxingsheng.com/blog/page/15/index.html">
<meta property="og:site_name" content="码农戏码">
<meta property="og:description" content="彪悍的人生需要书写">
<meta property="og:locale">
<meta property="article:author" content="朱兴生">
<meta property="article:tag" content="DDD,DDD分层,SOLID,DIP,DDD依赖,领域驱动开，binding,微服务，Istio,service mesh,dapr,架构,DDD ACL,motain源码,spring源码,游戏开发,源码分析,java互联网">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://www.zhuxingsheng.com/blog/page/15/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>码农戏码</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">码农戏码</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">新生代农民工的自我修养</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog" rel="section"><i class="home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives" rel="section"><i class="archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags" rel="section"><i class="tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about" rel="section"><i class="user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-在线工具">

    <a href="/tools" rel="section"><i class="gavel fa-fw"></i>在线工具</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://www.zhuxingsheng.com/blog/is-active-gc-required.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="朱兴生">
      <meta itemprop="description" content="彪悍的人生需要书写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码农戏码">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/is-active-gc-required.html" class="post-title-link" itemprop="url">主动GC是否需要</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-07-13 13:17:00" itemprop="dateCreated datePublished" datetime="2018-07-13T13:17:00+08:00">2018-07-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-07 21:29:17" itemprop="dateModified" datetime="2021-11-07T21:29:17+08:00">2021-11-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>看一段线上的gc日志，这是一段CMS完整步骤的日志，对于GC日志格式，不了解的可以再温习一下<a href="http://www.zhuxingsheng.com/blog/gc-and-jvm-parameters.html">《GC及JVM参数》</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">2017-07-18T21:28:41.422+0800: 11941915.242: [GC (CMS Initial Mark) [1 CMS-initial-mark: 786446K(1048576K)] 789098K(1992320K), 0.2623622 secs] [Times: user=0.00 sys=0.00, real=0.26 secs] </span><br><span class="line">2017-07-18T21:28:41.684+0800: 11941915.505: Total time for which application threads were stopped: 0.2630097 seconds, Stopping threads took: 0.0000587 seconds</span><br><span class="line">2017-07-18T21:28:41.685+0800: 11941915.505: [CMS-concurrent-mark-start]</span><br><span class="line">2017-07-18T21:29:02.443+0800: 11941936.263: [CMS-concurrent-mark: 20.758/20.758 secs] [Times: user=3.22 sys=1.67, real=20.75 secs] </span><br><span class="line">2017-07-18T21:29:02.443+0800: 11941936.263: [CMS-concurrent-preclean-start]</span><br><span class="line">2017-07-18T21:29:02.502+0800: 11941936.322: [CMS-concurrent-preclean: 0.059/0.059 secs] [Times: user=0.02 sys=0.01, real=0.06 secs] </span><br><span class="line">2017-07-18T21:29:02.502+0800: 11941936.322: [CMS-concurrent-abortable-preclean-start]</span><br><span class="line"> CMS: abort preclean due to time 2017-07-18T21:29:07.600+0800: 11941941.420: [CMS-concurrent-abortable-preclean: 0.889/5.098 secs] [Times: user=1.72 sys=0.31, real=5.10 secs] </span><br><span class="line">2017-07-18T21:29:07.602+0800: 11941941.422: Application time: 25.9175914 seconds</span><br><span class="line">2017-07-18T21:29:07.603+0800: 11941941.423: [GC (CMS Final Remark) [YG occupancy: 491182 K (943744 K)]</span><br><span class="line">2017-07-18T21:29:07.603+0800: 11941941.423: [Rescan (parallel) , 0.0654053 secs]</span><br><span class="line">2017-07-18T21:29:07.668+0800: 11941941.488: [weak refs processing, 0.6491578 secs]</span><br><span class="line">2017-07-18T21:29:08.317+0800: 11941942.138: [class unloading, 4.2229435 secs]</span><br><span class="line">2017-07-18T21:29:12.540+0800: 11941946.361: [scrub symbol table, 0.0536739 secs]</span><br><span class="line">2017-07-18T21:29:12.594+0800: 11941946.414: [scrub string table, 0.0009992 secs][1 CMS-remark: 786446K(1048576K)] 1277629K(1992320K), 5.0003976 secs] [Times: user=0.96 sys=0.01, real=5.00 secs] </span><br><span class="line">2017-07-18T21:29:12.603+0800: 11941946.423: Total time for which application threads were stopped: 5.0011973 seconds, Stopping threads took: 0.0000483 seconds</span><br></pre></td></tr></table></figure>
<p>对应着七个步骤： </p>
<ol>
<li>初始标记(CMS-initial-mark) ,会导致swt； </li>
<li>并发标记(CMS-concurrent-mark)，与用户线程同时运行； </li>
<li>预清理（CMS-concurrent-preclean），与用户线程同时运行； </li>
<li>可被终止的预清理（CMS-concurrent-abortable-preclean） 与用户线程同时运行； </li>
<li>重新标记(CMS-remark) ，会导致swt； </li>
<li>并发清除(CMS-concurrent-sweep)，与用户线程同时运行； </li>
<li>并发重置状态等待下次CMS的触发(CMS-concurrent-reset)，与用户线程同时运行；</li>
</ol>
<p>通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Times: user=0.96 sys=0.01, real=5.00 secs]</span><br></pre></td></tr></table></figure>
<p>看出STW了5s,对于一个单台1万QPS的系统来讲，那5s就影响了上万次服务，这显示然达不到高可用的要求</p>
<p>通过对user,sys,real的对比，user+sys的时间远远小于real的值，这种情况说明停顿的时间并不是消耗在cpu执行上了，不是cpu那就是io导致的了</p>
<p>此时，可以通过sar命令查看一下</p>
<p>sar（System Activity Reporter系统活动情况报告）是目前 Linux 上最为全面的系统性能分析工具之一，可以从多方面对系统的活动进行报告，包括：文件的读写情况、系统调用的使用情况、磁盘I&#x2F;O、CPU效率、内存使用状况、进程活动及IPC有关的活动等</p>
<p><img src="http://images.zhuxingsheng.com/201807191007_977.png" alt="sar -B"></p>
<p>sar -B 输出说明：</p>
<p>输出项说明：</p>
<p>pgpgin&#x2F;s：表示每秒从磁盘或SWAP置换到内存的字节数(KB)</p>
<p>pgpgout&#x2F;s：表示每秒从内存置换到磁盘或SWAP的字节数(KB)</p>
<p>fault&#x2F;s：每秒钟系统产生的缺页数,即主缺页与次缺页之和(major + minor)</p>
<p>majflt&#x2F;s：每秒钟产生的主缺页数.</p>
<p>pgfree&#x2F;s：每秒被放入空闲队列中的页个数</p>
<p>pgscank&#x2F;s：每秒被kswapd扫描的页个数</p>
<p>pgscand&#x2F;s：每秒直接被扫描的页个数</p>
<p>pgsteal&#x2F;s：每秒钟从cache中被清除来满足内存需要的页个数</p>
<p>%vmeff：每秒清除的页(pgsteal)占总扫描页(pgscank+pgscand)的百分比</p>
<h2 id="SWAP"><a href="#SWAP" class="headerlink" title="SWAP"></a>SWAP</h2><p>可以看到大量的pgin，这儿就不得不再普及一下linux的swap</p>
<blockquote>
<p>Linux divides its physical RAM (random access memory) into chucks of memory called pages. Swapping is the process whereby a page of memory is copied to the preconfigured space on the hard disk, called swap space, to free up that page of memory. The combined sizes of the physical memory and the swap space is the amount of virtual memory available.</p>
</blockquote>
<blockquote>
<p>Swap space in Linux is used when the amount of physical memory (RAM) is full. If the system needs more memory resources and the RAM is full, inactive pages in memory are moved to the swap space. While swap space can help machines with a small amount of RAM, it should not be considered a replacement for more RAM. Swap space is located on hard drives, which have a slower access time than physical memory.Swap space can be a dedicated swap partition (recommended), a swap file, or a combination of swap partitions and swap files.</p>
</blockquote>
<blockquote>
<p>Linux内核为了提高读写效率与速度，会将文件在内存中进行缓存，这部分内存就是Cache Memory(缓存内存)。即使你的程序运行结束后，Cache Memory也不会自动释放。这就会导致你在Linux系统中程序频繁读写文件后，你会发现可用物理内存变少。当系统的物理内存不够用的时候，就需要将物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap空间中，等到那些程序要运行时，再从Swap分区中恢复保存的数据到内存中。这样，系统总是在物理内存不够时，才进行Swap交换。</p>
</blockquote>
<h2 id="swap-vs-虚拟内存"><a href="#swap-vs-虚拟内存" class="headerlink" title="swap vs 虚拟内存"></a>swap vs 虚拟内存</h2><p>windows：虚拟内存</p>
<p>linux：swap分区</p>
<p>windows即使物理内存没有用完也会去用到虚拟内存，而Linux不一样 Linux只有当物理内存用完的时候才会去动用虚拟内存（即swap分区）</p>
<p>swap类似于windows的虚拟内存，不同之处在于，Windows可以设置在windows的任何盘符下面，默认是在C盘，可以和系统文件放在一个分区里。而linux则是独立占用一个分区，方便由于内存需求不够的情况下，把一部分内容放在swap分区里，待内存有空余的情况下再继续执行，也称之为交换分区，交换空间是其中的部分<br>windows的虚拟内存是电脑自动设置的</p>
<h2 id="为什么会停顿这么长时间呢？"><a href="#为什么会停顿这么长时间呢？" class="headerlink" title="为什么会停顿这么长时间呢？"></a>为什么会停顿这么长时间呢？</h2><ol>
<li>堆内存分配多大，当gc时，的确需要很长时间</li>
<li>内存不够用时，使用了swap,在gc时，需要从swap加载到内存，耗时</li>
</ol>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>对于上面的原因，可以找出对应的方案：</p>
<ol>
<li>分配小点，通过小而快的方式达到快速gc</li>
<li>定期检测old gen使用情况，当快要到达临界值时候(old gen使用率大于50%)主动执行cms gc</li>
</ol>
<p>主动Gc可能会影响服务，所以可能需要服务先下线，gc完，再上线</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/zqz_zqz/article/details/70568819">CMS垃圾回收器详解</a></p>
<p><a href="http://plumbr.io/handbook/garbage-collection-algorithms-implementations">GC Algorithms: Implementations</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://www.zhuxingsheng.com/blog/volatile-synchronized--cas.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="朱兴生">
      <meta itemprop="description" content="彪悍的人生需要书写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码农戏码">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/volatile-synchronized--cas.html" class="post-title-link" itemprop="url">volatile synchronized  cas</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-06-26 10:43:00" itemprop="dateCreated datePublished" datetime="2018-06-26T10:43:00+08:00">2018-06-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-07 21:29:17" itemprop="dateModified" datetime="2021-11-07T21:29:17+08:00">2021-11-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前写了《熔断》，以及其中使用的《计数器算法》；本来是要接着再写不通过定时器清理计数环的计数器算法，看了下我司亿级网关的计数器，百行的代码，但却是满满bug。不得穿插一下并发的基础知识</p>
<p>处理并发，最基本的元件就这三样</p>
<ol>
<li>synchronized 这个关键字不必讲，从开始多线程，它就进入你的视线</li>
<li>volatile 在jdk5之后大放异彩</li>
<li>cas 在J.U.C中大量使用，他与volatile组合是J.U.C的基石</li>
</ol>
<h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p>谈到多线程，不得不说的JMM，这儿只做简单阐述</p>
<p>在jsr-133中是这么定义的</p>
<blockquote>
<p>A memory model describes, given a program and an execution trace of that program,<br>whether the execution trace is a legal execution of the program. For the Java programming language,<br>the memory model works by examining each read in an execution trace and checking that the write observed by that read is valid according to certain rules.</p>
</blockquote>
<p>也就是说<strong>一个内存模型描述了一个给定的程序和和它的执行路径是否一个合法的执行路径</strong>。对于java序言来说，内存模型通过考察在程序执行路径中每一个读操作，根据特定的规则，检查写操作对应的读操作是否能是有效的。<br>java内存模型只是定义了一个规范，具体的实现可以是根据实际情况自由实现的。但是实现要满足java内存模型定义的规范。</p>
<p>从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读&#x2F;写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java内存模型的抽象示意图如下：</p>
<p><img src="http://images.zhuxingsheng.com/201806261839_931.png?imageView2/0/q/75%7Cwatermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2%7Cimageslim"></p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>由于java的内存模型中有工作内存和主内存之分，所以可能会有两种问题：</p>
<p>（1）线程可能在工作内存中更改变量的值，而没有及时写回到主内存，其他线程从主内存读取的数据仍然是老数据</p>
<p>（2）线程在工作内存中更改了变量的值，写回主内存了，但是其他线程之前也读取了这个变量的值，这样其他线程的工作内存中，此变量的值没有被及时更新。</p>
<p>为了解决这个问题，可以使用同步机制，也可以把变量声明为volatile，</p>
<p><strong>JMM:对volatile字段的写入操作happens-before于每一个后续的同一个字段的读操作</strong></p>
<p>如何理解呢？</p>
<p>（1）每次对变量的修改，都会引起处理器缓存（工作内存）写回到主内存。</p>
<p>（2）一个工作内存回写到主内存会导致其他线程的处理器缓存（工作内存）无效。</p>
<p>基于以上两点，如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。</p>
<h3 id="volatile原子性"><a href="#volatile原子性" class="headerlink" title="volatile原子性"></a>volatile原子性</h3><p>Java内存模型要求lock, unlock, read, load, assign, use, write这个8个操作都具有原子性，但是同时又对64位的数据类型(long&amp;double)给了一个相对宽松的规定，就是允许虚拟机将没有被volatile参数修饰的64位数据类型的<strong>读写划分为两次32位的操作来进行</strong>，即允许虚拟机将load, store, read, write这个4个操作实现为非原子的。</p>
<p>当线程把主存中的long&#x2F;double类型的值读到线程内存中时，可能是两次32位值的写操作，显而易见，如果几个线程同时操作，那么就可能会出现高低2个32位值出错的情况发生。</p>
<p>java虚拟机规范（jvm spec）中，规定了声明为volatile的long和double变量的get和set操作是原子的</p>
<blockquote>
<p>Writes and reads of volatile long and double values are always atomic.<br>Writes to and reads of references are always atomic, regardless of whether they are implemented as 32-bit or 64-bit values.</p>
</blockquote>
<p>关于volatile变量的使用建议：多线程环境下需要共享的变量采用volatile声明；如果使用了同步块或者是常量，则没有必要使用volatile。</p>
<p><em>当然，需要注意的是，这儿的原子性，与i++不是一个概念</em></p>
<p><strong>前者是单个变量写，后者是复合操作</strong></p>
<h3 id="volatile实现"><a href="#volatile实现" class="headerlink" title="volatile实现"></a>volatile实现</h3><p>volatile是如何做到可见性的呢？</p>
<p>来段代码看下，定义两个变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private int i;</span><br><span class="line"></span><br><span class="line">private volatile int j;</span><br></pre></td></tr></table></figure>

<p>通过java -verbos XX.class 查看一下生成的编译码</p>
<p><img src="http://images.zhuxingsheng.com/201806281746_198.png?imageView2/0/q/75%7Cwatermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2%7Cimageslim"></p>
<p>发现唯一的区别就在于volatile多了<strong>ACC_VOLATILE</strong>标识</p>
<p>通过查看JVM源码，可以看到如下代码</p>
<p><img src="http://images.zhuxingsheng.com/201807021342_940.png?imageView2/0/q/75%7Cwatermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2%7Cimageslim"></p>
<p>这就是大名鼎鼎的“内存屏障”的抽象</p>
<h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><p><strong>内存屏障Memory Barriers</strong>：是一组处理器指令，用于实现对内存操作的顺序限制。</p>
<p>Memory barrier 能够让 CPU 或编译器在内存访问上有序。一个 Memory barrier 之前的内存访问操作必定先于其之后的完成。</p>
<p><strong>内存屏障有两个能力</strong>：</p>
<ol>
<li>阻止屏障两边的指令重排序</li>
<li>强制把写缓冲区&#x2F;高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效</li>
</ol>
<p><strong>Memory barrier 分类</strong>：</p>
<ol>
<li>编译器 barrier</li>
<li>CPU Memory barrier</li>
</ol>
<p><strong>内存屏障列表</strong>：</p>
<p><img src="http://images.zhuxingsheng.com/201807021531_692.png?imageView2/0/q/75%7Cwatermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2%7Cimageslim"></p>
<p><strong>JMM针对编译器制定的volatile重排序规则表</strong>：<br><img src="http://images.zhuxingsheng.com/201807021457_96.png?imageView2/0/q/75%7Cwatermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2%7Cimageslim"></p>
<p>举例来说，第三行最后一个单元格的意思是：在程序顺序中，当第一个操作为普通变量的读或写时，如果第二个操作为volatile写，则编译器不能重排序这两个操作。</p>
<p>从上表我们可以看出：</p>
<p>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后</p>
<p>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前</p>
<p>当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。</p>
<p><strong>volatile的内存语义的（JVM）实现策略</strong>：</p>
<ol>
<li>在每个volatile写操作前，会插入一个StoreStore屏障；</li>
<li>在每个volatile写操作后，会插入一个storeload屏障；</li>
<li>在每个volatile读操作后，插入一个LoadLoad，一个LoadStore屏障</li>
</ol>
<p><img src="http://images.zhuxingsheng.com/201807021506_541.png?imageView2/0/q/75%7Cwatermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2%7Cimageslim"><br>上图中的StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作已经对任意处理器可见了。这是因为StoreStore屏障将保障上面所有的普通写在volatile写之前刷新到主内存。</p>
<p>这里比较有意思的是volatile写后面的StoreLoad屏障。这个屏障的作用是避免volatile写与后面可能有的volatile读&#x2F;写操作重排序。因为编译器常常无法准确判断在一个volatile写的后面，是否需要插入一个StoreLoad屏障（比如，一个volatile写之后方法立即return）。为了保证能正确实现volatile的内存语义，JMM在这里采取了保守策略：在每个volatile写的后面或在每个volatile读的前面插入一个StoreLoad屏障。从整体执行效率的角度考虑，JMM选择了在每个volatile写的后面插入一个StoreLoad屏障。因为volatile写-读内存语义的常见使用模式是：一个写线程写volatile变量，多个读线程读同一个volatile变量。当读线程的数量大大超过写线程时，选择在volatile写之后插入StoreLoad屏障将带来可观的执行效率的提升。从这里我们可以看到JMM在实现上的一个特点：首先确保正确性，然后再去追求执行效率。</p>
<p><img src="http://images.zhuxingsheng.com/201807021516_753.png?imageView2/0/q/75%7Cwatermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2%7Cimageslim"></p>
<p>上图中的LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序。LoadStore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序。</p>
<h4 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h4><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p>
<ol>
<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序。由于处理器使用缓存和读&#x2F;写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。<br>从java源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</li>
</ol>
<p><img src="http://images.zhuxingsheng.com/201807021529_836.png?imageView2/0/q/75%7Cwatermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2%7Cimageslim"></p>
<p>上述的1属于编译器重排序，2和3属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求java编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel称之为memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。<br>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p>
<p>比如现在有一段代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = 1; //代码1</span><br><span class="line">b = 1; //代码2</span><br></pre></td></tr></table></figure>
<p>编译器和处理为了提高并行度，可以将代码1和2调整顺序，即先执行代码2和代码1</p>
<p>但是若是其他情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = 1; //代码3</span><br><span class="line">b = a; //代码4</span><br></pre></td></tr></table></figure>
<p>这种情况因为代码3和4存在数据依赖，存在hanpens-before关系，处理器和编译器会遵守 as-if-serial原则，不会调整顺序。</p>
<p><strong>as-if-serial原则</strong>：不管怎么重排序，单线程程序的执行结果不能发生改变。编译器、Runtime和处理器也是如此。这个语义相当于把单线程保护起来了，所以即使编译器和处理器对指令序列进行了重排序，我们也会认为程序指令并没有发生重排序</p>
<p><strong>hanpens-before</strong>：指前一个操作对后一个操作可见，并不是前一个操作必须在后一个操作之前执行。</p>
<p>当存在控制依赖时，编译器和处理器会采取猜测执行机制来提高并行度，如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = 1;</span><br><span class="line">flag = true ;</span><br><span class="line">if(flag)&#123; //代码5</span><br><span class="line">    a * = 2; //代码6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码5和6不存在数据依赖，可能会重排，处理器和编译器会先将代码6的执行结果放在缓冲区，等执行代码5之后，将缓冲区的结果直接赋值给a</p>
<p><strong>从JSR-133开始，volatile写-读建立的happens before关系</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class VolatileExample &#123;</span><br><span class="line">    int a = 0;</span><br><span class="line">    volatile boolean flag = false;</span><br><span class="line"> </span><br><span class="line">    public void writer() &#123;</span><br><span class="line">        a = 1;                   //1</span><br><span class="line">        flag = true;               //2</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void reader() &#123;</span><br><span class="line">        if (flag) &#123;                //3</span><br><span class="line">            int i =  a;           //4</span><br><span class="line">            ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设线程A执行writer()方法之后，线程B执行reader()方法。根据happens before规则，这个过程建立的happens before 关系可以分为两类：<br>·     根据程序次序规则，1 happens before 2; 3 happens before 4。<br>·     根据volatile规则，2 happens before 3。<br>·     根据happens before 的传递性规则，1 happens before 4。<br>上述happens before 关系的图形化表现形式如下：</p>
<p><img src="http://images.zhuxingsheng.com/201807031633_466.png?imageView2/0/q/75%7Cwatermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2%7Cimageslim"></p>
<p>在上图中，每一个箭头链接的两个节点，代表了一个happens before 关系。黑色箭头表示程序顺序规则；橙色箭头表示volatile规则；蓝色箭头表示组合这些规则后提供的happens before保证。</p>
<p>这里A线程写一个volatile变量后，B线程读同一个volatile变量。<br>A线程在写volatile变量之前所有可见的共享变量，在B线程读同一个volatile变量后，将立即变得对B线程可见。</p>
<p>在JSR-133之前的旧Java内存模型中，虽然不允许volatile变量之间重排序，但旧的Java内存模型允许volatile变量与普通变量之间重排序。<br>在旧的内存模型中，VolatileExample示例程序可能被重排序成下列时序来执行：</p>
<p><img src="http://images.zhuxingsheng.com/201807031634_763.png?imageView2/0/q/75%7Cwatermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2%7Cimageslim"></p>
<p>在旧的内存模型中，当1和2之间没有数据依赖关系时，1和2之间就可能被重排序（3和4类似）。其结果就是：读线程B执行4时，不一定能看到写线程A在执行1时对共享变量的修改。</p>
<p>因此在旧的内存模型中 ，volatile的写-读没有监视器的释放-获取具有的内存语义。</p>
<p>为了提供一种比监视器锁更轻量级的线程之间通信的机制，JSR-133专家组决定增强</p>
<p>volatile的内存语义：严格限制编译器和处理器对volatile变量与普通变量的重排序，确保volatile的写-读和监视器的释放-获取一样，具有相同的内存语义。</p>
<p>从编译器重排序规则和处理器内存屏障插入策略来看，只要volatile变量与普通变量之间的重排序可能会破坏volatile 的内存语意，这种重排序就会被编译器重排序规则和处理器内存屏障插入策略禁止。</p>
<p>由于volatile仅仅保证对单个volatile变量的读&#x2F;写具有原子性，而监视器锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。在功能上，监视器锁比volatile更强大；在可伸缩性和执行性能上，volatile更有优势。如果读者想在程序中用volatile代替监视器锁，请一定谨慎。</p>
<h4 id="volatile示例"><a href="#volatile示例" class="headerlink" title="volatile示例"></a>volatile示例</h4><p>还是不太明白，直接跑段代码，区别一下flag带与不带volatile修饰的情况，就很明显了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class TestVolatile &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        ThreadDemo td = new ThreadDemo();</span><br><span class="line">        new Thread(td).start();</span><br><span class="line"></span><br><span class="line">        while(true)&#123;</span><br><span class="line">            if(td.getFlag())&#123;</span><br><span class="line">                System.out.println(&quot;主线程flag:&quot; + td.getFlag());</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ThreadDemo implements Runnable&#123;</span><br><span class="line">    //共享变量</span><br><span class="line">    private volatile   boolean  flag = false;</span><br><span class="line"></span><br><span class="line">    public boolean getFlag() &#123;</span><br><span class="line">        return flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setFlag(boolean flag) &#123;</span><br><span class="line">        this.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(200);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        flag = true;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;其他线程flag=&quot; + getFlag());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>在多线程并发编程中Synchronized一直是元老级角色，很多人都会称呼它为重量级锁</p>
<p>Java SE1.6为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率</p>
<p><img src="http://images.zhuxingsheng.com/201807031406_452.png?imageView2/0/q/75%7Cwatermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2%7Cimageslim"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class SynchronizedTest &#123;</span><br><span class="line"></span><br><span class="line">    public synchronized void test1()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test2()&#123;</span><br><span class="line">        synchronized (this)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>能过javap -v 查看编译后的代码：</p>
<p><img src="http://images.zhuxingsheng.com/201807031409_511.png?imageView2/0/q/75%7Cwatermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2%7Cimageslim"></p>
<p><img src="http://images.zhuxingsheng.com/201807031410_993.png?imageView2/0/q/75%7Cwatermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2%7Cimageslim"></p>
<p>从反编译的结果来看，方法的同步并没有通过指令monitorenter和monitorexit来完成（理论上其实也可以通过这两条指令来实现），不过相对于普通方法，其常量池中多了ACC_SYNCHRONIZED标示符。JVM就是根据该标示符来实现方法的同步的：当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。 其实本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。</p>
<p>关于这两条指令的作用，我们直接参考JVM规范中描述：</p>
<p><strong>monitorenter</strong></p>
<blockquote>
<p>Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:<br>• If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.<br>• If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count.<br>• If another thread already owns the monitor associated with objectref, the thread blocks until the monitor’s entry count is zero, then tries again to gain ownership.</p>
</blockquote>
<p>这段话的大概意思为：</p>
<p>每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</p>
<p>1、如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。</p>
<p>2、如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.</p>
<p>3.如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</p>
<p><strong>monitorexit：</strong></p>
<blockquote>
<p>The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref.<br>The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.</p>
</blockquote>
<p>这段话的大概意思为：</p>
<p>执行monitorexit的线程必须是objectref所对应的monitor的所有者。</p>
<p>指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。 </p>
<p>通过这两段描述，我们应该能很清楚的看出Synchronized的实现原理，Synchronized的语义底层是通过一个monitor的对象来完成，其实wait&#x2F;notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait&#x2F;notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class SynchronizedExample &#123;</span><br><span class="line">int a = 0;</span><br><span class="line">boolean flag = false;</span><br><span class="line"> </span><br><span class="line">public synchronized void writer() &#123;</span><br><span class="line">    a = 1;</span><br><span class="line">    flag = true;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public synchronized void reader() &#123;</span><br><span class="line">    if (flag) &#123;</span><br><span class="line">        int i = a;</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面示例代码中，假设A线程执行writer()方法后，B线程执行reader()方法。这是一个正确同步的多线程程序。</p>
<p><img src="http://images.zhuxingsheng.com/201807031735_910.png?imageView2/0/q/75%7Cwatermark/2/text/d3d3LnpodXhpbmdzaGVuZy5jb20=/font/5b6u6L2v6ZuF6buR/fontsize/300/fill/I0VDRTlFOQ==/dissolve/100/gravity/SouthEast/dx/2/dy/2%7Cimageslim"></p>
<h2 id="cas"><a href="#cas" class="headerlink" title="cas"></a>cas</h2><p>Java在JDK1.5之前都是靠 synchronized关键字保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有共享变量的锁，都采用独占的方式来访问这些变量。这就是一种独占锁，独占锁其实就是一种悲观锁，所以可以说 synchronized 是悲观锁。</p>
<p>悲观锁机制存在以下问题：　　</p>
<ol>
<li>在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。</li>
<li>一个线程持有锁会导致其它所有需要此锁的线程挂起。</li>
<li>如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。</li>
</ol>
<p>对比于悲观锁的这些问题，另一个更加有效的锁就是乐观锁。</p>
<p>其实乐观锁就是：每次不加锁而是假设没有并发冲突而去完成某项操作，如果因为并发冲突失败就重试，直到成功为止。</p>
<p>CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p>
<p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。<br>（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前值。）<br>CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；<br>否则，不要更改该位置，只告诉我这个位置现在的值即可。”这其实和乐观锁的冲突检查+数据更新的原理是一样的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final boolean compareAndSet(int expect, int update) &#123;   </span><br><span class="line">    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line"></span><br><span class="line">类似：</span><br><span class="line"></span><br><span class="line">if (this == expect) &#123;</span><br><span class="line"></span><br><span class="line">       this = update</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">&#125;  else &#123;</span><br><span class="line"></span><br><span class="line">       return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h3><p>CAS通过调用JNI的代码实现的。JNI:Java Native Interface为JAVA本地调用，允许java调用其他语言。</p>
<p>而compareAndSwapInt就是借助C来调用CPU底层指令实现的。</p>
<p>下面是sun.misc.Unsafe类的compareAndSwapInt()方法的源代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final native boolean compareAndSwapInt(Object o, long offset,</span><br><span class="line">                                              int expected,</span><br><span class="line">                                              int x);</span><br></pre></td></tr></table></figure>

<p>可以看到这是个本地方法调用。这个本地方法在openjdk中依次调用的c++代码为：unsafe.cpp，atomic.cpp和atomicwindowsx86.inline.hpp。这个本地方法的最终实现在openjdk的如下位置：openjdk-7-fcs-src-b147-27jun2011\openjdk\hotspot\src\oscpu\windowsx86\vm\ atomicwindowsx86.inline.hpp（对应于windows操作系统，X86处理器）。下面是对应于intel x86处理器的源代码的片段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// Adding a lock prefix to an instruction on MP machine</span><br><span class="line">// VC++ doesn&#x27;t like the lock prefix to be on a single line</span><br><span class="line">// so we can&#x27;t insert a label after the lock prefix.</span><br><span class="line">// By emitting a lock prefix, we can define a label after it.</span><br><span class="line">#define LOCK_IF_MP(mp) __asm cmp mp, 0  \</span><br><span class="line">                       __asm je L0      \</span><br><span class="line">                       __asm _emit 0xF0 \</span><br><span class="line">                       __asm L0:</span><br><span class="line"></span><br><span class="line">inline jint     Atomic::cmpxchg    (jint     exchange_value, volatile jint*     dest, jint     compare_value) &#123;</span><br><span class="line">  // alternative for InterlockedCompareExchange</span><br><span class="line">  int mp = os::is_MP();</span><br><span class="line">  __asm &#123;</span><br><span class="line">    mov edx, dest</span><br><span class="line">    mov ecx, exchange_value</span><br><span class="line">    mov eax, compare_value</span><br><span class="line">    LOCK_IF_MP(mp)</span><br><span class="line">    cmpxchg dword ptr [edx], ecx</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上面源代码所示，程序会根据当前处理器的类型来决定是否为cmpxchg指令添加lock前缀。如果程序是在多处理器上运行，就为cmpxchg指令加上lock前缀（lock cmpxchg）。反之，如果程序是在单处理器上运行，就省略lock前缀（单处理器自身会维护单处理器内的顺序一致性，不需要lock前缀提供的内存屏障效果）。</p>
<p>intel的手册对lock前缀的说明如下：</p>
<ol>
<li>确保对内存的读-改-写操作原子执行。在Pentium及Pentium之前的处理器中，带有lock前缀的指令在执行期间会锁住总线，使得其他处理器暂时无法通过总线访问内存。很显然，这会带来昂贵的开销。从Pentium 4，Intel Xeon及P6处理器开始，intel在原有总线锁的基础上做了一个很有意义的优化：如果要访问的内存区域（area of memory）在lock前缀指令执行期间已经在处理器内部的缓存中被锁定（即包含该内存区域的缓存行当前处于独占或以修改状态），并且该内存区域被完全包含在单个缓存行（cache line）中，那么处理器将直接执行该指令。由于在指令执行期间该缓存行会一直被锁定，其它处理器无法读&#x2F;写该指令要访问的内存区域，因此能保证指令执行的原子性。这个操作过程叫做缓存锁定（cache locking），缓存锁定将大大降低lock前缀指令的执行开销，但是当多处理器之间的竞争程度很高或者指令访问的内存地址未对齐时，仍然会锁住总线。</li>
<li>禁止该指令与之前和之后的读和写指令重排序。</li>
<li>把写缓冲区中的所有数据刷新到内存中。</li>
</ol>
<h3 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h3><p> CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作</p>
<ol>
<li>ABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A<br>从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</li>
<li>循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</li>
<li>只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j&#x3D;a，合并一下ij&#x3D;2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</li>
</ol>
<h3 id="concurrent包的实现"><a href="#concurrent包的实现" class="headerlink" title="concurrent包的实现"></a>concurrent包的实现</h3><p>由于java的CAS同时具有 volatile 读和volatile写的内存语义，因此Java线程之间的通信现在有了下面四种方式：</p>
<ol>
<li>A线程写volatile变量，随后B线程读这个volatile变量。</li>
<li>A线程写volatile变量，随后B线程用CAS更新这个volatile变量。</li>
<li>A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。</li>
<li>A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。</li>
</ol>
<p>Java的CAS会使用现代处理器上提供的高效机器级别原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键（从本质上来说，能够支持原子性读-改-写指令的计算机器，是顺序计算图灵机的异步等价机器，因此任何现代的多处理器都会去支持某种能对内存执行原子性读-改-写操作的原子指令）。同时，volatile变量的读&#x2F;写和CAS可以实现线程之间的通信。把这些特性整合在一起，就形成了整个concurrent包得以实现的基石。如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式：</p>
<ul>
<li>首先，声明共享变量为volatile；</li>
<li>然后，使用CAS的原子条件更新来实现线程之间的同步；</li>
<li>同时，配合以volatile的读&#x2F;写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。</li>
</ul>
<h2 id="volatile-vs-synchronized"><a href="#volatile-vs-synchronized" class="headerlink" title="volatile vs synchronized"></a>volatile vs synchronized</h2><p>1.volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。<br>2.volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。<br>3.volatile仅能实现变量的修改可见性，不能保证原子性（线程A修改了变量还没结束时,另外的线程B可以看到已修改的值,而且可以修改这个变量,而不用等待A释放锁,因为Volatile 变量没上锁）；而synchronized则可以保证变量的修改可见性和原子性。<br>4.volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞和上下文切换。<br>5.volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</p>
<p>6.在使用volatile关键字时要慎重，并不是只要简单类型变量使用volatile修饰，对这个变量的所有操作都是原子操作。当变量的值由自身决定时，如n&#x3D;n+1、n++ 等，volatile关键字将失效。只有当变量的值和自身无关时对该变量的操作才是原子级别的，如n &#x3D; m + 1，这个就是原级别的。所以在使用volatile关键时一定要谨慎，如果自己没有把握，可以使用synchronized来代替volatile。</p>
<p>7.“锁是昂贵的”，谨慎使用锁机制。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html">Java Language Specification</a> </p>
<p><a href="https://www.jianshu.com/p/506c1e38a922">volatile的底层源码分析</a></p>
<p><a href="http://blog.sina.com.cn/s/blog_12fa13e6e0102v3gm.html">volatile</a></p>
<p><a href="http://www.cnblogs.com/liaokang/p/5614748.html">内存屏障（Memory barrier）</a></p>
<p><a href="http://www.infoq.com/cn/articles/java-memory-model-4/">深入理解Java内存模型（四）——volatile</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://www.zhuxingsheng.com/blog/microservice---circuit-breaker-mechanism.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="朱兴生">
      <meta itemprop="description" content="彪悍的人生需要书写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码农戏码">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/microservice---circuit-breaker-mechanism.html" class="post-title-link" itemprop="url">微服务-熔断机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-04-16 21:29:36" itemprop="dateCreated datePublished" datetime="2018-04-16T21:29:36+08:00">2018-04-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-07 21:29:17" itemprop="dateModified" datetime="2021-11-07T21:29:17+08:00">2021-11-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>由于微服务间通过RPC来进行数据交换，所以我们可以做一个假设：在IO型服务中，假设服务A依赖服务B和服务C，而B服务和C服务有可能继续依赖其他的服务，继续下去会使得调用链路过长，技术上称1-&gt;N扇出</p>
<p><img src="http://images.zhuxingsheng.com/201804281326_732.png?imageView/2/w/500/q/70" alt="1-&gt;N扇出"></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果在A的链路上某个或几个被调用的子服务不可用或延迟较高，则会导致调用A服务的请求被堵住，堵住的请求会消耗占用掉系统的线程、io等资源，当该类请求越来越多，占用的计算机资源越来越多的时候，会导致系统瓶颈出现，造成其他的请求同样不可用，最终导致业务系统崩溃</p>
<ol>
<li>服务器失败影响服务质量</li>
<li>超负荷导致整个服务失败</li>
<li>服务失败造成的雪崩效应</li>
</ol>
<p><img src="http://images.zhuxingsheng.com/201804281126_490.png" alt="微服务服务依赖调用"></p>
<p><img src="http://images.zhuxingsheng.com/201804281126_55.png" alt="超负荷导致整个服务失败"></p>
<p><img src="http://images.zhuxingsheng.com/201804281127_30.png" alt="服务失败造成的雪崩效应"></p>
<h1 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h1><p><strong>熔断模式</strong>：这种模式主要是参考电路熔断，如果一条线路电压过高，保险丝会熔断，防止火灾。放到我们的系统中，如果某个目标服务调用慢或者有大量超时，此时，熔断该服务的调用，对于后续调用请求，不在继续调用目标服务，直接返回，快速释放资源。如果目标服务情况好转则恢复调用。</p>
<p>定义里面有几个量化的地方</p>
<ol>
<li>目标服务调用慢或者超时：开启熔断的阀值量化</li>
</ol>
<p>可以通过两个维度：时间与请求数</p>
<p><strong>时间</strong><br>多长时间内的超时请求达到多少，触发熔断</p>
<p><strong>请求数</strong><br>从服务启动，超时请求数达到多少，触发</p>
<p>这两个维度都需要记录超时请求数和统计总请求数</p>
<ol start="2">
<li>情况好转，恢复调用</li>
</ol>
<p>如何量化情况好转：多长时间之后超时请求数低于多少关闭熔断</p>
<h2 id="熔断状态"><a href="#熔断状态" class="headerlink" title="熔断状态"></a>熔断状态</h2><p><img src="http://images.zhuxingsheng.com/201805021603_479.png" alt="熔断状态"></p>
<p>三种状态的切换</p>
<p><strong>开 – 半开 – 关</strong></p>
<p><strong>开</strong>：使用快速失败返回，调用链结束</p>
<p><strong>半开</strong>：当熔断开启一段时间后，尝试阶段</p>
<p><strong>关</strong>：调用正常</p>
<h2 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h2><p>可以使用一段伪代码表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//正常request</span><br><span class="line">if( request is open) &#123;</span><br><span class="line">    //fastfail</span><br><span class="line">&#125; else if( request is halfopen) &#123;</span><br><span class="line">    if ( request success count &gt; recoverySampleVolume) &#123;</span><br><span class="line">        //state --&gt; close</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//失败request</span><br><span class="line">if( request is failcount &gt; requestVolumeThreshold &amp;&amp; errorPercentage &gt; threshold) &#123;</span><br><span class="line">    //close --&gt; open</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求熔断开启时，直接快速失败</p>
<p>是halfopen状态，如果成功处理次数是否大于恢复配置，就关闭熔断</p>
<p>如果失败次数超过阀值，开启熔断</p>
<p>而对于open–&gt;halfopen的转换，可以通过定时器主动触发</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>现在有很多开源的</p>
<p>failsafe:<a href="https://github.com/jhalterman/failsafe">https://github.com/jhalterman/failsafe</a></p>
<p>Hystrix</p>
<h3 id="个案实现"><a href="#个案实现" class="headerlink" title="个案实现"></a>个案实现</h3><p>在没有熔断时，请求链路：</p>
<p>client –&gt; request –&gt; balance – &gt; handler</p>
<p>一个请求过来，通过负载均衡找到具体的server,再执行</p>
<p>加入熔断后：</p>
<p>client –&gt; request –&gt; circuitBreakerfilter –&gt; balance – &gt; handler</p>
<p>CircuitBreakerFilter过滤掉被熔断的server,在负载均衡时，不再被选中</p>
<ol>
<li>getAllServers() 获取所有服务器列表</li>
<li>根据requestService,requestMethod获取熔断的servers<ul>
<li>从allserverList中剔除这些server</li>
</ul>
</li>
</ol>
<p>熔断服务列表怎么维护呢？</p>
<h5 id="正常状态-–-熔断状态"><a href="#正常状态-–-熔断状态" class="headerlink" title="正常状态 –&gt; 熔断状态"></a>正常状态 –&gt; 熔断状态</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 收到失败请求(e.g.超时，系统异常)</span><br><span class="line">2. 判断此service是否配置了熔断策略 map&lt;serviceName,circuitBreakerpolicy&gt;</span><br><span class="line">    - 根据serviceName,method,serverInfo获取CircuitBreakerCounter</span><br><span class="line">    - counter对失败次数+1</span><br><span class="line">    - 此server是否在half open状态  HalfOpenServersMap&lt;serverName+method,serverList&gt;</span><br><span class="line">        - 在：如果失败次数超过RecoverySampleVolume，openserversmap&lt;servername+method,serverlist&gt;进行put操作、并从HalfOpenServersMap中remove</span><br><span class="line">        - 不在：请求数大于等于10笔(requestVolumeThreshold)，且错误率达到60%(errorPercentage),openserversmap&lt;servername+method,serverlist&gt;进行put操作</span><br></pre></td></tr></table></figure>
<h5 id="熔断状态-–-正常状态"><a href="#熔断状态-–-正常状态" class="headerlink" title="熔断状态 –&gt; 正常状态"></a>熔断状态 –&gt; 正常状态</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 收到请求</span><br><span class="line">2. 判断此service是否配置了熔断策略 map&lt;serviceName,circuitBreakerpolicy&gt;</span><br><span class="line">    - 根据serviceName,method,serverInfo获取CircuitBreakerCounter</span><br><span class="line">    - counter调用次数+1</span><br><span class="line">    - 若half-open 状态下的服务instance被调用次数超过取样的sample数,从HalfOpenServersMap中remove</span><br></pre></td></tr></table></figure>

<h5 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h5><ol>
<li>错误率怎么计算？</li>
<li>counter的实现</li>
<li>上面是close与open的转换，怎么转换到halfopen？</li>
</ol>
<p>错误率&#x3D; 错误次数&#x2F;请求次数</p>
<p><strong>halfopen状态</strong></p>
<p>在上面的提到，被熔断的服务，如果情况好转就会关闭熔断！“情况好转”：什么时候去判断情况好转，怎么判断情况好转两方面</p>
<ol>
<li>在加入到openserversmap时，同时开启延迟时间窗口后的定时任务<ul>
<li>从openserversmap中移除，加入到halfOpenServersMap</li>
</ul>
</li>
</ol>
<p><strong>counter实现</strong></p>
<ol>
<li>简单点：AtomicLong，如当是halfopen时，使用这种简单的计数器叠加</li>
<li>滑动时间窗口实现</li>
</ol>
<h1 id="VS-降级"><a href="#VS-降级" class="headerlink" title="VS 降级"></a>VS 降级</h1><p>提到熔断，不得不起一下降级。两者的区别</p>
<p>有时语言真是乏力，不容易表达清楚，罗列一下</p>
<p>熔断是框架提供，不管业务什么样，防止系统雪崩，都需要提供一下基本功能；而降级与业务有关，自动或手动。比如支付，有很多种支付方式，储蓄卡，信用卡，支付宝，微信。若发现某一支付通道不稳定，或压力过大，手动先关闭，这就是一种降级</p>
<p>由此可看出：</p>
<ol>
<li>触发原因不太一样，服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑；</li>
<li>管理目标的层次不太一样，熔断其实是一个框架级的处理，每个微服务都需要（无层级之分），而降级一般需要对业务有层级之分（比如降级一般是从最外围服务开始）</li>
<li>实现方式不一样</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://yq.aliyun.com/articles/7443">微服务熔断与隔离</a></p>
<p><a href="https://martinfowler.com/bliki/CircuitBreaker.html">CircuitBreaker</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://www.zhuxingsheng.com/blog/zookeeper-paxos.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="朱兴生">
      <meta itemprop="description" content="彪悍的人生需要书写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码农戏码">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/zookeeper-paxos.html" class="post-title-link" itemprop="url">zookeeper-paxos</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-01-29 14:33:00" itemprop="dateCreated datePublished" datetime="2018-01-29T14:33:00+08:00">2018-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-01-21 20:42:14" itemprop="dateModified" datetime="2024-01-21T20:42:14+08:00">2024-01-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/readbook/" itemprop="url" rel="index"><span itemprop="name">读书</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在《常识五配置中心》文章中，少了一节关于zookeeper内容，现在补全</p>
<p>此篇也作为《从Paxos到zookeeper分布式一致性原理与实践》的读书笔记</p>
<p><img src="http://qnimages.zhuxingsheng.com/book/book-paxos-to-zookeeper.png" alt="image"></p>
<p>这本书很早就出版了，现在才知道，惭愧。好书总是发现的晚，Better late than never！</p>
<p>IT界日异月新，如果你还没有使用过ZK，那也可以跳过了，虽然现在大多数互联网架构都使用，但它也是个古老物件了。随着CoreOS和Kubernetes等项目在开源社区日益火热，etcd已是跃然而上，我司新一代配置中心架构也开始使用etcd代替zk</p>
<p>但功不唐捐，还是要努力抓住它的尾巴，回味一下错失的年华</p>
<h1 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h1><p>分布式系统对于数据的复制需求一般都来自于以下两个原因</p>
<ol>
<li>为了增加系统的可用性，以防止单点故障引起的系统不可用。</li>
<li>提高系统的整体性能，通过负载均衡技术，能够让分布在不同地方的数据副本都能够为用户提供服务。</li>
</ol>
<p>数据复制在可用性和性能方面给分布式系统带来的巨大好处是不言而喻的，然而数据复制所带来的一致性挑战，也是每一个系统研发人员不得不面对的。</p>
<h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><ul>
<li>强一致性</li>
<li>弱一致性<ol>
<li>会话一致性</li>
<li>用户一致性</li>
</ol>
</li>
<li>最终一致性</li>
</ul>
<h1 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h1><p>通过消息传递进行通信和协调的系统</p>
<ul>
<li>分布性</li>
<li>对等性</li>
<li>并发性</li>
<li>缺乏全局时钟</li>
<li>故障总是会发生</li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="通信异常"><a href="#通信异常" class="headerlink" title="通信异常"></a>通信异常</h3><p>网络是不可靠的</p>
<h3 id="网络分区"><a href="#网络分区" class="headerlink" title="网络分区"></a>网络分区</h3><p>俗称“脑裂”</p>
<h3 id="三态"><a href="#三态" class="headerlink" title="三态"></a>三态</h3><p>成功，失败，超时</p>
<h3 id="节点故障"><a href="#节点故障" class="headerlink" title="节点故障"></a>节点故障</h3><p>每个节点随时都有可能发生故障</p>
<h2 id="ACID-CAP-BASE"><a href="#ACID-CAP-BASE" class="headerlink" title="ACID &amp;&amp; CAP &amp;&amp; BASE"></a>ACID &amp;&amp; CAP &amp;&amp; BASE</h2><p><img src="http://qnimages.zhuxingsheng.com/cap.jpg" alt="image"></p>
<h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><p>这个集中式架构中，数据库就能保证</p>
<p>ACID是Atomic（原子性）、Consistency（一致性）、Isolation（隔离性）和Durability（持久性）的英文缩写。</p>
<p>原子性：指整个数据库事务是不可分割的工作单位。只有使据库中所有的操作执行成功，才算整个事务成功；事务中任何一个SQL语句执行失败，那么已经执行成功的SQL语句也必须撤销，数据库状态应该退回到执行事务前的状态。</p>
<p>一致性：指数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。例如对银行转帐事务，不管事务成功还是失败，应该保证事务结束后ACCOUNTS表中Tom和Jack的存款总额为2000元。</p>
<p>隔离性：指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。</p>
<p>持久性：指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。</p>
<h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><p>CAP原则又称CAP定理，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼</p>
<ul>
<li>一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</li>
<li>可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</li>
<li>分区容错性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</li>
</ul>
<p>设想一下，当一个分布式系统发生了部分隔离：</p>
<p><img src="http://qnimages.zhuxingsheng.com/cap-partition.gif" alt="image"></p>
<p>节点被分隔到了两个区域：写入区域（1）的数据无法复制到区域（2），而访问区域（2）的请求也不能被转发到区域（1）。</p>
<p>这时候，如果让左边的写入成功——优先保证可用性，则访问区域（2）的请求读不到最新一致的数据，违反了一致性。</p>
<p>反之，如果让写入失败（阻塞），或者彻底阻止外部请求访问区域（2）——则保证了数据一致性，但是损失了可用性。</p>
<p>因此，要同时保证一致性和可用性，区域（1）和区域（2）必须能够互相通讯。</p>
<h3 id="BASE-最终一致性"><a href="#BASE-最终一致性" class="headerlink" title="BASE, 最终一致性"></a>BASE, 最终一致性</h3><p>这个理论由 Basically Available, Soft state, Eventual consistency 组成。核心的概念是 Eventual consistency ——最终一致性。它局部的放弃了 CAP 理论中的“完全”一致性，提供了更好的可用性和分区容忍度。</p>
<h4 id="Basically-Available"><a href="#Basically-Available" class="headerlink" title="Basically Available"></a>Basically Available</h4><p>基本可用, 或者说部分可用。由于分布式系统的节点故障是常见的，业务必须接受这种不可用，并且做出选择：是访问另一个节点忍受数据的临时不一致，还是等待节点恢复并忍受业务上的部分不可用。</p>
<h4 id="Soft-state"><a href="#Soft-state" class="headerlink" title="Soft state"></a>Soft state</h4><p>把所有节点的数据 (数据 &#x3D; 状态) 都看作是缓存（Cache）。适当的调整业务，使业务可以忍受数据的临时不一致，并保证这种不一致是无害的，可以被最终用户理解。</p>
<h4 id="Eventual-consistency"><a href="#Eventual-consistency" class="headerlink" title="Eventual consistency"></a>Eventual consistency</h4><p>放弃在任何时刻、从任何节点都能读到完全一致的数据。允许数据的临时不一致，并通过异步复制、重试和合并消除数据的临时不一致。</p>
<p>注意 在分布式系统中，写入和读取可能发生在不同的节点上。最终一致带来的问题是，业务在写入后立即读取，很可能读不到刚刚写入的数据</p>
<p>在实际工程实践中，最终一致性存在以下五类主要变种。</p>
<ol>
<li>因果一致性（Causal consistency）<br>因果一致性是指，如果进程A在更新完某个数据项后通知了进程B，那么进程B之后对该数据项的访问都应该能够获取到进程A更新后的最新值，并且如果进程B要对该数据项进行更新操作的话，务必基于进程A更新后的最新值，即不能发生丢失更新情况。与此同时，与进程A无因果关系的进程C的数据访问则没有这样的限制。</li>
<li>读己之所写（Read your writes）<br>读己之所写是指，进程A更新一个数据项之后，它自己总是能够访问到更新过的最新值，而不会看到旧值。也就是说，对于单个数据获取者来说，其读取到的数据，一定不会比自己上次写入的值旧。因此，读己之所写也可以看作是一种特殊的因果一致性。</li>
<li>会话一致性（Session consistency）<br>会话一致性将对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现“读己之所写”的一致性，也就是说，执行更能操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。</li>
<li>单调读一致性（Monotonic read consistency）<br>单调读一致性是指如果一个进程从系统中读取出一个数据项的某个值后，那么系统对于该进程后续的任何数据访问都不应该返回更旧的值。</li>
<li>单调写一致性（Monotonic write consistency）<br>单调写一致性是指，一个系统需要能够保证来自同一个进程的写操作被顺序地执行。</li>
</ol>
<h1 id="一致性协议"><a href="#一致性协议" class="headerlink" title="一致性协议"></a>一致性协议</h1><h2 id="2PC-3PC"><a href="#2PC-3PC" class="headerlink" title="2PC&amp;&amp;3PC"></a>2PC&amp;&amp;3PC</h2><p>2PC&#x2F;3PC全称:Two&#x2F;Three Phase Commit,中文名叫叫两阶段&#x2F;三阶段提交；为了使基于分布式系统架构下的所有节点在进行事务处理的过程中能够ACID特性而设计的一种算法，需要引入一个作为协调者的组件来统一掌控所有节点(称作参与者)的操作结果并最终指示这些节点是否要把操作结果进行真正的提交</p>
<h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h3><p><img src="http://qnimages.zhuxingsheng.com/2pc.png" alt="2pc"><br><em>第一阶段：提交事务阶段(投票阶段)</em></p>
<ol>
<li>事务询问：协调者会问所有的参与者结点，是否可以执行提交操作</li>
<li>执行事务：各个参与者执行事务操作 如：资源上锁，将Undo和Redo信息记入事务日志中</li>
<li>参与者向协调者反馈事务询问的响应：如果参与者成功执行了事务操作，反馈给协调者Yes响应，否则No响应</li>
</ol>
<p><em>第二阶段：执行事务提交(执行阶段)</em></p>
<p>假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务提交</p>
<ol>
<li>发送提交请求：协调者向参与者发送Commit请求</li>
<li>事务提交：参与者接受到Commit请求后，会正式执行事务提交操作，并在完成提交之后释放事务资源</li>
<li>反馈事务提交结果：参与者在完成事务提交之后，向协调者发送Ack消息</li>
<li>完成事务：协调者接受到所有参与者反馈的Ack消息后，完成事务</li>
</ol>
<p>假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无接收到所有参与者的反馈信息，那么就会中断事务</p>
<ol>
<li>发送回滚请求：协调者向参与者发送Rollback请求</li>
<li>事务回滚：参与者利用Undo信息来执行事务回滚，并释放事务资源</li>
<li>反馈事务回滚结果：参与者在完成事务回滚之后，向协调者发送Ack消息</li>
<li>中断事务：协调者接收到所有参与者反馈的Ack消息之后，中断事务</li>
</ol>
<p>网上看来的西方教堂结婚一个桥段很好的描述了2PC协议：<br>1.牧师分别问新郎和新娘：你是否愿意……不管生老病死……（投票阶段）<br>2.当新郎和新娘都回答愿意后（锁定一生的资源），牧师就会说：我宣布你们……（执行阶段）</p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li>二阶段提交协议的优点：原理简单，实现方便。</li>
<li>二阶段提交协议的缺点：同步阻塞、单点问题、脑裂、太过保守</li>
</ul>
<h5 id="同步阻塞"><a href="#同步阻塞" class="headerlink" title="同步阻塞"></a>同步阻塞</h5><p>二阶段提交协议存在的最明显也是最大的一个问题就是同步阻塞，这会极大地限制分布式系统的性能。在二阶段提交的执行过程中，所有参与该事务操作的逻辑都处于阻塞状态，也就是说，各个参与者在等待其他参与者响应的过程中，将无法进行其他任何操作。</p>
<h5 id="单点问题"><a href="#单点问题" class="headerlink" title="单点问题"></a>单点问题</h5><p>协调者的角色在整个二阶段提交协议中起到了非常重要的作用。一旦协调者出现问题，那么整个二阶段提交流程将无法运转，更为严重的是，如果协调者是在阶段二中出现问题的话，那么其他参与者将会一直处于锁定事务资源的状态中，而无法继续完成事务操作。</p>
<h5 id="数据不一致"><a href="#数据不一致" class="headerlink" title="数据不一致"></a>数据不一致</h5><p>在二阶段提交协议的阶段二，即执行事务提交的时候，当协调者向所有的参与者发送Commit请求之后，发生了局部网络异常或者是协调者在尚未发送完Commit请求之前自身发生了崩溃，导致最终只有部分参与者收到了Commit请求。于是，这部分收到了Commit请求的参与者就会进行事务的提交，而其他没有收到Commit请求的参与者则无法进行事务提交，于是整个分布式系统便出现了数据不一致性现象。</p>
<h5 id="太过保守"><a href="#太过保守" class="headerlink" title="太过保守"></a>太过保守</h5><p>如果在协调者指示参与者进行事务提交询问的过程中，参与者出现故障而导致协调者始终无法获取到所有参与者的响应信息的话，这时协调者只能依靠其自身的超时机制来判断是否需要中断事务，这样的策略显得比较保守。换句话说，二阶段提交协议没有设计较为完善的容错机制，任意一个节点的失败都会导致整个事务的失败。</p>
<p>在异步环境(asynchronous)并且没有节点宕机(fail-stop)的模型下，2PC可以满足全认同、值合法、可结束，是解决一致性问题的一种协议。但如果再加上节点宕机(fail-recover)的考虑，2PC是否还能解决一致性问题呢？</p>
<p>coordinator如果在发起提议后宕机，那么participant将进入阻塞(block)状态、一直等待coordinator回应以完成该次决议。这时需要另一角色把系统从不可结束的状态中带出来，我们把新增的这一角色叫协调者备份(coordinator watchdog)。coordinator宕机一定时间后，watchdog接替原coordinator工作，通过问询(query) 各participant的状态，决定阶段2是提交还是中止。这也要求 coordinator&#x2F;participant 记录(logging)历史状态，以备coordinator宕机后watchdog对participant查询、coordinator宕机恢复后重新找回状态。</p>
<p>从coordinator接收到一次事务请求、发起提议到事务完成，经过2PC协议后增加了2次RTT(propose+commit)，带来的时延(latency)增加相对较少。</p>
<h3 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h3><p>3PC是2PC的改进版本，将2PC的第一阶段：提交事务阶段一分为二，形成了CanCommit、PreCommit和doCommit三个阶段组成的事务处理协议</p>
<p>在2PC中一个participant的状态只有它自己和coordinator知晓，假如coordinator提议后自身宕机，在watchdog启用前一个participant又宕机，其他participant就会进入既不能回滚、又不能强制commit的阻塞状态，直到participant宕机恢复。这引出两个疑问：</p>
<ol>
<li>能不能去掉阻塞，使系统可以在commit&#x2F;abort前回滚(rollback)到决议发起前的初始状态</li>
<li>当次决议中，participant间能不能相互知道对方的状态，又或者participant间根本不依赖对方的状态</li>
</ol>
<p>具体看一张流程图</p>
<p><img src="http://qnimages.zhuxingsheng.com/3pc.png" alt="3pc"></p>
<p><strong>阶段一：CanCommit</strong></p>
<ol>
<li>事务询问。<br>协调者向所有的参与者发送一个包含事务内容的canCommit请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应。</li>
<li>各参与者向协调者反馈事务询问的响应。<br>参与者在接收到来自协调者的canCommit请求后，正常情况下，如果其自身认为可以顺利执行事务，那么会反馈Yes响应，并进入预备状态，否则反馈No响应。</li>
</ol>
<p><strong>阶段二：PreCommit</strong></p>
<p>在阶段二中，协调者会根据各参与者的反馈情况来决定是否可以进行事务的PreCommit操作，正常情况下，包含两种可能。</p>
<ul>
<li>执行事务预提交</li>
</ul>
<p>假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务预提交。</p>
<ol>
<li>发送预提交请求。<br>协调者向所有参与者节点发出preCommit的请求，并进入Prepared阶段。</li>
<li>事务预提交。<br>参与者接收到preCommit请求后，会执行事务操作，并将Undo和Redo信息记录到事务日志中。</li>
<li>各参与者向协调者反馈事务执行的响应。<br>如果参与者成功执行了事务操作，那么就会反馈给协调者Ack响应，同时等待最终的指令：提交（commit）或中止（abort）。</li>
</ol>
<ul>
<li>中断事务<br>假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。</li>
</ul>
<ol>
<li>发送中断请求。<br>协调者向所有参与者节点发出abort请求。</li>
<li>中断事务。<br>无论是收到来自协调者的abort请求，或者是在等待协调者请求过程中出现超时，参与者都会中断事务。</li>
</ol>
<p><strong>阶段三：doCommit</strong></p>
<p>该阶段将进行真正的事务提交，会存在以下两种可能的情况。</p>
<ul>
<li>执行提交</li>
</ul>
<ol>
<li>发送提交请求。<br>进入这一阶段，假设协调者处于正常工作状态，并且它接收到了来自所有参与者的Ack响应，那么它将从“预提交”状态转换到“提交”状态，并向所有的参与者发送doCommit请求。</li>
<li>事务提交。<br>参与者接收到doCommit请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源。</li>
<li>反馈事务提交结果。<br>参与者在完成事务提交之后，向协调者发送Ack消息。</li>
<li>完成事务。<br>协调者接收到所有参与者反馈的Ack消息后，完成事务。</li>
</ol>
<ul>
<li>中断事务<br>进入这一阶段，假设协调者处于正常工作状态，并且有任意一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。</li>
</ul>
<ol>
<li>发送中断请求。<br>协调者向所有的参与者节点发送abort请求。</li>
<li>事务回滚。<br>参与者接收到abort请求后，会利用其在阶段二中记录的Undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。</li>
<li>反馈事务回滚结果。<br>参与者在完成事务回滚之后，向协调者发送Ack消息。</li>
<li>中断事务。<br>协调者接收到所有参与者反馈的Ack消息后，中断事务。</li>
</ol>
<p>需要注意的是，一旦进入阶段三，可能会存在以下两种故障。</p>
<ol>
<li>协调者出现问题</li>
<li>协调者和参与者之间的网络出现故障。</li>
</ol>
<p>无论出现哪种情况，最终都会导致参与者无法及时接收到来自协调者的doCommit或是abort请求，针对这样的异常情况，参与者都会在等待超时之后，继续进行事务提交。</p>
<h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p>三阶段提交协议的优点：</p>
<p>相较于二阶段提交协议，三阶段提交协议最大的优点就是降低了参与者的阻塞范围，并且能够在出现单点故障后继续达成一致。</p>
<p>三阶段提交协议的缺点：</p>
<p>三阶段提交协议在去除阻塞的同时也引入了新的问题，那就是在参与者接收到preCommit消息后，如果网络出现分区，此时协调者所在的节点和参与者无法进行正常的网络通信，在这种情况下，该参与者依然会进行事务的提交，这必然出现数据的不一致性。</p>
<p>coordinator接收完participant的反馈(vote)之后，进入阶段2，给各个participant发送准备提交(prepare to commit)指令。participant接到准备提交指令后可以锁资源，但要求相关操作必须可回滚。coordinator接收完确认(ACK)后进入阶段3、进行commit&#x2F;abort，3PC的阶段3与2PC的阶段2无异。协调者备份(coordinator watchdog)、状态记录(logging)同样应用在3PC。</p>
<p>participant如果在不同阶段宕机，我们来看看3PC如何应对：</p>
<ul>
<li>阶段1: coordinator或watchdog未收到宕机participant的vote，直接中止事务；宕机的participant恢复后，读取logging发现未发出赞成vote，自行中止该次事务</li>
<li>阶段2: coordinator未收到宕机participant的precommit ACK，但因为之前已经收到了宕机participant的赞成反馈(不然也不会进入到阶段2)，coordinator进行commit；watchdog可以通过问询其他participant获得这些信息，过程同理；宕机的participant恢复后发现收到precommit或已经发出赞成vote，则自行commit该次事务</li>
<li>阶段3: 即便coordinator或watchdog未收到宕机participant的commit ACK，也结束该次事务；宕机的participant恢复后发现收到commit或者precommit，也将自行commit该次事务</li>
</ul>
<p>因为有了准备提交(prepare to commit)阶段，3PC的事务处理延时也增加了1个RTT，变为3个RTT(propose+precommit+commit)，但是它防止participant宕机后整个系统进入阻塞态，增强了系统的可用性，对一些现实业务场景是非常值得的。</p>
<h2 id="paxos"><a href="#paxos" class="headerlink" title="paxos"></a>paxos</h2><p><strong>2PC:同步阻塞、单点问题、脑裂、太过保守</strong></p>
<p><strong>3PC:主要解决的单点故障问题，并减少阻塞,但依然存在数据不一致以及太过保守问题</strong></p>
<p>2PC协议用于保证属于多个数据分片上的操作的原子性。这些数据分片可能分布在不同的服务器上，2PC协议保证多台服务器上的操作要么全部成功，要么全部失败。</p>
<p>Paxos协议用于保证同一个数据分片的多个副本之间的数据一致性。</p>
<p>Paxos算法要解决的问题就是如何在可能发生几起宕机或网络异常的分布式系统中，快速且正确地在集群内部对某个数据的值达成一致，并且保证不论发生以上任何异常，都不会破坏整个系统的一致性</p>
<h3 id="复制策略"><a href="#复制策略" class="headerlink" title="复制策略"></a>复制策略</h3><p>很多资料介绍paxos时，很学术，上来就是提案者，接受者~ 我也是云里雾里，只能不明觉历。</p>
<p>罗列一些问题：</p>
<p>一致性是什么？以前怎么处理一致性问题？</p>
<p>没有paxos时，以前的解决方案有哪些问题？</p>
<p>paxos怎么演变而来？</p>
<p>paxos怎么解决问题的？</p>
<p>理论背景的缺失，让人难以理解！</p>
<p>看到了<a href="http://drmingdrmer.github.io/tech/distributed/2015/11/11/paxos-slide.html">可靠分布式系统基础 Paxos 的直观解释</a>，感觉有点明白了。引用一下！</p>
<p>对于一致性，现在一些方案大都是走复制模式，如主从及进化的主从</p>
<h4 id="主从异步复制"><a href="#主从异步复制" class="headerlink" title="主从异步复制"></a>主从异步复制</h4><p>如Mysql的binlog复制</p>
<ol>
<li>主接到写请求</li>
<li>主写入本磁盘</li>
<li>主应答‘OK’</li>
<li>主复制数据到从库</li>
</ol>
<p>如果磁盘在复制前损坏： 数据丢失</p>
<p><img src="http://qnimages.zhuxingsheng.com/async-copy.png" alt="image"></p>
<h4 id="主从同步复制"><a href="#主从同步复制" class="headerlink" title="主从同步复制"></a>主从同步复制</h4><ol>
<li>主接到写请求</li>
<li>主复制日志到从库</li>
<li>从库这时可能阻塞</li>
<li>客户端一直等待应答OK，直到所有从库返回</li>
</ol>
<p>一个失联节点造成整个系统不可用<br><img src="http://qnimages.zhuxingsheng.com/sync-copy.png" alt="image"></p>
<h4 id="主从半同步复制"><a href="#主从半同步复制" class="headerlink" title="主从半同步复制"></a>主从半同步复制</h4><ol>
<li>主接到写请求</li>
<li>主复制日志到从库</li>
<li>从库可能阻塞</li>
<li>如果1&lt;&#x3D;x&lt;&#x3D;n个从库返回OK,刚返回客户端OK</li>
</ol>
<p>高可靠、高可用、可能任何从库都不完整</p>
<h4 id="多数派写"><a href="#多数派写" class="headerlink" title="多数派写"></a>多数派写</h4><ol>
<li>客户端写入W &gt;&#x3D;N&#x2F;2+1个节点，不需要主</li>
<li>多数派读：W+R&gt;N;R&gt;&#x3D;N&#x2F;2+1</li>
<li>容忍最多(N-1)&#x2F;2个节点损坏</li>
<li>最后1次覆盖先前写入</li>
<li>所有写入操作需要有1个全局顺序:时间戳</li>
</ol>
<p>一致性:最终一致性<br>事务性:非原子更新、脏读、更新丢失问题</p>
<h3 id="多数派读写的不足"><a href="#多数派读写的不足" class="headerlink" title="多数派读写的不足"></a>多数派读写的不足</h3><p>一个假想存储服务</p>
<ol>
<li>一个有3个存储节点的存储服务集群</li>
<li>使用多数派读写策略</li>
<li>“i”的每次更新对应有多个版本i1,i2,i3…</li>
<li>这个存储系统支持3个命令 get读最新的i,set<n> 设置下个版本i的值为n,inc<n> 对i加n</li>
</ol>
<p>命令实现：</p>
<p>“set” → 直接对应多数派写.</p>
<p>“inc” → (最简单的事务型操作):</p>
<ol>
<li>通过多数派读，读取最新的 “i”: i1</li>
<li>Let i2 &#x3D; i1 + n</li>
<li>set i2</li>
</ol>
<p><img src="http://qnimages.zhuxingsheng.com/setgeti.png" alt="image"></p>
<h4 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h4><p><img src="http://qnimages.zhuxingsheng.com/concurrency-i.png" alt="image"></p>
<p>我们期待最终X可以读到i3&#x3D;5, 这需要Y能知道X已经写入了i2。如何实现这个机制？</p>
<p>在X和Y的2次“inc”操作后，为了得到正确的i3：整个系统里对i的某个版本(i2)，只能有1次成功写入.</p>
<p>推广为:在存储系统中，一个值(1个变量的1个版本)在被认为确定(客户端接到OK)之后，就不允许被修改().</p>
<p><strong>如何定义“被确定的”?</strong></p>
<p><strong>如何避免修改“被确定的”值</strong></p>
<h5 id="如何确定一个值"><a href="#如何确定一个值" class="headerlink" title="如何确定一个值"></a>如何确定一个值</h5><p>方案：每次写入一个值前，先运行一次多数派读，来确认是否这个值（可能）已经被写过了</p>
<p><img src="http://qnimages.zhuxingsheng.com/paxos-valueset.png" alt="image"></p>
<p>但是，X和Y可能同时以为还没有值被写入过，然后同时开始写</p>
<p><img src="http://qnimages.zhuxingsheng.com/paxos-updatelost.png" alt="image"></p>
<p><strong>方案改进</strong>:让存储节点记住谁最后1次做过“写前读取”，并拒绝之前其他的“写前读取”的写入操作</p>
<p><img src="http://qnimages.zhuxingsheng.com/paxos-writelast.png" alt="image"></p>
<h3 id="paxos-1"><a href="#paxos-1" class="headerlink" title="paxos"></a>paxos</h3><p>paxos就是以上的解决方案</p>
<blockquote>
<p>将所有节点都写入同一个值，且被写入后不再更改。</p>
</blockquote>
<p>两个操作</p>
<ol>
<li>Proposal Value：提议的值；</li>
<li>Proposal Number：提议编号，可理解为提议版本号，要求不能冲突；</li>
</ol>
<p>三个角色</p>
<ol>
<li>Proposer：提议发起者。Proposer 可以有多个，Proposer 提出议案（value）。所谓 value，可以是任何操作，比如“设置某个变量的值为value”。不同的 Proposer 可以提出不同的 value，例如某个Proposer 提议“将变量 X 设置为 1”，另一个 Proposer 提议“将变量 X 设置为 2”，但对同一轮 Paxos过程，最多只有一个 value 被批准。</li>
<li>Acceptor：提议接受者；Acceptor 有 N 个，Proposer 提出的 value 必须获得超过半数(N&#x2F;2+1)的 Acceptor批准后才能通过。Acceptor 之间完全对等独立。</li>
<li>Learner：提议学习者。上面提到只要超过半数accpetor通过即可获得通过，那么learner角色的目的就是把通过的确定性取值同步给其他未确定的Acceptor。</li>
</ol>
<p>协议过程</p>
<blockquote>
<p>proposer将发起提案（value）给所有accpetor，超过半数accpetor获得批准后，proposer将提案写入accpetor内，最终所有accpetor获得一致性的确定性取值，且后续不允许再修改。</p>
</blockquote>
<p><strong>协议分为两大阶段，每个阶段又分为A&#x2F;B两小步骤：</strong></p>
<ol>
<li>准备阶段（占坑阶段）<ul>
<li>第一阶段A：Proposer选择一个提议编号n，向所有的Acceptor广播Prepare（n）请求。</li>
<li>第一阶段B：Acceptor接收到Prepare（n）请求，若提议编号n比之前接收的Prepare请求都要大，则承诺将不会接收提议编号比n小(&lt;&#x3D;)的提议，并且带上之前Accept的提议中编号小于n(&lt;)的最大的提议，否则不予理会。</li>
</ul>
</li>
<li>接受阶段（提交阶段）<ul>
<li>第二阶段A：整个协议最为关键的点：Proposer得到了Acceptor响应</li>
<li>如果未超过半数accpetor响应，直接转为提议失败；</li>
<li>如果超过多数Acceptor的承诺，又分为不同情况：</li>
</ul>
<ol>
<li>如果所有Acceptor都未接收过值（都为null），那么向所有的Acceptor发起自己的值和提议编号n，记住，一定是所有Acceptor都没接受过值；</li>
<li>如果有部分Acceptor接收过值，那么从所有接受过的值中选择对应的提议编号最大的作为提议的值，提议编号仍然为n。但此时Proposer就不能提议自己的值，只能信任Acceptor通过的值，维护一但获得确定性取值就不能更改原则；</li>
</ol>
<ul>
<li>第二阶段B：Acceptor接收到提议后，如果该提议版本号不等于自身保存记录的版本号（第一阶段记录的），不接受该请求，相等则写入本地。</li>
</ul>
</li>
</ol>
<p>整个paxos协议过程看似复杂难懂，但<em>只要把握和理解这两点就基本理解了paxos的精髓：</em></p>
<ol>
<li>理解第一阶段accpetor的处理流程：如果本地已经写入了，不再接受和同意后面的所有请求，并返回本地写入的值；如果本地未写入，则本地记录该请求的版本号，并不再接受其他版本号的请求，简单来说<strong>只信任最后一次提交的版本号的请求</strong>，使其他版本号写入失效；</li>
<li>理解第二阶段proposer的处理流程：未超过半数accpetor响应，提议失败；超过半数的accpetor值都为空才提交自身要写入的值，否则<strong>选择非空值里版本号最大的值提交，最大的区别在于是提交的值是自身的还是使用以前提交的</strong>。</li>
</ol>
<blockquote>
<p>简单讲，在prepare阶段，以编号大的为准；在accept阶段以值为准</p>
</blockquote>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://in355hz.iteye.com/blog/2034681">漫谈事务与分布式事务（3）- 分布式困境</a></p>
<p><a href="https://www.cnblogs.com/bangerlee/p/5268485.html">分布式系统理论基础 - 一致性、2PC和3PC</a></p>
<p><a href="http://drmingdrmer.github.io/tech/distributed/2015/11/11/paxos-slide.html">可靠分布式系统基础 Paxos 的直观解释</a></p>
<p><a href="https://www.zhihu.com/question/19787937/answer/234636052">如何浅显易懂地解说 Paxos 的算法</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/24788205">Paxos算法的理解</a></p>
<p><a href="http://iunknown.iteye.com/blog/2246484">以两军问题为背景来演绎Basic Paxos</a></p>
<p><a href="http://blog.csdn.net/chdhust/article/details/52655006">Basic Paxos算法</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://www.zhuxingsheng.com/blog/game-gray-release.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="朱兴生">
      <meta itemprop="description" content="彪悍的人生需要书写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码农戏码">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/game-gray-release.html" class="post-title-link" itemprop="url">游戏灰度发布</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-01-26 23:17:16" itemprop="dateCreated datePublished" datetime="2018-01-26T23:17:16+08:00">2018-01-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-29 15:24:30" itemprop="dateModified" datetime="2021-09-29T15:24:30+08:00">2021-09-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>快速可以说是互联网的最大特点了，唯快不破，快速响应，快速发布，快速部署，快速上线</p>
<p>但上线，毕竟还是有风险的，怎么能又快速响应，又能降低风险范围呢</p>
<p>前人，现人，后人们都在寻找着银弹</p>
<p>部署方式就进化了有很多次，蓝绿部署、滚动部署、灰度发布、金丝雀发布。。。</p>
<p>这些都是为了应对互联网的快速响应需求</p>
<p>游戏的发布现在还是比较粗暴的，对开发，运维也比较简单。</p>
<p>制定一个版本计划，开发，与运营沟通，确定版本内容，到了时间，所有游戏区全部关闭入口，停止服务器，发布，部署，重启，开放入口，一气呵成，快哉！</p>
<p>等等，理想很丰满，现实很骨感</p>
<p>在版本发布最后一天，开发人员在凌晨1、 2点时，还在开发，修复bug，好不容易打包，回家睡觉</p>
<p>第二天运维在8点开始停机发布新版本；</p>
<p>duang,怎么游戏服起不来了，开发请起床，查问题</p>
<p>迷迷糊糊的开发在梦境中惊醒，终于搞定，打包，发版本，启动服务(有时可能要一上午查问题，通知运营方，延长维护时间)</p>
<p>duang,玩家反馈，新功能有问题…</p>
<p>此时，回滚？还是。。。；好汉不回头，哪来的回滚</p>
<p>紧急停机，再寻找问题，修复，上线…</p>
<p>…</p>
<p>整个游戏的链条上，似乎大家都已经习惯，开发习惯，玩家也习惯</p>
<p>习惯麻痹了一切，没有提出更好的策略，大家都这么玩啊，无所谓啦~</p>
<h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><p><strong>细思极恐，我们应该，也需要做得更好</strong></p>
<h2 id="灰度发布／金丝雀发布"><a href="#灰度发布／金丝雀发布" class="headerlink" title="灰度发布／金丝雀发布"></a>灰度发布／金丝雀发布</h2><p>灰度发布是在原有版本可用的情况下，同时部署一个新版本应用作为“金丝雀”（金丝雀对瓦斯极敏感，矿井工人携带金丝雀，以便及时发发现危险），测试新版本的性能和表现，以保障整体系统稳定的情况下，尽早发现、调整问题。</p>
<p><img src="http://qnimages.zhuxingsheng.com/network/gray-deploy.png" alt="灰度发布"></p>
<p>灰度发布／金丝雀发布由以下几个步骤组成：</p>
<ol>
<li>准备好部署各个阶段的工件，包括：构建工件，测试脚本，配置文件和部署清单文件。</li>
<li>从负载均衡列表中移除掉“金丝雀”服务器。</li>
<li>升级“金丝雀”应用（排掉原有流量并进行部署）。</li>
<li>对应用进行自动化测试。</li>
<li>将“金丝雀”服务器重新添加到负载均衡列表中（连通性和健康检查）。</li>
<li>如果“金丝雀”在线使用测试成功，升级剩余的其他服务器。（否则就回滚）</li>
</ol>
<h2 id="游戏架构"><a href="#游戏架构" class="headerlink" title="游戏架构"></a>游戏架构</h2><p><img src="http://qnimages.zhuxingsheng.com/game/game-server.png" alt="image"></p>
<p>这个架构图比现实丰满不少，真实情况组件可能是单点的，数据层也就是单个mysql，一切都是那么脆弱。</p>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="http://qnimages.zhuxingsheng.com/game/game-data-stream.png" alt="流程图"></p>
<p>玩家首先登陆游戏运营平台，鉴权完毕，选择区服，通过网关服务器获取到真实game-server信息，通过TCP，玩家与game-server建立起长连接。</p>
<p>通过这个流程，就知道玩家与game-server直接牵手，强依赖的，如果gameserver重启，tcp连接是一定会断的，虽然前端可能尝试重新连接，但对玩家是有感的，不可能对玩家透明。</p>
<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>怎么才能对玩家无感，切换版本呢？</p>
<p><img src="http://qnimages.zhuxingsheng.com/game/game-server-gray.png" alt="image"></p>
<p>在之前的架构图中，稍作修改，在玩家与Gameserver之间增加一层ha-proxy，这样就有了灰度发布的基础</p>
<p>玩家不再直接与game-server直连，而是与ha-proxy</p>
<h4 id="透明性"><a href="#透明性" class="headerlink" title="透明性"></a>透明性</h4><p>对玩家来说，发版本就是透明的，发版本时，不再需要停机，入口也不需要关闭，7*24玩耍</p>
<h4 id="流量灵活切换"><a href="#流量灵活切换" class="headerlink" title="流量灵活切换"></a>流量灵活切换</h4><p>灰度百分比，可以灵活控制，这里面又涉及到路由规则，复杂了，可以先百分百切换</p>
<h4 id="快速迭代"><a href="#快速迭代" class="headerlink" title="快速迭代"></a>快速迭代</h4><p>玩家无感，出现bug，可以快速修复，快速上线</p>
<h4 id="快速回滚"><a href="#快速回滚" class="headerlink" title="快速回滚"></a>快速回滚</h4><p>一旦新版本有问题，可以马上切回老版本，版本之间无逢切换</p>
<h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><p>加了ha-proxy，多了更多的灵活性</p>
<p>ha-proxy的难点，高可用，高可靠，高性能</p>
<h4 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h4><p>最重要的一点，不能单点；</p>
<p>如果ha-proxy挂了，怎么办？就算game-server正常运行，也不能再提供服务，自己坑了自己</p>
<p>所以ha-proxy不能单点，哪是集群，还是主从？</p>
<p>每台物理机上都部署，还是集中几台部署？</p>
<h4 id="高可靠"><a href="#高可靠" class="headerlink" title="高可靠"></a>高可靠</h4><p>在新旧版本同时在线时，流量是否平滑过渡？ 玩家操作是否保持完整性？</p>
<p>一个玩家操作横跨新旧版本时，数据一致性如何保障？</p>
<h4 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h4><p>游戏服都是尽量压榨单台服务的能力，现在多了一层通讯，IO会不会影响性能？</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>对于以上方案，不论是哪一种实现方式，仁者见仁，条条大路通罗马。</p>
<p>也可能你觉得这种想法本身就是个多余。</p>
<p>能卖1块钱的豆腐，为什么要卖5毛？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://www.zhuxingsheng.com/blog/common-sense-four-out-of-heap-memory.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="朱兴生">
      <meta itemprop="description" content="彪悍的人生需要书写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码农戏码">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/common-sense-four-out-of-heap-memory.html" class="post-title-link" itemprop="url">常识四堆外内存</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-12-31 23:12:00" itemprop="dateCreated datePublished" datetime="2017-12-31T23:12:00+08:00">2017-12-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-29 15:24:30" itemprop="dateModified" datetime="2021-09-29T15:24:30+08:00">2021-09-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>常识系列,作为一名互联网门外汉的科普系列</p>
</blockquote>
<p>堆外内存除了在像netty开源框架中，在平常项目中使用的比较少，在现前的项目中，QPS要求高的系统中，堆外内存作为其中一级缓存是相当有成效的。所以来学习一下，文中主要涉及到这三分部内容</p>
<blockquote>
<ol>
<li>堆外内存是什么？与堆内内存的区别</li>
<li>怎么分配，与GC的影响</li>
<li>开源框架使用</li>
</ol>
</blockquote>
<p>这篇文章写到最后，发现还只是回答了开源框架OHC的<a href="#OHC">Why not use ByteBuffer.allocateDirect()?</a></p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="堆内内存"><a href="#堆内内存" class="headerlink" title="堆内内存"></a>堆内内存</h2><p>现在流行的还是使用分代管理方式</p>
<p><img src="http://qnimages.zhuxingsheng.com/off-heap/on-heap.jpg" alt="image"></p>
<p>之前写过相关文章<a href="https://zhuxingsheng.github.io/2017/02/27/gc-and-jvm-parameters/">GC及JVM参数</a></p>
<p>在jvm参数中只要使用-Xms，-Xmx等参数就可以设置堆的大小和最大值</p>
<h2 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h2><p>和堆内内存相对应，堆外内存就是把内存对象分配在Java虚拟机的堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机）</p>
<p>堆外内存有以下特点：</p>
<ul>
<li>对于大内存有良好的伸缩性</li>
<li>对垃圾回收停顿的改善可以明显感觉到</li>
<li>在进程间可以共享，减少虚拟机间的复制</li>
</ul>
<h1 id="堆外内存分配与回收"><a href="#堆外内存分配与回收" class="headerlink" title="堆外内存分配与回收"></a>堆外内存分配与回收</h1><p>其实堆外内存一直在使用,却没有真正关注过。最常见的nio,Netty，里面大量使用了堆外内存</p>
<p>这儿会涉及到很多知识点，一步步来，抽丝剥茧</p>
<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>这儿回顾下io知识，java提供了两种io处理方式，一种是io，另一种是nio</p>
<p>Java NIO和IO之间最大的区别是IO是面向流（Stream）的，NIO是面向块（buffer）的，所以，这意味着什么？</p>
<p>面向流意味着从流中一次可以读取一个或多个字节，拿到读取的这些做什么你说了算，这里没有任何缓存（这里指的是使用流没有任何缓存，接收或者发送的数据是缓存到操作系统中的，流就像一根水管从操作系统的缓存中读取数据）而且只能顺序从流中读取数据，如果需要跳过一些字节或者再读取已经读过的字节，你必须将从流中读取的数据先缓存起来。<br>面向块的处理方式有些不同，数据是先被 读&#x2F;写到buffer中的，根据需要你可以控制读取什么位置的数据。这在处理的过程中给用户多了一些灵活性，然而，你需要额外做的工作是检查你需要的数据是否已经全部到了buffer中，你还需要保证当有更多的数据进入buffer中时，buffer中未处理的数据不会被覆盖</p>
<p>对于stream流来讲，一个一个字节处理效率太差了，所以还提供了带buffer的bufferedStream</p>
<p>对就到api，就是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">read()</span><br><span class="line">read(byte b[])</span><br><span class="line"></span><br><span class="line">write()</span><br><span class="line">write(byte b[])</span><br></pre></td></tr></table></figure>

<p>nio是面向buffer的，所以有专门抽象了Buffer</p>
<p><img src="http://qnimages.zhuxingsheng.com/java/buffer.png" alt="buffer"></p>
<h2 id="zero-copy"><a href="#zero-copy" class="headerlink" title="zero copy"></a>zero copy</h2><p>虽然通过调节buffer的大小，使用bufferedstream可以提升性能，但还不够</p>
<p>还可以通过Zero-Copy大大提高了应用程序的性能，并且减少了kernel和user模式上下文的切换</p>
<p>这儿需要再深入底层机制，来看系统内核与应用程序的交互过程</p>
<h3 id="linux科普"><a href="#linux科普" class="headerlink" title="linux科普"></a>linux科普</h3><p>这儿再回顾一下linux相关知识点</p>
<p><img src="http://qnimages.zhuxingsheng.com/linux/linux-user-kernel.png" alt="linux的内核态和用户态"></p>
<ul>
<li>内核态：控制计算机的硬件资源，并提供上层应用程序运行的环境。比如socket I&#x2F;0操作或者文件的读写操作等</li>
<li>用户态：上层应用程序的活动空间，应用程序的执行必须依托于内核提供的资源。</li>
<li>系统调用：为了使上层应用能够访问到这些资源，内核为上层应用提供访问的接口。</li>
</ul>
<p><img src="http://qnimages.zhuxingsheng.com/linux/linux-invoke.png" alt="关系"></p>
<p>因此我们可以得知当我们通过JNI调用的native方法实际上就是从用户态切换到了内核态的一种方式。并且通过该系统调用使用操作系统所提供的功能。</p>
<p>Q：为什么需要用户进程(位于用户态中)要通过系统调用(Java中即使JNI)来调用内核态中的资源，或者说调用操作系统的服务了？<br>A：intel cpu提供Ring0-Ring3四种级别的运行模式，Ring0级别最高，Ring3最低。Linux使用了Ring3级别运行用户态，Ring0作为内核态。Ring3状态不能访问Ring0的地址空间，包括代码和数据。因此用户态是没有权限去操作内核态的资源的，它只能通过系统调用外完成用户态到内核态的切换，然后在完成相关操作后再有内核态切换回用户态。</p>
<p>鉴于linux系统的特性，IO之流程就如下图</p>
<p><img src="http://qnimages.zhuxingsheng.com/linux/io-buffer.jpg" alt="IO之流程与buffer概览"></p>
<h3 id="copy过程"><a href="#copy过程" class="headerlink" title="copy过程"></a>copy过程</h3><p>大部分web服务器都要处理大量的静态内容，而其中大部分都是从磁盘文件中读取数据然后写到socket中。这种操作对cpu的消耗是比较小的，但也是十分低效的：内核首先从磁盘文件读取数据，然后从内核空间将数据传到用户空间，应用程序又将数据从用户空间返回到内核空间然后传输给socket(如果好奇数据为何如此来回传输，请继续看下文)。实际上，应用程序就相当于是个低效的中间者，从磁盘拿数据放到socket。</p>
<h4 id="read-write模式"><a href="#read-write模式" class="headerlink" title="read&#x2F;write模式"></a>read&#x2F;write模式</h4><p>代码抽象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read(file, tmp_buf, len);</span><br><span class="line">write(socket, tmp_buf, len);</span><br></pre></td></tr></table></figure>

<p>首先调用read将静态内容，这里假设为文件A，读取到tmp_buf, 然后调用write将tmp_buf写入到socket中</p>
<p><img src="http://qnimages.zhuxingsheng.com/linux/copy-steps.png" alt="read&#x2F;write copy steps"></p>
<p>1、当调用 read 系统调用时，通过 DMA（Direct Memory Access）将数据 copy 到内核模式</p>
<p>2、然后由 CPU 控制将内核模式数据 copy 到用户模式下的 buffer 中</p>
<p>3、read 调用完成后，write 调用首先将用户模式下 buffer 中的数据 copy 到内核模式下的 socket buffer 中</p>
<p>4、最后通过 DMA copy 将内核模式下的 socket buffer 中的数据 copy 到网卡设备中传送。</p>
<p>从上面的过程可以看出，数据白白从内核模式到用户模式走了一圈，浪费了两次 copy(第一次，从kernel模式拷贝到user模式；第二次从user模式再拷贝回kernel模式，即上面4次过程的第2和3步骤。)，而这两次 copy 都是 CPU copy，即占用CPU资源</p>
<h4 id="sendfile模式"><a href="#sendfile模式" class="headerlink" title="sendfile模式"></a>sendfile模式</h4><p><img src="http://qnimages.zhuxingsheng.com/linux/sendfile-copy-steps.jpeg" alt="sendfile copy steps"></p>
<p>通过 sendfile 传送文件只需要一次系统调用，当调用 sendfile 时：</p>
<p>1、首先通过 DMA copy 将数据从磁盘读取到 kernel buffer 中</p>
<p>2、然后通过 CPU copy 将数据从 kernel buffer copy 到 sokcet buffer 中</p>
<p>3、最终通过 DMA copy 将 socket buffer 中数据 copy 到网卡 buffer 中发送</p>
<p>sendfile 与 read&#x2F;write 方式相比，少了 一次模式切换一次 CPU copy。但是从上述过程中也可以发现从 kernel buffer 中将数据 copy 到socket buffer 是没必要的。</p>
<h4 id="sendfile模式改进"><a href="#sendfile模式改进" class="headerlink" title="sendfile模式改进"></a>sendfile模式改进</h4><p>Linux2.4 内核对 sendfile 做了改进，下图所示</p>
<p><img src="http://qnimages.zhuxingsheng.com/linux/sendfilev2-copy-steps.jpeg" alt="sendfilev2 copy steps"></p>
<p>改进后的处理过程如下：</p>
<p>1、DMA copy 将磁盘数据 copy 到 kernel buffer 中</p>
<p>2、向 socket buffer 中追加当前要发送的数据在 kernel buffer 中的位置和偏移量</p>
<p>3、DMA gather copy 根据 socket buffer 中的位置和偏移量直接将 kernel buffer 中的数据 copy 到网卡上。</p>
<p>经过上述过程，数据只经过了 2 次 copy 就从磁盘传送出去了。（事实上这个 Zero copy 是针对内核来讲的，数据在内核模式下是 Zero－copy 的）。</p>
<p>当前许多高性能 http server 都引入了 sendfile 机制，如 nginx，lighttpd 等。</p>
<h3 id="java-zero-copy"><a href="#java-zero-copy" class="headerlink" title="java zero copy"></a>java zero copy</h3><p>Zero-Copy技术省去了将操作系统的read buffer拷贝到程序的buffer，以及从程序buffer拷贝到socket buffer的步骤，直接将read buffer拷贝到socket buffer. Java NIO中的FileChannal.transferTo()方法就是这样的实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void transferTo(long position,long count,WritableByteChannel target);</span><br></pre></td></tr></table></figure>
<p>transferTo()方法将数据从一个channel传输到另一个可写的channel上，其内部实现依赖于操作系统对zero copy技术的支持。在unix操作系统和各种linux的发型版本中，这种功能最终是通过sendfile()系统调用实现。下边就是这个方法的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);</span><br></pre></td></tr></table></figure>
<p>可以通过调用transferTo()方法来替代上边的File.read()、Socket.send()</p>
<p>通过transferTo实现数据传输的路径：</p>
<p><img src="http://qnimages.zhuxingsheng.com/java/transferTo.gif" alt="transferTo"></p>
<p>展示了内核态、用户态的切换情况:</p>
<p><img src="http://qnimages.zhuxingsheng.com/java/transferTo-contextSwitch.gif" alt="transferTo-contextSwitch"></p>
<p>使用transferTo()方式所经历的步骤：</p>
<p>1、transferTo调用会引起DMA将文件内容复制到读缓冲区(内核空间的缓冲区)，然后数据从这个缓冲区复制到另一个与socket输出相关的内核缓冲区中。</p>
<p>2、第三次数据复制就是DMA把socket关联的缓冲区中的数据复制到协议引擎上发送到网络上。</p>
<p>这次改善，我们是通过将内核、用户态切换的次数从四次减少到两次，将数据的复制次数从四次减少到三次(只有一次用到cpu资源)。但这并没有达到我们零复制的目标。如果底层网络适配器支持收集操作的话，我们可以进一步减少内核对数据的复制次数。</p>
<p>在内核为2.4或者以上版本的linux系统上，socket缓冲区描述符将被用来满足这个需求。这个方式不仅减少了内核用户态间的切换，而且也省去了那次需要cpu参与的复制过程。<br>从用户角度来看依旧是调用transferTo()方法，但是其本质发生了变化：</p>
<p>1、调用transferTo方法后数据被DMA从文件复制到了内核的一个缓冲区中。</p>
<p>2、数据不再被复制到socket关联的缓冲区中了，仅仅是将一个描述符（包含了数据的位置和长度等信息）追加到socket关联的缓冲区中。DMA直接将内核中的缓冲区中的数据传输给协议引擎，消除了仅剩的一次需要cpu周期的数据复制。</p>
<p><img src="http://qnimages.zhuxingsheng.com/java/transferTov2.gif" alt="transferTo"></p>
<h2 id="ByteBuffer创建"><a href="#ByteBuffer创建" class="headerlink" title="ByteBuffer创建"></a>ByteBuffer创建</h2><p>以上的知识点都是点缀，真正的主角上场了,看下java中是如何抽象上述理论的</p>
<p>ByteBuffer有两种分配buffer的方式：</p>
<p><em>分配HeapByteBuffer</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(int capacity);  </span><br></pre></td></tr></table></figure>

<p><em>分配DirectByteBuffer</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocateDirect(int capacity);  </span><br></pre></td></tr></table></figure>
<p>两者的区别，JDK里面说得很清楚</p>
<blockquote>
<p>A byte buffer is either direct or non-direct. Given a direct byte buffer, the Java virtual machine will make a best effort to perform native I&#x2F;O operations directly upon it. That is, it will attempt to avoid copying the buffer’s content to (or from) an intermediate buffer before (or after) each invocation of one of the underlying operating system’s native I&#x2F;O operations.<br>A direct byte buffer may be created by invoking the allocateDirect factory method of this class. The buffers returned by this method typically have somewhat higher allocation and deallocation costs than non-direct buffers. The contents of direct buffers may reside outside of the normal garbage-collected heap, and so their impact upon the memory footprint of an application might not be obvious. It is therefore recommended that direct buffers be allocated primarily for large, long-lived buffers that are subject to the underlying system’s native I&#x2F;O operations. In general it is best to allocate direct buffers only when they yield a measureable gain in program performance.<br>A direct byte buffer may also be created by mapping a region of a file directly into memory. An implementation of the Java platform may optionally support the creation of direct byte buffers from native code via JNI. If an instance of one of these kinds of buffers refers to an inaccessible region of memory then an attempt to access that region will not change the buffer’s content and will cause an unspecified exception to be thrown either at the time of the access or at some later time. </p>
</blockquote>
<p>从文中大致可以看到DirectByteBuffer的特点如下：</p>
<ul>
<li>对于native IO operation，JVM会有最佳的性能效果(它不需要一个中间缓冲区，而是可以直接使用，避免了将buffer中的数据再复制到中间缓冲区)。</li>
<li>由于DirectByteBuffer分配与native memory中，不在heap区，不会受到heap区的gc影响。（一般在old gen的full gc才会收集。）</li>
<li>分配和释放需要更多的成本。<br><img src="http://qnimages.zhuxingsheng.com/java/bytebuffer-choise.jpg" alt="bytebuffer"></li>
</ul>
<p>从上可以总结DirectByteBuffer大致的应用场景如下（socket通信和大文件处理还是比较适用的）：</p>
<ul>
<li>频繁的native IO操作。</li>
<li>系统的要求处理响应速度快和稳定，即高吞吐和低延迟。</li>
<li>ByteBuffer的生命周期长且容量需求较大，会占用较多的内存空间。<br><img src="http://qnimages.zhuxingsheng.com/java/bytebuffer-choise1.jpg" alt="bytebuffer"></li>
</ul>
<p>看下代码，更直观一些</p>
<h3 id="HeapByteBuffer"><a href="#HeapByteBuffer" class="headerlink" title="HeapByteBuffer"></a>HeapByteBuffer</h3><p>分配在堆上的，直接由Java虚拟机负责垃圾收集，你可以把它想象成一个字节数组的包装类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class HeapByteBuffer</span><br><span class="line">    extends ByteBuffer</span><br><span class="line">&#123;</span><br><span class="line">    HeapByteBuffer(int cap, int lim) &#123;            // package-private</span><br><span class="line"></span><br><span class="line">        super(-1, 0, lim, cap, new byte[cap], 0);</span><br><span class="line">        /*</span><br><span class="line">        hb = new byte[cap];</span><br><span class="line">        offset = 0;</span><br><span class="line">        */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">public abstract class ByteBuffer</span><br><span class="line">    extends Buffer</span><br><span class="line">    implements Comparable&lt;ByteBuffer&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    // These fields are declared here rather than in Heap-X-Buffer in order to</span><br><span class="line">    // reduce the number of virtual method invocations needed to access these</span><br><span class="line">    // values, which is especially costly when coding small buffers.</span><br><span class="line">    //</span><br><span class="line">    final byte[] hb;                  // Non-null only for heap buffers</span><br><span class="line">    final int offset;</span><br><span class="line">    boolean isReadOnly;                 // Valid only for heap buffers</span><br><span class="line"></span><br><span class="line">    // Creates a new buffer with the given mark, position, limit, capacity,</span><br><span class="line">    // backing array, and array offset</span><br><span class="line">    //</span><br><span class="line">    ByteBuffer(int mark, int pos, int lim, int cap,   // package-private</span><br><span class="line">                 byte[] hb, int offset)</span><br><span class="line">    &#123;</span><br><span class="line">        super(mark, pos, lim, cap);</span><br><span class="line">        this.hb = hb;</span><br><span class="line">        this.offset = offset;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h3 id="DirectByteBuffer"><a href="#DirectByteBuffer" class="headerlink" title="DirectByteBuffer"></a>DirectByteBuffer</h3><p>这个类就没有HeapByteBuffer简单了</p>
<p><strong>DirectByteBuffer结构</strong></p>
<p><img src="http://qnimages.zhuxingsheng.com/java/directbyebuffer-struts.png" alt="DirectByteBuffer结构"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DirectByteBuffer(int cap) &#123;                   // package-private</span><br><span class="line"></span><br><span class="line">        super(-1, 0, cap, cap);</span><br><span class="line">        boolean pa = VM.isDirectMemoryPageAligned();</span><br><span class="line">        int ps = Bits.pageSize();</span><br><span class="line">        long size = Math.max(1L, (long)cap + (pa ? ps : 0));</span><br><span class="line">        Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">        long base = 0;</span><br><span class="line">        try &#123;</span><br><span class="line">            base = unsafe.allocateMemory(size);</span><br><span class="line">        &#125; catch (OutOfMemoryError x) &#123;</span><br><span class="line">            Bits.unreserveMemory(size, cap);</span><br><span class="line">            throw x;</span><br><span class="line">        &#125;</span><br><span class="line">        unsafe.setMemory(base, size, (byte) 0);</span><br><span class="line">        if (pa &amp;&amp; (base % ps != 0)) &#123;</span><br><span class="line">            // Round up to page boundary</span><br><span class="line">            address = base + ps - (base &amp; (ps - 1));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            address = base;</span><br><span class="line">        &#125;</span><br><span class="line">        cleaner = Cleaner.create(this, new Deallocator(base, size, cap));</span><br><span class="line">        att = null;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Bits.reserveMemory(size, cap) 方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">static void reserveMemory(long size, int cap) &#123;</span><br><span class="line">        synchronized (Bits.class) &#123;</span><br><span class="line">            if (!memoryLimitSet &amp;&amp; VM.isBooted()) &#123;</span><br><span class="line">                maxMemory = VM.maxDirectMemory();</span><br><span class="line">                memoryLimitSet = true;</span><br><span class="line">            &#125;</span><br><span class="line">            // -XX:MaxDirectMemorySize limits the total capacity rather than the</span><br><span class="line">            // actual memory usage, which will differ when buffers are page</span><br><span class="line">            // aligned.</span><br><span class="line">            if (cap &lt;= maxMemory - totalCapacity) &#123;</span><br><span class="line">                reservedMemory += size;</span><br><span class="line">                totalCapacity += cap;</span><br><span class="line">                count++;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(100);</span><br><span class="line">        &#125; catch (InterruptedException x) &#123;</span><br><span class="line">            // Restore interrupt status</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        synchronized (Bits.class) &#123;</span><br><span class="line">            if (totalCapacity + cap &gt; maxMemory)</span><br><span class="line">                throw new OutOfMemoryError(&quot;Direct buffer memory&quot;);</span><br><span class="line">            reservedMemory += size;</span><br><span class="line">            totalCapacity += cap;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在DirectByteBuffer中，首先向Bits类申请额度，Bits类有一个全局的totalCapacity变量，记录着全部DirectByteBuffer的总大小，每次申请，都先看看是否超限,堆外内存的限额默认与堆内内存(由-Xmx 设定)相仿，可用 -XX:MaxDirectMemorySize 重新设定。</p>
<p>如果不指定，该参数的默认值为Xmx的值减去1个Survior区的值。</p>
<blockquote>
<p>如设置启动参数-Xmx20M -Xmn10M -XX：SurvivorRatio&#x3D;8,那么申请20M-1M&#x3D;19M的DirectMemory</p>
</blockquote>
<p>如果已经超限，会主动执行Sytem.gc()，期待能主动回收一点堆外内存。</p>
<blockquote>
<p>System.gc()会触发一个full gc，当然前提是你没有显示的设置-XX:+DisableExplicitGC来禁用显式GC。并且你需要知道，调用System.gc()并不能够保证full gc马上就能被执行。</p>
</blockquote>
<blockquote>
<p>所以在使用netty这类框架时，一定要注意JVM优化，如果DisableExplicitGC那就可能会OOM了</p>
</blockquote>
<p>然后休眠一百毫秒，看看totalCapacity降下来没有，如果内存还是不足，就抛出OOM异常。如果额度被批准，就调用大名鼎鼎的sun.misc.Unsafe去分配内存,返回内存基地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Used only by direct buffers</span><br><span class="line">// NOTE: hoisted here for speed in JNI GetDirectBufferAddress</span><br><span class="line">long address;</span><br></pre></td></tr></table></figure>
<p>这样我们后面通过JNI对这个堆外内存操作时都是通过这个address来实现的了。</p>
<p>Unsafe的<a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/prims/unsafe.cpp#l583">C++实现在此</a>，标准的malloc。然后再调一次Unsafe把这段内存给清零。跑个题，Unsafe的名字是提醒大家这个类只给Sun自家用的</p>
<p>JDK7开始，DirectByteBuffer分配内存时默认已不做分页对齐，不会再每次分配并清零实际需要＋分页大小(4k)的内存，这对性能应有较大提升，所以Oracle专门写在了<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/io/enhancements.html#jdk7">Enhancements in Java I&#x2F;O</a>里。</p>
<p>最后，创建一个Cleaner，并把代表清理动作的Deallocator类绑定 – 降低Bits里的totalCapacity，并调用Unsafe调free去释放内存。Cleaner的触发机制后面再说。</p>
<p>DirectByteBuffer中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">byte _get(int i) &#123;                          // package-private</span><br><span class="line">        return unsafe.getByte(address + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">void _put(int i, byte b) &#123;                  // package-private</span><br><span class="line"></span><br><span class="line">    unsafe.putByte(address + i, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前面我们说过，在linux中内核态的权限是最高的，那么在内核态的场景下，操作系统是可以访问任何一个内存区域的，所以操作系统是可以访问到Java堆的这个内存区域的。</p>
<p>Q：那为什么操作系统不直接访问Java堆内的内存区域了？</p>
<p>A：这是因为JNI方法访问的内存区域是一个已经确定了的内存区域地质，那么该内存地址指向的是Java堆内内存的话，那么如果在操作系统正在访问这个内存地址的时候，Java在这个时候进行了GC操作，而GC操作会涉及到数据的移动操作[GC经常会进行先标志在压缩的操作。即，将可回收的空间做标志，然后清空标志位置的内存，然后会进行一个压缩，压缩就会涉及到对象的移动，移动的目的是为了腾出一块更加完整、连续的内存空间，以容纳更大的新对象]，数据的移动会使JNI调用的数据错乱。所以JNI调用的内存是不能进行GC操作的，JNI不能直接访问Java堆内的内存区域</p>
<p>Q：如上面所说，JNI不能直接访问Java堆内的内存区域，那该如何解决了？</p>
<p>A：①堆内内存与堆外内存之间数据拷贝的方式(并且在将堆内内存拷贝到堆外内存的过程JVM会保证不会进行GC操作)：</p>
<p>比如我们要完成一个从文件中读数据到堆内内存的操作，即FileChannelImpl.read(HeapByteBuffer)。这里实际上File I&#x2F;O会将数据读到堆外内存中，然后堆外内存再讲数据拷贝到堆内内存，这样我们就读到了文件中的内存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public int read(ByteBuffer var1) throws IOException &#123;</span><br><span class="line">        this.ensureOpen();</span><br><span class="line">        if(!this.readable) &#123;</span><br><span class="line">            throw new NonReadableChannelException();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Object var2 = this.positionLock;</span><br><span class="line">            synchronized(this.positionLock) &#123;</span><br><span class="line">                int var3 = 0;</span><br><span class="line">                int var4 = -1;</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    this.begin();</span><br><span class="line">                    var4 = this.threads.add();</span><br><span class="line">                    if(!this.isOpen()) &#123;</span><br><span class="line">                        byte var12 = 0;</span><br><span class="line">                        return var12;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        do &#123;</span><br><span class="line">                            //关键点在这行</span><br><span class="line">                            var3 = IOUtil.read(this.fd, var1, -1L, this.nd);</span><br><span class="line">                        &#125; while(var3 == -3 &amp;&amp; this.isOpen());</span><br><span class="line"></span><br><span class="line">                        int var5 = IOStatus.normalize(var3);</span><br><span class="line">                        return var5;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    this.threads.remove(var4);</span><br><span class="line">                    this.end(var3 &gt; 0);</span><br><span class="line"></span><br><span class="line">                    assert IOStatus.check(var3);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><em>IOUtil</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static int read(FileDescriptor var0, ByteBuffer var1, long var2, NativeDispatcher var4) throws IOException &#123;</span><br><span class="line">        if (var1.isReadOnly()) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Read-only buffer&quot;);</span><br><span class="line">        &#125; else if (var1 instanceof DirectBuffer) &#123;</span><br><span class="line">            return readIntoNativeBuffer(var0, var1, var2, var4);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 分配临时的堆外内存</span><br><span class="line">            ByteBuffer var5 = Util.getTemporaryDirectBuffer(var1.remaining());</span><br><span class="line"> </span><br><span class="line">            int var7;</span><br><span class="line">            try &#123;</span><br><span class="line">                // File I/O 操作会将数据读入到堆外内存中</span><br><span class="line">                int var6 = readIntoNativeBuffer(var0, var5, var2, var4);</span><br><span class="line">                var5.flip();</span><br><span class="line">                if (var6 &gt; 0) &#123;</span><br><span class="line">                    // 将堆外内存的数据拷贝到堆内内存中</span><br><span class="line">                    var1.put(var5);</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                var7 = var6;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                // 里面会调用DirectBuffer.cleaner().clean()来释放临时的堆外内存</span><br><span class="line">                Util.offerFirstTemporaryDirectBuffer(var5);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            return var7;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>而写操作则反之，我们会将堆内内存的数据线写到对堆外内存中，然后操作系统会将堆外内存的数据写入到文件中。</p>
<p>假设我们要从网络中读入一段数据，再把这段数据发送出去的话，采用Non-direct ByteBuffer的流程是这样的：</p>
<blockquote>
<p>网络 –&gt; 临时的Direct ByteBuffer –&gt; 应用 Non-direct ByteBuffer –&gt; 临时的Direct ByteBuffer –&gt; 网络</p>
</blockquote>
<p>② 直接使用堆外内存，如DirectByteBuffer：</p>
<p>这种方式是直接在堆外分配一个内存(即，native memory)来存储数据，<br>程序通过JNI直接将数据读&#x2F;写到堆外内存中。因为数据直接写入到了堆外内存中，所以这种方式就不会再在JVM管控的堆内再分配内存来存储数据了，也就不存在堆内内存和堆外内存数据拷贝的操作了。这样在进行I&#x2F;O操作时，只需要将这个堆外内存地址传给JNI的I&#x2F;O的函数就好了。</p>
<p>采用Direct ByteBuffer的流程是这样的：</p>
<blockquote>
<p>网络 –&gt; 应用 Direct ByteBuffer –&gt; 网络</p>
</blockquote>
<p>可以看到，除开构造和析构临时Direct ByteBuffer的时间外，起码还能节约两次内存拷贝的时间。那么是否在任何情况下都采用Direct Buffer呢？</p>
<p>不是。对于大部分应用而言，两次内存拷贝的时间几乎可以忽略不计，而构造和析构DirectBuffer的时间却相对较长。在JVM的实现当中，某些方法会缓存一部分临时Direct ByteBuffer，意味着如果采用Direct ByteBuffer仅仅能节约掉两次内存拷贝的时间，<br>而无法节约构造和析构的时间。就用Sun的实现来说，write(ByteBuffer)和read(ByteBuffer)方法都会缓存临时Direct ByteBuffer，而write(ByteBuffer[])和read(ByteBuffer[])每次都生成新的临时Direct ByteBuffer。</p>
<p>根据这些区别，如下的建议：</p>
<ul>
<li>如果你做中小规模的应用（在这里，应用大小是按照使用ByteBuffer的次数和规模来做划分的），而且并不在乎这该死的细节问题，请选择Non-direct ByteBuffer</li>
<li>如果采用Direct ByteBuffer后性能并没有出现你所期待的变化，请选择Non-direct ByteBuffer</li>
<li>如果没有Direct ByteBuffer Pool，尽量不要使用Direct ByteBuffer</li>
<li>除非你确定该ByteBuffer会长时间存在，并且和外界有频繁交互，可采用Direct ByteBuffer</li>
<li>如果采用Non-direct ByteBuffer，那么采用非聚集(gather)的write&#x2F;read(ByteBuffer)效果反而可能超出聚集的write&#x2F;read(ByteBuffer[])，因为聚集的write&#x2F;read的临时Direct ByteBuffer是非缓存的</li>
</ul>
<p>基本上，采用Non-direct ByteBuffer总是对的！因为内存拷贝需要的开销对大部分应用而言都可以忽略不计。</p>
<h2 id="ByteBuffer回收"><a href="#ByteBuffer回收" class="headerlink" title="ByteBuffer回收"></a>ByteBuffer回收</h2><p>HeapByteBuffer就不要说了，GC就帮忙处理了。这儿主要说下DirectByteBuffer</p>
<h3 id="基于GC回收DirectByteBuffer"><a href="#基于GC回收DirectByteBuffer" class="headerlink" title="基于GC回收DirectByteBuffer"></a>基于GC回收DirectByteBuffer</h3><p>存在于堆内的DirectByteBuffer对象很小，只存着基地址和大小等几个属性，和一个Cleaner，但它代表着后面所分配的一大段内存，是所谓的冰山对象。</p>
<p>在内存中基本是这样子<br><img src="http://qnimages.zhuxingsheng.com/java/off-heap-memory-before.png" alt="off-heap-memory"><br>其中first是Cleaner类的静态变量，Cleaner对象在初始化时会被添加到Clener链表中，和first形成引用关系，ReferenceQueue是用来保存需要回收的Cleaner对象。</p>
<p>如果该DirectByteBuffer对象在一次GC中被回收了<br><img src="http://qnimages.zhuxingsheng.com/java/off-heap-memory.png" alt="off-heap-memory"><br>此时，只有Cleaner对象唯一保存了堆外内存的数据（开始地址、大小和容量），在下一次Full GC时，把该Cleaner对象放入到ReferenceQueue中，并触发clean方法。</p>
<p>快速回顾一下堆内的GC机制，当新生代满了，就会发生young gc；如果此时对象还没失效，就不会被回收；撑过几次young gc后，对象被迁移到老生代；当老生代也满了，就会发生full gc。</p>
<p>这里可以看到一种尴尬的情况，因为DirectByteBuffer本身的个头很小，只要熬过了young gc，即使已经失效了也能在老生代里舒服的呆着，不容易把老生代撑爆触发full gc，如果没有别的大块头进入老生代触发full gc，就一直在那耗着，占着一大片堆外内存不释放。</p>
<p>这时，就只能靠前面提到的申请额度超限时触发的system.gc()来救场了。但这道最后的保险其实也不很好，首先它会中断整个进程，然后它让当前线程睡了整整一百毫秒，而且如果gc没在一百毫秒内完成，它仍然会无情的抛出OOM异常。还有，万一，万一大家迷信某个调优指南设置了-DisableExplicitGC禁止了system.gc()，那就不好玩了。</p>
<p>所以，堆外内存还是自己主动点回收更好，比如Netty就是这么做的</p>
<h3 id="主动回收DirectByteBuffer"><a href="#主动回收DirectByteBuffer" class="headerlink" title="主动回收DirectByteBuffer"></a>主动回收DirectByteBuffer</h3><p>对于Sun的JDK这其实很简单，只要从DirectByteBuffer里取出那个sun.misc.Cleaner，然后调用它的clean()就行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocateDirect(1024 * 1024 * 500);</span><br><span class="line">((DirectBuffer)byteBuffer).cleaner().clean();</span><br></pre></td></tr></table></figure>

<p>前面说的，clean()执行时实际调用的是被绑定的Deallocator类，这个类可被重复执行，释放过了就不再释放。所以GC时再被动执行一次clean()也没所谓。</p>
<p>在Netty里，因为不确定跑在Sun的JDK里(比如安卓)，所以多废了些功夫来确定Cleaner的存在</p>
<h3 id="Cleaner类"><a href="#Cleaner类" class="headerlink" title="Cleaner类"></a>Cleaner类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Cleaner extends PhantomReference&lt;Object&gt; &#123;</span><br><span class="line">    private static final ReferenceQueue&lt;Object&gt; dummyQueue = new ReferenceQueue();</span><br><span class="line">    private static Cleaner first = null;</span><br><span class="line">    private Cleaner next = null;</span><br><span class="line">    private Cleaner prev = null;</span><br><span class="line">    private final Runnable thunk;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>PhantomReference 这个虚引用类很少见，它是java中最弱的引用类型</p>
<blockquote>
<p>PhantomReference 类只能用于跟踪对被引用对象即将进行的收集。</p>
</blockquote>
<blockquote>
<p>同样，它还能用于执行 pre-mortem 清除操作。 PhantomReference 必须与 ReferenceQueue 类一起使用。需要 ReferenceQueue 是因为它能够充当通知机制。当垃圾收集器确定了某个对象是虚可及对象时， PhantomReference 对象就被放在它的 ReferenceQueue 上。将 PhantomReference 对象放在 ReferenceQueue 上也就是一个通知，表明 PhantomReference 对象引用的对象已经结束，可供收集了。这使您能够刚好在对象占用的内存被回收之前采取行动。</p>
</blockquote>
<p>当GC时发现它除了PhantomReference外已不可达（持有它的DirectByteBuffer失效了），就会把它放进 Reference类pending list静态变量里。然后另有一条ReferenceHandler线程，名字叫 “Reference Handler”的，关注着这个pending list，如果看到有对象类型是Cleaner，就会执行它的clean()，其他类型就放入应用构造Reference时传入的ReferenceQueue中，这样应用的代码可以从Queue里拖出这些理论上已死的对象，做爱做的事情——这是一种比finalizer更轻量更好的机制。</p>
<p><img src="http://qnimages.zhuxingsheng.com/java/cleaner.png" alt="cleaner"><br>比如创建DirectByteBuffer，会新建Cleaner对象，该对象添加到Cleaner链表中。<br>对象被GC，如果是Cleaner对象，则会执行该对象的clean方法,<br>Clean方法会将对应的cleaner对象从链表中移除，同时会回收DirectByteBuffer申请的资源</p>
<p>看下ReferenceHandler源码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/* High-priority thread to enqueue pending References</span><br><span class="line">     */</span><br><span class="line">    private static class ReferenceHandler extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        ReferenceHandler(ThreadGroup g, String name) &#123;</span><br><span class="line">            super(g, name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                Reference&lt;Object&gt; r;</span><br><span class="line">                synchronized (lock) &#123;</span><br><span class="line">                    if (pending != null) &#123;</span><br><span class="line">                        r = pending;</span><br><span class="line">                        pending = r.discovered;</span><br><span class="line">                        r.discovered = null;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // The waiting on the lock may cause an OOME because it may try to allocate</span><br><span class="line">                        // exception objects, so also catch OOME here to avoid silent exit of the</span><br><span class="line">                        // reference handler thread.</span><br><span class="line">                        //</span><br><span class="line">                        // Explicitly define the order of the two exceptions we catch here</span><br><span class="line">                        // when waiting for the lock.</span><br><span class="line">                        //</span><br><span class="line">                        // We do not want to try to potentially load the InterruptedException class</span><br><span class="line">                        // (which would be done if this was its first use, and InterruptedException</span><br><span class="line">                        // were checked first) in this situation.</span><br><span class="line">                        //</span><br><span class="line">                        // This may lead to the VM not ever trying to load the InterruptedException</span><br><span class="line">                        // class again.</span><br><span class="line">                        try &#123;</span><br><span class="line">                            try &#123;</span><br><span class="line">                                lock.wait();</span><br><span class="line">                            &#125; catch (OutOfMemoryError x) &#123; &#125;</span><br><span class="line">                        &#125; catch (InterruptedException x) &#123; &#125;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Fast path for cleaners</span><br><span class="line">                if (r instanceof Cleaner) &#123;</span><br><span class="line">                    ((Cleaner)r).clean();</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ReferenceQueue&lt;Object&gt; q = r.queue;</span><br><span class="line">                if (q != ReferenceQueue.NULL) q.enqueue(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>回顾下Finalize回收</strong></p>
<p>sun不推荐实现finalize，实际上JDK内部很多类都实现了finalize。</p>
<p><img src="http://qnimages.zhuxingsheng.com/java/finalize.png" alt="finalize"></p>
<p>如果对象实现了finalize，在对象初始化后,会封装成Finalizer对象添加到 Finalizer链表中。</p>
<p>对象被GC时，如果是Finalizer对象，会将对象赋值到pending对象。Reference Handler线程会将pending对象push到queue中。</p>
<p>Finalizer线程poll到对象，先删除掉Finalizer链表中对应的对象，然后再执行对象的finalize方法(一般为资源的销毁)</p>
<p>方案的缺点：</p>
<ol>
<li>对象至少跨越2个GC，垃圾对象无法及时被GC掉，并且存在多次拷贝。影响YGC和FGC</li>
<li>Finalizer线程优先级较低，会导致finalize方法延迟执行</li>
</ol>
<h1 id="开源堆外缓存框架"><a href="#开源堆外缓存框架" class="headerlink" title="开源堆外缓存框架"></a>开源堆外缓存框架</h1><ul>
<li>Ehcache 3.0：3.0基于其商业公司一个非开源的堆外组件的实现。</li>
<li>Chronical Map：OpenHFT包括很多类库，使用这些类库很少产生垃圾，并且应用程序使用这些类库后也很少发生Minor GC。类库主要包括：Chronicle Map，Chronicle Queue等等。</li>
<li>OHC：来源于Cassandra 3.0， Apache v2。</li>
<li>Ignite: 一个规模宏大的内存计算框架，属于Apache项目。</li>
</ul>
<h2 id="OHC"><a href="#OHC" class="headerlink" title="OHC"></a>OHC</h2><p>DirectByteBuffer是使用unsafe(JNI)申请堆外空间(unsafe.allocateMemory(size))。还有一种申请堆外空间的手段：JNA。</p>
<p>JNA的描述(<a href="https://github.com/java-native-access/jna">https://github.com/java-native-access/jna</a>)</p>
<p>JNA provides Java programs easy access to native shared libraries without writing anything but Java code - no JNI or native code is required</p>
<p>堆外缓存OHC便是使用JNA来申请堆外空间。</p>
<p>线下测试：JNA内存申请的性能是unsafe（JNI）的2倍。</p>
<h3 id="Why-not-use-ByteBuffer-allocateDirect"><a href="#Why-not-use-ByteBuffer-allocateDirect" class="headerlink" title="Why not use ByteBuffer.allocateDirect()?"></a>Why not use ByteBuffer.allocateDirect()?</h3><blockquote>
<p>TL;DR allocating off-heap memory directly and bypassing ByteBuffer.allocateDirect is very gentle to the GC and we have explicit control over memory allocation and, more importantly, free. The stock implementation in Java frees off-heap memory during a garbage collection - also: if no more off-heap memory is available, it likely triggers a Full-GC, which is problematic if multiple threads run into that situation concurrently since it means lots of Full-GCs sequentially. Further, the stock implementation uses a global, synchronized linked list to track off-heap memory allocations.</p>
</blockquote>
<blockquote>
<p>This is why OHC allocates off-heap memory directly and recommends to preload jemalloc on Linux systems to improve memory managment performance.</p>
</blockquote>
<p>这是OHC的wiki说明</p>
<p>其实OHC实现了JNI(malloc),JNA(jemalloc)两种方式，默认使用了JNA(jemalloc),性能的提升最关键的是malloc与jemalloc的区别了</p>
<p><img src="http://qnimages.zhuxingsheng.com/off-heap/allocator.png" alt="ohc-allocator"></p>
<p>在org.caffinitas.ohc.chunked.Uns类中，创建IAllocator类片段代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private static final String __ALLOCATOR = System.getProperty(OHCacheBuilder.SYSTEM_PROPERTY_PREFIX + &quot;allocator&quot;);</span><br><span class="line"></span><br><span class="line">IAllocator alloc;</span><br><span class="line">            String allocType = __ALLOCATOR != null ? __ALLOCATOR : &quot;jna&quot;;</span><br><span class="line">            switch (allocType)</span><br><span class="line">            &#123;</span><br><span class="line">                case &quot;unsafe&quot;:</span><br><span class="line">                    alloc = new UnsafeAllocator();</span><br><span class="line">                    LOGGER.info(&quot;OHC using sun.misc.Unsafe memory allocation&quot;);</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;jna&quot;:</span><br><span class="line">                default:</span><br><span class="line">                    alloc = new JNANativeAllocator();</span><br><span class="line">                    LOGGER.info(&quot;OHC using JNA OS native malloc/free&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            allocator = alloc;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>UnsafeAllocator</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Field field = sun.misc.Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">field.setAccessible(true);</span><br><span class="line">unsafe = (sun.misc.Unsafe) field.get(null);</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">public long allocate(long size)</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            return unsafe.allocateMemory(size);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (OutOfMemoryError oom)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0L;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>JNANativeAllocator</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public long allocate(long size)</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            return Native.malloc(size);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (OutOfMemoryError oom)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0L;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>OHC这只是一个开端，只是分配内存部分，它还有淘汰策略等等，之后说缓存时，再谈了</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://calvin1978.blogcn.com/articles/directbytebuffer.html">Netty之Java堆外内存扫盲贴</a></p>
<p><a href="https://yq.aliyun.com/articles/66875">千丝万缕的FGC与Buffer pool</a></p>
<p><a href="https://yq.aliyun.com/articles/2948">JVM源码分析之堆外内存完全解读</a></p>
<p><a href="http://www.infoq.com/cn/articles/jvm-source-code-analysis-finalreference">JVM源码分析之FinalReference完全解读</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://www.zhuxingsheng.com/blog/kung-fu-is-beyond-poetry.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="朱兴生">
      <meta itemprop="description" content="彪悍的人生需要书写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码农戏码">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/kung-fu-is-beyond-poetry.html" class="post-title-link" itemprop="url">功夫在诗外</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-12-17 13:10:00" itemprop="dateCreated datePublished" datetime="2017-12-17T13:10:00+08:00">2017-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-29 15:24:30" itemprop="dateModified" datetime="2021-09-29T15:24:30+08:00">2021-09-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="功夫在诗外"><a href="#功夫在诗外" class="headerlink" title="功夫在诗外"></a>功夫在诗外</h1><p>算是对今年，以及去年这两年的读书的一点思考，总结</p>
<p>为什么会有去年，因为今年读书过程中，让人不自然地想起了去年的类似内容。说的书类型不重复，但出现了很多相同的内容</p>
<p>可能与这些内容有缘分</p>
<h1 id="迷思"><a href="#迷思" class="headerlink" title="迷思"></a>迷思</h1><p>每次跳槽的时候，都会去思考我的核心竞争力到底是什么？这个问题代表了两个对立的思想一方面代表了不自知，迷茫，对未来的焦虑；另一方面代表了自不知，三人有我师，前进的动力。</p>
<p>职场规划一片迷茫，股票所学也是一无长进，甚是苦恼。<br>想起了陆游的这句话，《汝果欲学诗，功夫在诗外》；所以去年开始读了很多与专业不相关的书籍。</p>
<p>名人传记，历史书籍，小说，这类书的价值在于引导成长；</p>
<p>心智，心理类也是所好，可惜所得甚少。一些书籍还得多读，多思</p>
<p>如《乌合之众》，知了很多年，却没读得很少，也没读懂。</p>
<p>路漫漫其修远兮</p>
<h1 id="所得"><a href="#所得" class="headerlink" title="所得"></a>所得</h1><p>在读《超级交易者》上半段时，突然有了一细细恍惚。好些内容都似曾相识，让人不得不想起一句老话，失败者的失败各有各的不同，而成功者的成功却具有惊人的相似之处。</p>
<h2 id="责任"><a href="#责任" class="headerlink" title="责任"></a>责任</h2><p>这个词就像是个空词，人人都会把这个词挂在嘴边，但何为责任，责任有何妙处</p>
<p>这在《人生五章》诗中也有体现</p>
<p>《人生五章》 </p>
<p>1、 </p>
<p>我走上街， </p>
<p>人行道上有一个深洞， </p>
<p>我掉了进去。 </p>
<p>我迷失了……我绝望了。 </p>
<p>这不是我的错， </p>
<p>费了好大的劲才爬出来。 </p>
<p>2、 </p>
<p>我走上同一条街。 </p>
<p>人行道上有一个深洞， </p>
<p>我假装没看到， </p>
<p>还是掉了进去。 </p>
<p>我不能相信我居然会掉在同样的地方。 </p>
<p>但这不是我的错。 </p>
<p>还是花了很长的时间才爬出来。 </p>
<p>3、 </p>
<p>我走上同一条街。 </p>
<p>人行道上有一个深洞， </p>
<p>我看到它在那儿， </p>
<p>但还是掉了进去…… </p>
<p>这是一种习惯。 </p>
<p>我的眼睛张开着， </p>
<p>我知道我在那儿。 </p>
<p>这是我的错。 </p>
<p>我立刻爬了出来。 </p>
<p>4、 </p>
<p>我走上同一条街， </p>
<p>人行道上有一个深洞， </p>
<p>我绕道而过。 </p>
<p>5、 </p>
<p>我走上另一条街。</p>
<p>这首诗的内容在读《股票作手加快录》时，就有体会，大意就是一个人从意识到自身问题，到要改变，再到彻底改变的过程是相当艰辛的，习惯上升到性格再到内质的人性，是相当难以改变的。</p>
<p>这一切的改变，自省的起始就在于责任两字，无责任怎么会想到自身问题。</p>
<p>自己永无过错，一切都是别人的问题；代码没问题，是环境问题，自己买卖没问题，是庄家问题。</p>
<h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><p>为什么写作？其实有各种理由</p>
<ul>
<li>文字可以重塑人</li>
<li>写作是与自己的对话，引人思考</li>
<li>输出倒逼输入</li>
<li>形成闭环，输入输出完整的IO系统</li>
<li>写作是睡后收入</li>
</ul>
<p>我算是写作的践行者，有什么意义呢？写作了很多年，有什么益处呢？</p>
<p>之前我是记录时间日志，是在看《时间就是朋友》这本书得来的。</p>
<p>后来李笑来又说要记注意力日志。还没有太多的实践，从时间开销日志来讲，只是发现了自我的浪费时间，这也算是所得之一吧。</p>
<p>从去年开始写博客，为什么要写呢？关键是“形成有效的输入输出系统，以输出倒逼输入”，“写作也记录下学习过程，防止狗咬尾巴”。</p>
<p>现在的博客目标是每篇文章写尽一个知识点，有广度，也得有深度。但任何知识都不是单点，‘台上一分钟，台下十年功’，‘冰山理论’。</p>
<p>晨写也没有以前的质量和数量了，上次交易玫瑰讲了量化：一是两张A4纸，二是得有三十分钟。</p>
<p>还有关键一点，我也疏忽的一点，<strong>没有及时回顾日记。需要温故知新。</strong></p>
<h2 id="冥想"><a href="#冥想" class="headerlink" title="冥想"></a>冥想</h2><p>这个之前实践了几天，后来也没有坚持。这以后还是得有空多练习，看看效果了</p>
<h2 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h2><p>很多人的理想生活就是 读万卷书，行万里路</p>
<p>我现在的读书方法，以及读书效果还是很差，不让人满意。关键是缺少总结，一本书，至少要自己组织语言总结其主旨。</p>
<p>不然读再多的书，还是一无所得，浪费时间，自我心理满足。不能学以致用。</p>
<p>上次读李笑来的财富自由之路，一个读书亮点：慢读。</p>
<p>现在很多的书籍都教人快速阅读以应对当代快速膨胀的知识，以快致胜。而李笑来提出，要慢读。</p>
<p>快速膨胀的是信息，而不是知识。知识的出现需要很久的时间积累。所以要慢读，要有深度，现在流行快餐文化，让世人缺少了深度思考的过程，以致人浮于思，任何事都没有深度，人云亦云。</p>
<h1 id="导图"><a href="#导图" class="headerlink" title="导图"></a>导图</h1><p>对于以上所得共同点，画了张思维导图更能一目了然</p>
<p><img src="http://qnimages.zhuxingsheng.com/book/%E5%8A%9F%E5%A4%AB%E5%9C%A8%E8%AF%97%E5%A4%96.png" alt="image"></p>
<h1 id="书单"><a href="#书单" class="headerlink" title="书单"></a>书单</h1><p>这些书单是今年看过超出一半内容的书籍，有几本是年初读的，现在都已经忘记内容了。主要就是没有写一段自己理解的总结。这些书，明年还会再读，重读。吸取知识的能力实在是差。</p>
<p>《西藏生死书》</p>
<p>《刻意练习》</p>
<p>《简单思考》</p>
<p>《自卑与超越》</p>
<p>《超级交易员》</p>
<p>《我做散户这十年：三万赚到千万》</p>
<p>《走进我的交易室》</p>
<p>《炒股的智慧》</p>
<p>《红尘天幕》</p>
<p>今年没有达到目标，计划是一个月一本的，不找客观原因，明年还得继续努力。育儿方面的内容也得加强。</p>
<p>今年的博客也是打算一月一篇的，也没有正常发布。</p>
<p>计划是用来执行的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://www.zhuxingsheng.com/blog/microservices---monitoring.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="朱兴生">
      <meta itemprop="description" content="彪悍的人生需要书写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码农戏码">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/microservices---monitoring.html" class="post-title-link" itemprop="url">微服务-监控</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-10-15 21:29:36" itemprop="dateCreated datePublished" datetime="2017-10-15T21:29:36+08:00">2017-10-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-29 15:24:30" itemprop="dateModified" datetime="2021-09-29T15:24:30+08:00">2021-09-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇其实本来也打算放在《常识》系列中的，介绍一下分布式日志追踪系统，这在互联网界理论，技术，产品已经很成熟，国内外各大厂都有自己成熟的产品。是个不错的互联网门外汉科普知识点</p>
<p>微服务，已经火了多年，也已经落地实施。对服务的监控需求顺理成章。监控系统的本质其实也就是分布式日志追踪系统。就归类到《微服务》系列中吧</p>
<p>本篇大体内容</p>
<ol>
<li>《微服务设计》第八章监控</li>
<li>监控理念Dapper</li>
<li>流行监控框架架构</li>
<li>aspectj</li>
</ol>
<h1 id="《微服务》之监控"><a href="#《微服务》之监控" class="headerlink" title="《微服务》之监控"></a>《微服务》之监控</h1><p>本来是说，要写个读书笔记的，但没有那么多完整的时间，正好学习监控，就把书拿出来，一并读了。理论结合实践，效果更好。</p>
<h2 id="监控模型"><a href="#监控模型" class="headerlink" title="监控模型"></a>监控模型</h2><p>三种监控模型</p>
<ol>
<li>单一服务，单一服务器</li>
<li>单一服务，多个服务器</li>
<li>多个服务，多个服务器</li>
</ol>
<h3 id="单一服务单一服务器"><a href="#单一服务单一服务器" class="headerlink" title="单一服务单一服务器"></a>单一服务单一服务器</h3><ol>
<li>主机状态</li>
</ol>
<p>CPU、内存等，可以使用监控软件Nagios,Zabbix或者像New Relic这样的托管服务来帮助监控主机</p>
<ol start="2">
<li>服务状态</li>
</ol>
<p>直接查看服务应用日志，或者web容器日志</p>
<h3 id="单一服务多个服务器"><a href="#单一服务多个服务器" class="headerlink" title="单一服务多个服务器"></a>单一服务多个服务器</h3><ol>
<li>主机状态</li>
</ol>
<p>这种情况稍微复杂了一点，如前所述，如果我们想监控CPU，当CPU占用率过高时，如果这个问题发生在所有的服务器上，有可能是微服务本身的问题，但如果只发生在一台，则有可能是主机本身的问题。</p>
<p>我们需要关注每台服务器的日志数据，我们既想把数据聚合起来，又想深入分析每台主机，Nagios允许以这样的方式组织我们的主机。</p>
<ol start="2">
<li>服务状态</li>
</ol>
<p>如果只有几个主机，可以用像ssh-multiplexers这样的工具，在多个主机上运行相同的命令。用一个大显示屏，运行grep “Error” app.log来定位错误。对于响应时间，可以在负载均衡器中跟踪，负载均衡器本身也需要跟踪。</p>
<h3 id="多个服务多个服务器"><a href="#多个服务多个服务器" class="headerlink" title="多个服务多个服务器"></a>多个服务多个服务器</h3><p>这个情况就更复杂了，我们如何在多个主机上，成千上万行的日志中定位错误的原因？如果确定是一个服务器异常，还是一个系统性的问题？如何在多个主机跟踪一个错误的调用链，找出引起错误的原因？</p>
<p>答案是：从日志到应用程序指标，集中收集和聚合更可能多的数据</p>
<h2 id="日志，更多的日志"><a href="#日志，更多的日志" class="headerlink" title="日志，更多的日志"></a>日志，更多的日志</h2><p>需要将日志能够集中到一起方便使用</p>
<p>可以使用ELK</p>
<p>ELK由Elasticsearch、Logstash和Kibana三部分组件组成；</p>
<p>Elasticsearch是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。</p>
<p>Logstash是一个完全开源的工具，它可以对你的日志进行收集、分析，并将其存储供以后使用</p>
<p>kibana 是一个开源和免费的工具，它可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助您汇总、分析和搜索重要数据日志</p>
<p><img src="http://qnimages.zhuxingsheng.com/microservice/elk.jpg" alt="image"></p>
<h2 id="监控指标"><a href="#监控指标" class="headerlink" title="监控指标"></a>监控指标</h2><p><strong>系统指标</strong>：比如cpu 内存等，这些可以collectd进行收集</p>
<p><strong>服务指标</strong>：比如接口调用次数，线程池空闲线程数等</p>
<p><strong>语义指标</strong>：类似业务指标，比如订单量，活动用户数等</p>
<h2 id="关联标识"><a href="#关联标识" class="headerlink" title="关联标识"></a>关联标识</h2><p><img src="http://qnimages.zhuxingsheng.com/microservice/biaoshi.png" alt="image"></p>
<p>其实这就是<em>服务追踪</em>，<em>调用链监控</em></p>
<p>因为微服务化后，各种系统之间的调用关系很复杂，因此排查一个问题会比较难受，你不需要一个系统一个系统去找问题。所以服务追踪就变得非常关键。他能够追踪一次会话的所有调用，哪里有了问题，一目了然</p>
<p>这个更详细的后面介绍google的dapper</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>标准化：将监控api标准化。<br>考虑受众：谁看？运营还是开发？<br>更加实时：监控应该具有实时性，出问题第一时间反应。<br>避免级联危险：可以使用hystrix。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>对每个服务</strong>：跟踪请求响应时间、错误率和应用程序级指标；跟踪所有下游服务的健康状态，如调用时间、错误率；标准化如何收集和存储指标；以标准格式讲日志记录到一个标准位置；监控底层操作系统。</p>
<p><strong>对系统</strong>：聚合CPU等主机层级的指标和程序级指标；确保指标存储工具可以在系统和服务级别做聚合，也能查看单台主机信息；指标存储工具允许维护数据足够长时间，以了解趋势；使用单个可查询工具对日志进行聚合和存储；强烈考虑标准化关联标识的使用；了解什么样的情况需要行动，并构造警报和仪表盘；调查对各种指标聚合和统一化的可能性。</p>
<h1 id="Google-Dapper"><a href="#Google-Dapper" class="headerlink" title="Google Dapper"></a>Google Dapper</h1><p><img src="http://qnimages.zhuxingsheng.com/microservice/dapper.png" alt="image"></p>
<p>分布式服务的跟踪系统需要记录在一次特定的请求后系统中完成的所有工作的信息。举个例子，图展现的是一个和5台服务器相关的一个服务，包括：前端（A），两个中间层（B和C），以及两个后端（D和E）。当一个用户（这个用例的发起人）发起一个请求时，首先到达前端，然后发送两个RPC到服务器B和C。B会马上做出反应，但是C需要和后端的D和E交互之后再返还给A，由A来响应最初的请求。对于这样一个请求，简单实用的分布式跟踪的实现，就是为服务器上每一次你发送和接收动作来收集跟踪标识符(message identifiers)和时间戳(timestamped events)。</p>
<p>google dapper译文：<a href="http://bigbully.github.io/Dapper-translation/">http://bigbully.github.io/Dapper-translation/</a></p>
<p>Dapper有三个设计目标：</p>
<ol>
<li><p>低消耗：跟踪系统对在线服务的影响应该做到足够小。</p>
</li>
<li><p>应用级的透明：对于应用的程序员来说，是不需要知道有跟踪系统这回事的。如果一个跟踪系统想生效，就必须需要依赖应用的开发者主动配合，那么这个跟踪系统显然是侵入性太强的。</p>
</li>
<li><p>延展性：Google至少在未来几年的服务和集群的规模，监控系统都应该能完全把控住。</p>
</li>
</ol>
<h1 id="监控框架"><a href="#监控框架" class="headerlink" title="监控框架"></a>监控框架</h1><p>大的互联网公司都有自己的分布式跟踪系统，<br>比如Twitter的zipkin，淘宝的鹰眼，新浪的Watchman，京东的Hydra等</p>
<p>这些系统大多是基于dapper论文而来。</p>
<p><img src="http://qnimages.zhuxingsheng.com/microservice/yanyan.png" alt="image"></p>
<h1 id="aspectj"><a href="#aspectj" class="headerlink" title="aspectj"></a>aspectj</h1><p>监控系统，又名日志追踪系统，那主要还是打印日志嘛。</p>
<p>无侵入性的日志打印，AOP绝对是上选了</p>
<p>写了几个aspectj小示例<br><a href="https://github.com/zhuxingsheng/aspectjdemo">https://github.com/zhuxingsheng/aspectjdemo</a></p>
<p>当然，aspectj只是埋点，后面还有日志存储，实时计算，日志分析，监控展示</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.cnblogs.com/gudi/p/6683653.html">http://www.cnblogs.com/gudi/p/6683653.html</a></p>
<p><a href="http://blog.csdn.net/guwei9111986/article/details/51798394">http://blog.csdn.net/guwei9111986/article/details/51798394</a></p>
<p><a href="http://www.cnblogs.com/wintersun/p/6747355.html">微服务监控案例之一</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://www.zhuxingsheng.com/blog/spring-transactions-in-simple-terms.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="朱兴生">
      <meta itemprop="description" content="彪悍的人生需要书写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码农戏码">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/spring-transactions-in-simple-terms.html" class="post-title-link" itemprop="url">深入浅出spring事务</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-07-11 21:24:00" itemprop="dateCreated datePublished" datetime="2017-07-11T21:24:00+08:00">2017-07-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-29 15:24:30" itemprop="dateModified" datetime="2021-09-29T15:24:30+08:00">2021-09-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/source/" itemprop="url" rel="index"><span itemprop="name">源码解读</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇其实也要归纳到《常识》系列中，但这重点又是spring的介绍，故归档在spring系列中。</p>
<p>工作很多年，除了学生时代学过，事务还真没有用过。过去开发游戏时，完全不用事务；现在互联网开发，也没有使用事务的场景，不要见怪。</p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>对于事务(Transaction)的概念，网上有各种版本，大同小异，</p>
<p>事务就是是由一系列对系统中数据进行读写的操作组成的一个程序执行单元，狭义上的事务特指数据库事务。</p>
<p>事务是一系列的动作，它们综合在一起才是一个完整的工作单元，这些动作必须全部完成，如果有一个失败的话，那么事务就会回滚到最开始的状态，仿佛什么都没发生过一样。 </p>
<p>在企业级应用程序开发中，事务管理必不可少的技术，用来确保数据的完整性和一致性。 </p>
<p>比如你去ATM机取1000块钱，大体有两个步骤：首先输入密码金额，银行卡扣掉1000元钱；然后ATM出1000元钱。这两个步骤必须是要么都执行要么都不执行。如果银行卡扣除了1000块但是ATM出钱失败的话，你将会损失1000元；如果银行卡扣钱失败但是ATM却出了1000块，那么银行将损失1000元。所以，如果一个步骤成功另一个步骤失败对双方都不是好事，如果不管哪一个步骤失败了以后，整个取钱过程都能回滚，也就是完全取消所有操作的话，这对双方都是极好的。 </p>
<h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><p>大名鼎鼎的ACID</p>
<ol>
<li>原子性（Atomicity），事务必须是一个原子的操作序列单元，一次事务只允许存在两种状态，全部成功或全部失败，任何一个操作失败都将导致整个事务失败</li>
<li>一致性（Consistency），事务的执行不能破坏系统数据的完整性和一致性，如果未完成的事务对系统数据的修改有一部分已经写入物理数据库，这时系统数据就处于不一致状态</li>
<li>隔离性（Isolation），在并发环境中，不同的事务操作相同的数据时，虚相互隔离不能相互干扰</li>
<li>持久性（Durability），事务一旦提交，对系统数据的变更就应该是永久的，必须被永久保存下来，即使服务器宕机了，只要数据库能够重新启动，就一定能够恢复到事务成功结束时的状态</li>
</ol>
<h2 id="事务并发处理问题"><a href="#事务并发处理问题" class="headerlink" title="事务并发处理问题"></a>事务并发处理问题</h2><p>如果没有锁定且多个用户同时访问一个数据库，则当他们的事务同时使用相同的数据时可能会发生问题。由于并发操作带来的数据不一致性包括：丢失数据修改、读”脏”数据（脏读）、不可重复读、产生幽灵数据：</p>
<p>假设数据库中有如下一张表：</p>
<p><img src="http://qnimages.zhuxingsheng.com/transaction/data.png" alt="image"></p>
<h3 id="第一类丢失更新-lost-update"><a href="#第一类丢失更新-lost-update" class="headerlink" title="第一类丢失更新(lost update)"></a>第一类丢失更新(lost update)</h3><p><strong>回滚丢失</strong></p>
<p>在完全未隔离事务的情况下，两个事物更新同一条数据资源，某一事物异常终止，回滚造成第一个完成的更新也同时丢失。<br><img src="http://qnimages.zhuxingsheng.com/transaction/lostupdate.png" alt="image"></p>
<p>在T1时刻开启了事务1，T2时刻开启了事务2，</p>
<p>在T3时刻事务1从数据库中取出了id&#x3D;”402881e535194b8f0135194b91310001”的数据，</p>
<p>T4时刻事务2取出了同一条数据，</p>
<p>T5时刻事务1将age字段值更新为30，</p>
<p>T6时刻事务2更新age为35并提交了数据，</p>
<p>但是T7事务1回滚了事务age最后的值依然为20，事务2的更新丢失了，</p>
<p>这种情况就叫做”第一类丢失更新(lost update)”。</p>
<h3 id="脏读-dirty-read"><a href="#脏读-dirty-read" class="headerlink" title="脏读(dirty read)"></a>脏读(dirty read)</h3><p><strong>事务没提交，提前读取</strong></p>
<p>如果第二个事务查询到第一个事务还未提交的更新数据，形成脏读<br><img src="http://qnimages.zhuxingsheng.com/transaction/dirtyread.png" alt="image"></p>
<p>在T1时刻开启了事务1，T2时刻开启了事务2，</p>
<p>在T3时刻事务1从数据库中取出了id&#x3D;”402881e535194b8f0135194b91310001”的数据，</p>
<p>在T5时刻事务1将age的值更新为30，但是事务还未提交，</p>
<p>T6时刻事务2读取同一条记录，获得age的值为30，但是事务1还未提交，</p>
<p>若在T7时刻事务1回滚了事务2的数据就是错误的数据(脏数据)，</p>
<p>这种情况叫做” 脏读(dirty read)”。</p>
<h3 id="虚读-phantom-read"><a href="#虚读-phantom-read" class="headerlink" title="虚读(phantom read)"></a>虚读(phantom read)</h3><p>一个事务执行两次查询，第二次结果集包含第一次中没有或者某些行已被删除，造成两次结果不一致，只是另一个事务在这两次查询中间插入或者删除了数据造成的</p>
<p><img src="http://qnimages.zhuxingsheng.com/transaction/phantomread.png" alt="image"></p>
<p>在T1时刻开启了事务1，T2时刻开启了事务2，</p>
<p>T3时刻事务1从数据库中查询所有记录，记录总共有一条，</p>
<p>T4时刻事务2向数据库中插入一条记录，T6时刻事务2提交事务。</p>
<p>T7事务1再次查询数据数据时，记录变成两条了。</p>
<p>这种情况是”虚读(phantom read)”。</p>
<h3 id="不可重复读-unrepeated-read"><a href="#不可重复读-unrepeated-read" class="headerlink" title="不可重复读(unrepeated read)"></a>不可重复读(unrepeated read)</h3><p>一个事务两次读取同一行数据，结果得到不同状态结果，如中间正好另一个事务更新了该数据，两次结果相异，不可信任<br><img src="http://qnimages.zhuxingsheng.com/transaction/unrepeatedread.png" alt="image"></p>
<p>在T1时刻开启了事务1，T2时刻开启了事务2，</p>
<p>在T3时刻事务1从数据库中取出了id&#x3D;”402881e535194b8f0135194b91310001”的数据，此时age&#x3D;20，</p>
<p>T4时刻事务2查询同一条数据，</p>
<p>T5事务2更新数据age&#x3D;30，T6时刻事务2提交事务，</p>
<p>T7事务1查询同一条数据，发现数据与第一次不一致。</p>
<p>这种情况就是”不可重复读(unrepeated read)”</p>
<h3 id="第二类丢失更新-second-lost-updates"><a href="#第二类丢失更新-second-lost-updates" class="headerlink" title="第二类丢失更新(second lost updates)"></a>第二类丢失更新(second lost updates)</h3><p><strong>覆盖丢失</strong></p>
<p>不可重复读的特殊情况，如果两个事务都读取同一行，然后两个都进行写操作，并提交，第一个事务所做的改变就会丢失。</p>
<p><img src="http://qnimages.zhuxingsheng.com/transaction/secondlostupdates.png" alt="image"></p>
<p>在T1时刻开启了事务1，T2时刻开启了事务2，</p>
<p>T3时刻事务1更新数据age&#x3D;25，</p>
<p>T5时刻事务2更新数据age&#x3D;30，</p>
<p>T6时刻提交事务，</p>
<p>T7时刻事务2提交事务，把事务1的更新覆盖了。</p>
<p>这种情况就是”第二类丢失更新(second lost updates)”。</p>
<h2 id="并发问题总结"><a href="#并发问题总结" class="headerlink" title="并发问题总结"></a>并发问题总结</h2><p>不可重复读的重点是修改 : </p>
<p>同样的条件 ,   你读取过的数据 ,   再次读取出来发现值不一样了 </p>
<p>幻读的重点在于新增或者删除 </p>
<p>同样的条件 ,   第 1 次和第 2 次读出来的记录数不一样 </p>
<p>第一类更新丢失(回滚丢失)</p>
<p>第二类更新丢失(覆盖丢失)</p>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>解决并发问题的途径是什么?答案是：采取有效的隔离机制。怎样实现事务的隔离呢？隔离机制的实现必须使用锁</p>
<p>一般在编程的时候只需要设置隔离等级</p>
<p>数据库系统提供四种事务隔离级别：</p>
<ol>
<li>未提交读（READ UNCOMMITTED ）</li>
</ol>
<p>最低隔离级别，一个事务能读取到别的事务未提交的更新数据，很不安全，可能出现丢失更新、脏读、不可重复读、幻读；</p>
<ol start="2">
<li>提交读（READ COMMITTED）</li>
</ol>
<p>一个事务能读取到别的事务提交的更新数据，不能看到未提交的更新数据，不会出现丢失更新、脏读，但可能出现不可重复读、幻读；<br>3. 可重复读（REPEATABLE READ）</p>
<p>保证同一事务中先后执行的多次查询将返回同一结果，不受其他事务影响，不可能出现丢失更新、脏读、不可重复读，但可能出现幻读；</p>
<ol start="4">
<li>序列化（SERIALIZABLE）</li>
</ol>
<p>最高隔离级别，不允许事务并发执行，而必须串行化执行，最安全，不可能出现更新、脏读、不可重复读、幻读，但是效率最低。</p>
<p><img src="http://qnimages.zhuxingsheng.com/transaction/isolation.jpg" alt="image"></p>
<p>隔离级别越高，数据库事务并发执行性能越差，能处理的操作越少。<br>所以一般地，推荐使用REPEATABLE READ级别保证数据的读一致性。<br>对于幻读的问题，可以通过加锁来防止</p>
<p><img src="http://qnimages.zhuxingsheng.com/transaction/isolation-phr.png" alt="image"></p>
<p>MySQL支持这四种事务等级，默认事务隔离级别是REPEATABLE READ。</p>
<p>Oracle数据库支持READ COMMITTED 和 SERIALIZABLE这两种事务隔离级别，<br>所以Oracle数据库不支持脏读</p>
<p>Oracle数据库默认的事务隔离级别是READ COMMITTED</p>
<p>不可重复读和幻读的区别是，不可重复读对应的表的操作是更改(UPDATE)，而幻读对应的表的操作是插入(INSERT)，两种的应对策略不一样。对于不可重复读，只需要采用行级锁防止该记录被更新即可，而对于幻读必须加个表级锁，防止在表中插入数据</p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="乐观锁-Optimistic-Lock-和悲观锁-Pessimistic-Lock"><a href="#乐观锁-Optimistic-Lock-和悲观锁-Pessimistic-Lock" class="headerlink" title="乐观锁(Optimistic Lock)和悲观锁(Pessimistic Lock)"></a>乐观锁(Optimistic Lock)和悲观锁(Pessimistic Lock)</h4><p>最重要的分类就是乐观锁(Optimistic Lock)和悲观锁(Pessimistic Lock)，这实际上是两种锁策略</p>
<p><strong>乐观锁</strong>，顾名思义就是非常乐观，非常相信真善美，每次去读数据都认为其它事务没有在写数据，所以就不上锁，快乐的读取数据，而只在提交数据的时候判断其它事务是否搞过这个数据了，如果搞过就rollback。乐观锁相当于一种检测冲突的手段，可通过为记录添加版本或添加时间戳来实现。</p>
<p><strong>悲观锁</strong>，对其它事务抱有保守的态度，每次去读数据都认为其它事务想要作祟，所以每次读数据的时候都会上锁，直到取出数据。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性，但随之而来的是各种开销。悲观锁相当于一种避免冲突的手段。</p>
<p><em>选择标准</em>：如果并发量不大，或数据冲突的后果不严重，则可以使用乐观锁；而如果并发量大或数据冲突后果比较严重（对用户不友好），那么就使用悲观锁。</p>
<h4 id="分共享锁（S锁，Shared-Lock）和排他锁（X锁，Exclusive-Lock）"><a href="#分共享锁（S锁，Shared-Lock）和排他锁（X锁，Exclusive-Lock）" class="headerlink" title="分共享锁（S锁，Shared Lock）和排他锁（X锁，Exclusive Lock）"></a>分共享锁（S锁，Shared Lock）和排他锁（X锁，Exclusive Lock）</h4><p>从读写角度，分共享锁（S锁，Shared Lock）和排他锁（X锁，Exclusive Lock），也叫读锁（Read Lock）和写锁（Write Lock）。<br>理解：</p>
<p>持有S锁的事务只读不可写。</p>
<p>如果事务A对数据D加上S锁后，其它事务只能对D加上S锁而不能加X锁。</p>
<p>持有X锁的事务可读可写。</p>
<p>如果事务A对数据D加上X锁后，其它事务不能再对D加锁，直到A对D的锁解除。</p>
<h4 id="表级锁（Table-Lock）和行级锁（Row-Lock）"><a href="#表级锁（Table-Lock）和行级锁（Row-Lock）" class="headerlink" title="表级锁（Table Lock）和行级锁（Row Lock）"></a>表级锁（Table Lock）和行级锁（Row Lock）</h4><p>从锁的粒度角度，主要分为表级锁（Table Lock）和行级锁（Row Lock）。</p>
<p>表级锁将整个表加锁，性能开销最小</p>
<p>用户可以同时进行读操作。当一个用户对表进行写操作时，用户可以获得一个写锁，写锁禁止其他的用户读写操作。写锁比读锁的优先级更高，即使有读操作已排在队列中，一个被申请的写锁仍可以排在所队列的前列。</p>
<p>行级锁仅对指定的记录进行加锁</p>
<p>这样其它进程可以对同一个表中的其它记录进行读写操作。行级锁粒度最小，开销大，能够支持高并发，可能会出现死锁。</p>
<p>MySQL的MyISAM引擎使用表级锁，而InnoDB支持表级锁和行级锁，默认是行级锁。<br>还有BDB引擎使用页级锁，即一次锁定一组记录，并发性介于行级锁和表级锁之间。</p>
<h4 id="三级锁协议"><a href="#三级锁协议" class="headerlink" title="三级锁协议"></a>三级锁协议</h4><p>三级加锁协议是为了保证正确的事务并发操作，事务在读、写数据库对象是需要遵循的加锁规则。</p>
<p>一级封锁协议：事务T在修改数据R之前必须对它加X锁，直到事务结束方可释放。而若事务T只是读数据，不进行修改，则不需加锁，因此一级加锁协议下可能会出现脏读和不可重复读。</p>
<p>二级加锁协议：在一级加锁协议的基础上，加上这样一条规则——事务T在读取数据R之前必须对它加S锁，直到读取完毕以后释放。二级加锁协议下可能会出现不可重复读。</p>
<p>三级加锁协议：在一级加锁协议的基础上，加上这样一条规则——事务T在读取数据R之前必须对它加S锁，直到事务结束方可释放。三级加锁协议避免了脏读和不可重复读的问题</p>
<h1 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h1><p>Spring事务管理的实现有许多细节，如果对整个接口框架有个大体了解会非常有利于我们理解事务</p>
<p><img src="http://qnimages.zhuxingsheng.com/transaction/transaction.jpg" alt="image"></p>
<p><img src="http://qnimages.zhuxingsheng.com/transaction/transaction_1.jpg" alt="image"></p>
<h2 id="Spring事务管理器"><a href="#Spring事务管理器" class="headerlink" title="Spring事务管理器"></a>Spring事务管理器</h2><p>Spring事务管理涉及的接口的联系如下：<br><img src="http://qnimages.zhuxingsheng.com/transaction/spring-interface.png" alt="image"></p>
<p>Spring并不直接管理事务，而是提供了多种事务管理器，他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。 </p>
<p>Spring事务管理器的接口是org.springframework.transaction.PlatformTransactionManager，<br>通过这个接口，Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，</p>
<p>但是具体的实现就是各个平台自己的事情了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * This is the central interface in Spring&#x27;s transaction infrastructure.</span><br><span class="line"> * Applications can use this directly, but it is not primarily meant as API:</span><br><span class="line"> * Typically, applications will work with either TransactionTemplate or</span><br><span class="line"> * declarative transaction demarcation through AOP.</span><br><span class="line"> */</span><br><span class="line">public interface PlatformTransactionManager &#123;</span><br><span class="line">    TransactionStatus getTransaction(TransactionDefinition definition)</span><br><span class="line">        throws TransactionException;</span><br><span class="line">    void commit(TransactionStatus status) throws TransactionException;</span><br><span class="line">    void rollback(TransactionStatus status) throws TransactionException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>标准的jdbc处理事务代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = DataSourceUtils.getConnection();</span><br><span class="line"> //开启事务</span><br><span class="line">conn.setAutoCommit(false);</span><br><span class="line">try &#123;</span><br><span class="line">    Object retVal = callback.doInConnection(conn);</span><br><span class="line">    conn.commit(); //提交事务</span><br><span class="line">    return retVal;</span><br><span class="line">&#125;catch (Exception e) &#123;</span><br><span class="line">    conn.rollback();//回滚事务</span><br><span class="line">    throw e;</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">    conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>spring对应的TranstactionTemplate处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class TransactionTemplate extends DefaultTransactionDefinition</span><br><span class="line">		implements TransactionOperations, InitializingBean &#123;</span><br><span class="line">		</span><br><span class="line">    @Override</span><br><span class="line">	public &lt;T&gt; T execute(TransactionCallback&lt;T&gt; action) throws TransactionException &#123;</span><br><span class="line">		if (this.transactionManager instanceof CallbackPreferringPlatformTransactionManager) &#123;</span><br><span class="line">			return ((CallbackPreferringPlatformTransactionManager) this.transactionManager).execute(this, action);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			TransactionStatus status = this.transactionManager.getTransaction(this);</span><br><span class="line">			T result;</span><br><span class="line">			try &#123;</span><br><span class="line">				result = action.doInTransaction(status);</span><br><span class="line">			&#125;</span><br><span class="line">			catch (RuntimeException ex) &#123;</span><br><span class="line">				// Transactional code threw application exception -&gt; rollback</span><br><span class="line">				rollbackOnException(status, ex);</span><br><span class="line">				throw ex;</span><br><span class="line">			&#125;</span><br><span class="line">			catch (Error err) &#123;</span><br><span class="line">				// Transactional code threw error -&gt; rollback</span><br><span class="line">				rollbackOnException(status, err);</span><br><span class="line">				throw err;</span><br><span class="line">			&#125;</span><br><span class="line">			catch (Exception ex) &#123;</span><br><span class="line">				// Transactional code threw unexpected exception -&gt; rollback</span><br><span class="line">				rollbackOnException(status, ex);</span><br><span class="line">				throw new UndeclaredThrowableException(ex, &quot;TransactionCallback threw undeclared checked exception&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			this.transactionManager.commit(status);</span><br><span class="line">			return result;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的事务管理机制对Spring来说是透明的，它并不关心那些，那些是对应各个平台需要关心的，所以Spring事务管理的一个优点就是为不同的事务API提供一致的编程模型，如JTA、JDBC、Hibernate、JPA。下面分别介绍各个平台框架实现事务管理的机制。</p>
<p><img src="http://qnimages.zhuxingsheng.com/transaction/spring-txmanager.jpg" alt="image"></p>
<h3 id="JDBC事务"><a href="#JDBC事务" class="headerlink" title="JDBC事务"></a>JDBC事务</h3><p>如果应用程序中直接使用JDBC来进行持久化，DataSourceTransactionManager会为你处理事务边界。为了使用DataSourceTransactionManager，你需要使用如下的XML将其装配到应用程序的上下文定义中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>实际上，DataSourceTransactionManager是通过调用java.sql.Connection来管理事务，而后者是通过DataSource获取到的。通过调用连接的commit()方法来提交事务，同样，事务失败则通过调用rollback()方法进行回滚。</p>
<h3 id="Hibernate事务"><a href="#Hibernate事务" class="headerlink" title="Hibernate事务"></a>Hibernate事务</h3><p>如果应用程序的持久化是通过Hibernate实习的，那么你需要使用HibernateTransactionManager。对于Hibernate3，需要在Spring上下文定义中添加如下的<bean>声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>sessionFactory属性需要装配一个Hibernate的session工厂，HibernateTransactionManager的实现细节是它将事务管理的职责委托给org.hibernate.Transaction对象，而后者是从Hibernate Session中获取到的。当事务成功完成时，HibernateTransactionManager将会调用Transaction对象的commit()方法，反之，将会调用rollback()方法。</p>
<h2 id="事务属性"><a href="#事务属性" class="headerlink" title="事务属性"></a>事务属性</h2><p>事务管理器接口PlatformTransactionManager通过getTransaction(TransactionDefinition definition)方法来得到事务，这个方法里面的参数是TransactionDefinition类，这个类就定义了一些基本的事务属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface TransactionDefinition &#123;</span><br><span class="line">    int getPropagationBehavior(); // 返回事务的传播行为</span><br><span class="line">    int getIsolationLevel(); // 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据</span><br><span class="line">    int getTimeout();  // 返回事务必须在多少秒内完成</span><br><span class="line">    boolean isReadOnly(); // 事务是否只读，事务管理器能够根据这个返回值进行优化，确保事务是只读的</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>那么什么是事务属性呢？事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。事务属性包含了5个方面</p>
<p><img src="http://qnimages.zhuxingsheng.com/transaction/spring-attribute.png" alt="image"></p>
<h3 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h3><p>事务的第一个方面是传播行为（propagation behavior）。<br>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。</p>
<p>为什么需要定义传播？</p>
<blockquote>
<p>在我们用SSH开发项目的时候，我们一般都是将事务设置在Service层 那么当我们调用Service层的一个方法的时候它能够保证我们的这个方法中执行的所有的对数据库的更新操作保持在一个事务中，在事务层里面调用的这些方法要么全部成功，要么全部失败。那么事务的传播特性也是从这里说起的。<br>如果你在你的Service层的这个方法中，除了调用了Dao层的方法之外，还调用了本类的其他的Service方法，那么在调用其他的Service方法的时候，这个事务是怎么规定的呢，我必须保证我在我方法里掉用的这个方法与我本身的方法处在同一个事务中，否则如果保证事物的一致性。事务的传播特性就是解决这个问题的，“事务是会传播的”在Spring中有针对传播特性的多种配置我们大多数情况下只用其中的一种:PROPGATION_REQUIRED：这个配置项的意思是说当我调用service层的方法的时候开启一个事务(具体调用那一层的方法开始创建事务，要看你的aop的配置),那么在调用这个service层里面的其他的方法的时候,如果当前方法产生了事务就用当前方法产生的事务，否则就创建一个新的事务。这个工作使由Spring来帮助我们完成的。<br>以前没有Spring帮助我们完成事务的时候我们必须自己手动的控制事务，例如当我们项目中仅仅使用hibernate，而没有集成进spring的时候，我们在一个service层中调用其他的业务逻辑方法，为了保证事物必须也要把当前的hibernate session传递到下一个方法中，或者采用ThreadLocal的方法，将session传递给下一个方法，其实都是一个目的。现在这个工作由spring来帮助我们完成，就可以让我们更加的专注于我们的业务逻辑。而不用去关心事务的问题。</p>
</blockquote>
<p>Spring定义了七种传播行为：</p>
<p>PROPAGATION_REQUIRED</p>
<p>如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。</p>
<p>PROPAGATION_SUPPORTS</p>
<p>支持当前事务，如果当前没有事务，就以非事务方式执行。</p>
<p>PROPAGATION_MANDATORY</p>
<p>使用当前的事务，如果当前没有事务，就抛出异常。</p>
<p>PROPAGATION_REQUIRES_NEW</p>
<p>新建事务，如果当前存在事务，把当前事务挂起。</p>
<p>PROPAGATION_NOT_SUPPORTED</p>
<p>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p>
<p>PROPAGATION_NEVER</p>
<p>以非事务方式执行，如果当前存在事务，则抛出异常。</p>
<p>PROPAGATION_NESTED</p>
<p>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</p>
<h4 id="传播行为详细"><a href="#传播行为详细" class="headerlink" title="传播行为详细"></a>传播行为详细</h4><p>通过实例尝试一下各个传播属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ServiceA &#123;</span><br><span class="line">       </span><br><span class="line">     void methodA() &#123;</span><br><span class="line">         ServiceB.methodB();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">ServiceB &#123;</span><br><span class="line">       </span><br><span class="line">     void methodB() &#123;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="PROPAGATION-REQUIRED"><a href="#PROPAGATION-REQUIRED" class="headerlink" title="PROPAGATION_REQUIRED"></a>PROPAGATION_REQUIRED</h5><p>如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//事务属性 PROPAGATION_REQUIRED</span><br><span class="line">methodA&#123;</span><br><span class="line">    ……</span><br><span class="line">    methodB();</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line">//事务属性 PROPAGATION_REQUIRED</span><br><span class="line">methodB&#123;</span><br><span class="line">   ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单独调用methodB方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main&#123; </span><br><span class="line">    metodB(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相当于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Main&#123; </span><br><span class="line">    Connection con=null; </span><br><span class="line">    try&#123; </span><br><span class="line">        con = getConnection(); </span><br><span class="line">        con.setAutoCommit(false); </span><br><span class="line"></span><br><span class="line">        //方法调用</span><br><span class="line">        methodB(); </span><br><span class="line"></span><br><span class="line">        //提交事务</span><br><span class="line">        con.commit(); </span><br><span class="line">    &#125; Catch(RuntimeException ex) &#123; </span><br><span class="line">        //回滚事务</span><br><span class="line">        con.rollback();   </span><br><span class="line">    &#125; finally &#123; </span><br><span class="line">        //释放资源</span><br><span class="line">        closeCon(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>Spring保证在methodB方法中所有的调用都获得到一个相同的连接。在调用methodB时，没有一个存在的事务，所以获得一个新的连接，开启了一个新的事务。 </p>
<p><strong>只是在ServiceB.methodB内的任何地方出现异常，ServiceB.methodB将会被回滚，不会引起ServiceA.methodA的回滚</strong></p>
<p>单独调用MethodA时，在MethodA内又会调用MethodB.</p>
<p>执行效果相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">main&#123; </span><br><span class="line">    Connection con = null; </span><br><span class="line">    try&#123; </span><br><span class="line">        con = getConnection(); </span><br><span class="line">        methodA(); </span><br><span class="line">        con.commit(); </span><br><span class="line">    &#125; catch(RuntimeException ex) &#123; </span><br><span class="line">        con.rollback(); </span><br><span class="line">    &#125; finally &#123;    </span><br><span class="line">        closeCon(); </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>调用MethodA时，环境中没有事务，所以开启一个新的事务.</p>
<p>当在MethodA中调用MethodB时，环境中已经有了一个事务，所以methodB就加入当前事务</p>
<p><strong>ServiceA.methodA或者ServiceB.methodB无论哪个发生异常methodA和methodB作为一个整体都将一起回滚</strong></p>
<h5 id="PROPAGATION-SUPPORTS"><a href="#PROPAGATION-SUPPORTS" class="headerlink" title="PROPAGATION_SUPPORTS"></a>PROPAGATION_SUPPORTS</h5><p>如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。但是对于事务同步的事务管理器，PROPAGATION_SUPPORTS与不使用事务有少许不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//事务属性 PROPAGATION_REQUIRED</span><br><span class="line">methodA()&#123;</span><br><span class="line">  methodB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//事务属性 PROPAGATION_SUPPORTS</span><br><span class="line">methodB()&#123;</span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单纯的调用methodB时，methodB方法是非事务的执行的。当调用methdA时,methodB则加入了methodA的事务中,事务地执行</p>
<h5 id="PROPAGATION-MANDATORY"><a href="#PROPAGATION-MANDATORY" class="headerlink" title="PROPAGATION_MANDATORY"></a>PROPAGATION_MANDATORY</h5><p>如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//事务属性 PROPAGATION_REQUIRED</span><br><span class="line">methodA()&#123;</span><br><span class="line">    methodB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//事务属性 PROPAGATION_MANDATORY</span><br><span class="line">    methodB()&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当单独调用methodB时，因为当前没有一个活动的事务，则会抛出异常throw new IllegalTransactionStateException(“Transaction propagation ‘mandatory’ but no existing transaction found”);</p>
<p>当调用methodA时，methodB则加入到methodA的事务中，事务地执行</p>
<h5 id="PROPAGATION-REQUIRES-NEW"><a href="#PROPAGATION-REQUIRES-NEW" class="headerlink" title="PROPAGATION_REQUIRES_NEW"></a>PROPAGATION_REQUIRES_NEW</h5><p>总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//事务属性 PROPAGATION_REQUIRED</span><br><span class="line">methodA()&#123;</span><br><span class="line">    doSomeThingA();</span><br><span class="line">    methodB();</span><br><span class="line">    doSomeThingB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//事务属性 PROPAGATION_REQUIRES_NEW</span><br><span class="line">methodB()&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用A方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">    methodA();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相当于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">    TransactionManager tm = null;</span><br><span class="line">    try&#123;</span><br><span class="line">        //获得一个JTA事务管理器</span><br><span class="line">        tm = getTransactionManager();</span><br><span class="line">        tm.begin();//开启一个新的事务</span><br><span class="line">        Transaction ts1 = tm.getTransaction();</span><br><span class="line">        doSomeThing();</span><br><span class="line">        tm.suspend();//挂起当前事务</span><br><span class="line">        try&#123;</span><br><span class="line">            tm.begin();//重新开启第二个事务</span><br><span class="line">            Transaction ts2 = tm.getTransaction();</span><br><span class="line">            methodB();</span><br><span class="line">            ts2.commit();//提交第二个事务</span><br><span class="line">        &#125; Catch(RunTimeException ex) &#123;</span><br><span class="line">            ts2.rollback();//回滚第二个事务</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //释放资源</span><br><span class="line">        &#125;</span><br><span class="line">        //methodB执行完后，恢复第一个事务</span><br><span class="line">        tm.resume(ts1);</span><br><span class="line">        doSomeThingB();</span><br><span class="line">        ts1.commit();//提交第一个事务</span><br><span class="line">    &#125; catch(RunTimeException ex) &#123;</span><br><span class="line">        ts1.rollback();//回滚第一个事务</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //释放资源</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我把ts1称为外层事务，ts2称为内层事务。从上面的代码可以看出，ts2与ts1是两个独立的事务，互不相干。</p>
<p>Ts2是否成功并不依赖于ts1</p>
<p>如果methodA方法在调用methodB方法后的doSomeThingB方法失败了，而methodB方法所做的结果依然被提交。</p>
<p>而除了 methodB之外的其它代码导致的结果却被回滚了</p>
<h5 id="PROPAGATION-NOT-SUPPORTED"><a href="#PROPAGATION-NOT-SUPPORTED" class="headerlink" title="PROPAGATION_NOT_SUPPORTED"></a>PROPAGATION_NOT_SUPPORTED</h5><p>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//事务属性 PROPAGATION_REQUIRED</span><br><span class="line">methodA()&#123;</span><br><span class="line">    doSomeThingA();</span><br><span class="line">    methodB();</span><br><span class="line">    doSomeThingB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//事务属性 PROPAGATION_NOT_SUPPORTED</span><br><span class="line">methodB()&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当前不支持事务。比如ServiceA.methodA的事务级别是PROPAGATION_REQUIRED ，<br>而ServiceB.methodB的事务级别是PROPAGATION_NOT_SUPPORTED ，<br>那么当执行到ServiceB.methodB时，ServiceA.methodA的事务挂起，而他以非事务的状态运行完，再继续ServiceA.methodA的事务</p>
<h5 id="PROPAGATION-NEVER"><a href="#PROPAGATION-NEVER" class="headerlink" title="PROPAGATION_NEVER"></a>PROPAGATION_NEVER</h5><p>不能在事务中运行。假设ServiceA.methodA的事务级别是PROPAGATION_REQUIRED，<br>而ServiceB.methodB的事务级别是PROPAGATION_NEVER ，<br>那么ServiceB.methodB就要抛出异常了。</p>
<h5 id="PROPAGATION-NESTED"><a href="#PROPAGATION-NESTED" class="headerlink" title="PROPAGATION_NESTED"></a>PROPAGATION_NESTED</h5><p>开始一个 “嵌套的” 事务,  它是已经存在事务的一个真正的子事务. 潜套事务开始执行时,  它将取得一个 savepoint. 如果这个嵌套事务失败, 我们将回滚到此 savepoint. 潜套事务是外部事务的一部分, 只有外部事务结束后它才会被提交. </p>
<p>比如我们设计ServiceA.methodA的事务级别为PROPAGATION_REQUIRED，ServiceB.methodB的事务级别为PROPAGATION_NESTED，那么当执行到ServiceB.methodB的时候，ServiceA.methodA所在的事务就会挂起，ServiceB.methodB会起一个新的子事务并设置savepoint，等待ServiceB.methodB的事务完成以后，他才继续执行</p>
<p>因为ServiceB.methodB是外部事务的子事务，那么</p>
<ol>
<li>如果ServiceB.methodB已经提交，那么ServiceA.methodA失败回滚，ServiceB.methodB也将回滚。</li>
<li>如果ServiceB.methodB失败回滚，如果他抛出的异常被ServiceA.methodA的try..catch捕获并处理，ServiceA.methodA事务仍然可能提交；如果他抛出的异常未被ServiceA.methodA捕获处理，ServiceA.methodA事务将回滚。</li>
</ol>
<p>理解Nested的关键是savepoint。</p>
<p><strong>与PROPAGATION_REQUIRES_NEW的区别</strong>：</p>
<ol>
<li>RequiresNew每次都创建新的独立的物理事务，而Nested只有一个物理事务；</li>
<li>Nested嵌套事务回滚或提交不会导致外部事务回滚或提交，但外部事务回滚将导致嵌套事务回滚，而 RequiresNew由于都是全新的事务，所以之间是无关联的；</li>
<li>Nested使用JDBC 3的保存点实现，即如果使用低版本驱动将导致不支持嵌套事务。<br>使用嵌套事务，必须确保具体事务管理器实现的nestedTransactionAllowed属性为true，否则不支持嵌套事务，如DataSourceTransactionManager默认支持，而HibernateTransactionManager默认不支持，需要我们来开启。</li>
</ol>
<p>在 spring 中使用 PROPAGATION_NESTED的前提：</p>
<ol>
<li>我们要设置 transactionManager 的 nestedTransactionAllowed 属性为 true, 注意, 此属性默认为 false!!! </li>
<li>java.sql.Savepoint 必须存在, 即 jdk 版本要 1.4+ </li>
<li>Connection.getMetaData().supportsSavepoints() 必须为 true, 即 jdbc drive 必须支持 JDBC 3.0</li>
</ol>
<p><img src="http://qnimages.zhuxingsheng.com/transaction/propagation.png" alt="image"></p>
<h3 id="隔离规则"><a href="#隔离规则" class="headerlink" title="隔离规则"></a>隔离规则</h3><p>用来解决并发事务时出现的问题，其使用TransactionDefinition中的静态变量来指定</p>
<ol>
<li>ISOLATION_DEFAULT	使用后端数据库默认的隔离级别</li>
<li>ISOLATION_READ_UNCOMMITTED	最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</li>
<li>ISOLATION_READ_COMMITTED	允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</li>
<li>ISOLATION_REPEATABLE_READ	对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生</li>
<li>ISOLATION_SERIALIZABLE	最高的隔离级别，完全服从ACID的隔离级别，确保阻止脏读、不可重复读以及幻读，也是最慢的事务隔离级别，因为它通常是通过完全锁定事务相关的数据库表来实现的</li>
</ol>
<p>可以使用DefaultTransactionDefinition类的setIsolationLevel(TransactionDefinition. ISOLATION_READ_COMMITTED)来指定隔离级别，其中此处表示隔离级别为提交读</p>
<p>也可以使用或setIsolationLevelName(“ISOLATION_READ_COMMITTED”)方式指定，其中参数就是隔离级别静态变量的名字，但不推荐这种方式</p>
<h3 id="事务只读"><a href="#事务只读" class="headerlink" title="事务只读"></a>事务只读</h3><p>将事务标识为只读，只读事务不修改任何数据；</p>
<p>对于JDBC只是简单的将连接设置为只读模式，对于更新将抛出异常；</p>
<p>对于一些其他ORM框架有一些优化作用，如在Hibernate中，Spring事务管理器将执行“session.setFlushMode(FlushMode.MANUAL)”<br>即指定Hibernate会话在只读事务模式下不用尝试检测和同步持久对象的状态的更新。</p>
<p>如果使用设置具体事务管理的validateExistingTransaction属性为true（默认false），将确保整个事务传播链都是只读或都不是只读<br><img src="http://qnimages.zhuxingsheng.com/transaction/readonly.JPG" alt="image"></p>
<p>第二个addressService.save()不能设置成false</p>
<p>对于错误的事务只读设置将抛出IllegalTransactionStateException异常，并伴随“Participating transaction with definition [……] is not marked as read-only……”信息，表示参与的事务只读属性设置错误</p>
<h3 id="事务超时"><a href="#事务超时" class="headerlink" title="事务超时"></a>事务超时</h3><p>设置事务的超时时间，单位为秒，默认为-1表示使用底层事务的超时时间</p>
<p>使用如setTimeout(100)来设置超时时间，如果事务超时将抛出org.springframework.transaction.TransactionTimedOutException异常并将当前事务标记为应该回滚，即超时后事务被自动回滚</p>
<p>可以使用具体事务管理器实现的defaultTimeout属性设置默认的事务超时时间，如DataSourceTransactionManager. setDefaultTimeout(10)</p>
<h3 id="回滚规则"><a href="#回滚规则" class="headerlink" title="回滚规则"></a>回滚规则</h3><p>spring事务管理器会捕捉任何未处理的异常，然后依据规则决定是否回滚抛出异常的事务</p>
<p>默认配置下，Spring只有在抛出的异常为运行时unchecked异常时才回滚该事务，也就是抛出的异常为RuntimeException的子类(Errors也会导致事务回滚)，而抛出checked异常则不会导致事务回滚。可以明确的配置在抛出那些异常时回滚事务，包括checked异常。也可以明确定义那些异常抛出时不回滚事务</p>
<p><strong>如何改变默认规则</strong>：</p>
<ol>
<li>让checked例外也回滚：在整个方法前加上 @Transactional(rollbackFor&#x3D;Exception.class)</li>
<li>让unchecked例外不回滚： @Transactional(notRollbackFor&#x3D;RunTimeException.class)</li>
<li>不需要事务管理的(只查询的)方法：@Transactional(propagation&#x3D;Propagation.NOT_SUPPORTED)</li>
</ol>
<h2 id="事务状态"><a href="#事务状态" class="headerlink" title="事务状态"></a>事务状态</h2><p>上面讲到的调用PlatformTransactionManager接口的getTransaction()的方法得到的是TransactionStatus接口的一个实现，这个接口的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface TransactionStatus&#123;</span><br><span class="line">    boolean isNewTransaction(); // 是否是新的事物</span><br><span class="line">    boolean hasSavepoint(); // 是否有恢复点</span><br><span class="line">    void setRollbackOnly();  // 设置为只回滚</span><br><span class="line">    boolean isRollbackOnly(); // 是否为只回滚</span><br><span class="line">    boolean isCompleted; // 是否已完成</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>可以发现这个接口描述的是一些处理事务提供简单的控制事务执行和查询事务状态的方法，在回滚或提交的时候需要应用对应的事务状态</p>
<h2 id="编程式和声明式事务"><a href="#编程式和声明式事务" class="headerlink" title="编程式和声明式事务"></a>编程式和声明式事务</h2><p>Spring提供了对编程式事务和声明式事务的支持，编程式事务允许用户在代码中精确定义事务的边界</p>
<p>而声明式事务（基于AOP）有助于用户将操作与事务规则进行解耦。 </p>
<p>简单地说，编程式事务侵入到了业务代码里面，但是提供了更加详细的事务管理；而声明式事务由于基于AOP，所以既能起到事务管理的作用，又可以不影响业务代码的具体实现。</p>
<h3 id="编程式"><a href="#编程式" class="headerlink" title="编程式"></a>编程式</h3><p>Spring提供两种方式的编程式事务管理，分别是：使用TransactionTemplate和直接使用PlatformTransactionManager</p>
<h4 id="使用TransactionTemplate"><a href="#使用TransactionTemplate" class="headerlink" title="使用TransactionTemplate"></a>使用TransactionTemplate</h4><p>采用TransactionTemplate和采用其他Spring模板，如JdbcTempalte和HibernateTemplate是一样的方法。它使用回调方法，把应用程序从处理取得和释放资源中解脱出来。如同其他模板，TransactionTemplate是线程安全的。代码片段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TransactionTemplate tt = new TransactionTemplate(); // 新建一个TransactionTemplate</span><br><span class="line">Object result = tt.execute(</span><br><span class="line">    new TransactionCallback()&#123;  </span><br><span class="line">        public Object doTransaction(TransactionStatus status)&#123;  </span><br><span class="line">            updateOperation();  </span><br><span class="line">            return resultOfUpdateOperation();  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;); // 执行execute方法进行事务管理</span><br></pre></td></tr></table></figure>

<p>使用TransactionCallback()可以返回一个值。如果使用TransactionCallbackWithoutResult则没有返回值</p>
<h4 id="使用PlatformTransactionManager"><a href="#使用PlatformTransactionManager" class="headerlink" title="使用PlatformTransactionManager"></a>使用PlatformTransactionManager</h4><p>示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager();</span><br><span class="line">//定义一个某个框架平台的TransactionManager，如JDBC、Hibernate</span><br><span class="line">dataSourceTransactionManager.setDataSource(this.getJdbcTemplate().getDataSource()); // 设置数据源</span><br><span class="line">    DefaultTransactionDefinition transDef = new DefaultTransactionDefinition(); // 定义事务属性</span><br><span class="line">    transDef.setPropagationBehavior(DefaultTransactionDefinition.PROPAGATION_REQUIRED); // 设置传播行为属性</span><br><span class="line">    TransactionStatus status = dataSourceTransactionManager.getTransaction(transDef); // 获得事务状态</span><br><span class="line">    try &#123;</span><br><span class="line">        // 数据库操作</span><br><span class="line">        dataSourceTransactionManager.commit(status);// 提交</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        dataSourceTransactionManager.rollback(status);// 回滚</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="声明式"><a href="#声明式" class="headerlink" title="声明式"></a>声明式</h3><p>有几种实现方式，不一一罗列了</p>
<h4 id="使用tx拦截器"><a href="#使用tx拦截器" class="headerlink" title="使用tx拦截器"></a>使用tx拦截器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><!-- 定义事务管理器（声明式的事务） --> </span><br><span class="line">    &lt;bean id=&quot;transactionManager&quot;</span><br><span class="line">        class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot; /&gt;</span><br><span class="line">        &lt;/tx:attributes&gt;</span><br><span class="line">    &lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;aop:pointcut id=&quot;interceptorPointCuts&quot;</span><br><span class="line">            expression=&quot;execution(* com.bluesky.spring.dao.*.*(..))&quot; /&gt;</span><br><span class="line">        &lt;aop:advisor advice-ref=&quot;txAdvice&quot;</span><br><span class="line">            pointcut-ref=&quot;interceptorPointCuts&quot; /&gt;       </span><br><span class="line">    &lt;/aop:config&gt; </span><br></pre></td></tr></table></figure>
<h4 id="全注解"><a href="#全注解" class="headerlink" title="全注解"></a>全注解</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt;</span><br><span class="line">    &lt;bean id=&quot;transactionManager&quot;</span><br><span class="line">          class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager &quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot;&gt;</span><br><span class="line">            &lt;ref bean=&quot;basicDataSource&quot; /&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Spring源码片段"><a href="#Spring源码片段" class="headerlink" title="Spring源码片段"></a>Spring源码片段</h2><p>在《BeanPostProcessor学习》中提到了AOP的实现方式，声明式事务实现是基于AOP</p>
<p>首先得解析xml配置，TxNamespaceHandler</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">	public void init() &#123;</span><br><span class="line">		registerBeanDefinitionParser(&quot;advice&quot;, new TxAdviceBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(&quot;annotation-driven&quot;, new AnnotationDrivenBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(&quot;jta-transaction-manager&quot;, new JtaTransactionManagerBeanDefinitionParser());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>主要是TransactionInterceptor类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(final MethodInvocation invocation) throws Throwable &#123;</span><br><span class="line">		// Work out the target class: may be &#123;@code null&#125;.</span><br><span class="line">		// The TransactionAttributeSource should be passed the target class</span><br><span class="line">		// as well as the method, which may be from an interface.</span><br><span class="line">		Class&lt;?&gt; targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);</span><br><span class="line"></span><br><span class="line">		// Adapt to TransactionAspectSupport&#x27;s invokeWithinTransaction...</span><br><span class="line">		//主要逻辑在父类</span><br><span class="line">		return invokeWithinTransaction(invocation.getMethod(), targetClass, new InvocationCallback() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public Object proceedWithInvocation() throws Throwable &#123;</span><br><span class="line">				return invocation.proceed();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>核心逻辑，还得看父类TransactionAspectSupport#invokeWithinTransaction</p>
<p>逻辑主干很清晰</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">			// Standard transaction demarcation with getTransaction and commit/rollback calls.</span><br><span class="line">			// 判断创建Transaction</span><br><span class="line">			TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line">			Object retVal = null;</span><br><span class="line">			try &#123;</span><br><span class="line">				// This is an around advice: Invoke the next interceptor in the chain.</span><br><span class="line">				// This will normally result in a target object being invoked.</span><br><span class="line">				//执行业务逻辑</span><br><span class="line">				retVal = invocation.proceedWithInvocation();</span><br><span class="line">			&#125;</span><br><span class="line">			catch (Throwable ex) &#123;</span><br><span class="line">				// target invocation exception</span><br><span class="line">				// 出现异常，回滚</span><br><span class="line">				completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">				throw ex;</span><br><span class="line">			&#125;</span><br><span class="line">			finally &#123;</span><br><span class="line">				//清除当前事务状态</span><br><span class="line">				cleanupTransactionInfo(txInfo);</span><br><span class="line">			&#125;</span><br><span class="line">			//提交事务</span><br><span class="line">			commitTransactionAfterReturning(txInfo);</span><br><span class="line">			return retVal;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建事务createTransactionIfNecessary"><a href="#创建事务createTransactionIfNecessary" class="headerlink" title="创建事务createTransactionIfNecessary"></a>创建事务createTransactionIfNecessary</h3><p>主要逻辑在PlatformTransactionManager#getTransaction()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException &#123;</span><br><span class="line">		//得到各个不同数据源的事务对象，spring尽然没有把transaction对象抽象出来，很是奇怪</span><br><span class="line">		Object transaction = doGetTransaction();</span><br><span class="line"></span><br><span class="line">		// Cache debug flag to avoid repeated checks.</span><br><span class="line">		boolean debugEnabled = logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line">		if (definition == null) &#123;</span><br><span class="line">			// Use defaults if no transaction definition given.</span><br><span class="line">			definition = new DefaultTransactionDefinition();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//此事务是否已经存在</span><br><span class="line">		if (isExistingTransaction(transaction)) &#123;</span><br><span class="line">			// Existing transaction found -&gt; check propagation behavior to find out how to behave.</span><br><span class="line">			return handleExistingTransaction(definition, transaction, debugEnabled);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Check definition settings for new transaction.</span><br><span class="line">		if (definition.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">			throw new InvalidTimeoutException(&quot;Invalid transaction timeout&quot;, definition.getTimeout());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// No existing transaction found -&gt; check propagation behavior to find out how to proceed.</span><br><span class="line">		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line">			throw new IllegalTransactionStateException(</span><br><span class="line">					&quot;No existing transaction found for transaction marked with propagation &#x27;mandatory&#x27;&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		//这三种都是新建事务</span><br><span class="line">		else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</span><br><span class="line">				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">			SuspendedResourcesHolder suspendedResources = suspend(null);</span><br><span class="line">			if (debugEnabled) &#123;</span><br><span class="line">				logger.debug(&quot;Creating new transaction with name [&quot; + definition.getName() + &quot;]: &quot; + definition);</span><br><span class="line">			&#125;</span><br><span class="line">			try &#123;</span><br><span class="line">				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">				DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">				//开始获取链接，开启事务，绑定资源到当前线程</span><br><span class="line">				doBegin(transaction, definition);</span><br><span class="line">				prepareSynchronization(status, definition);</span><br><span class="line">				return status;</span><br><span class="line">			&#125;</span><br><span class="line">			catch (RuntimeException | Error ex) &#123;</span><br><span class="line">				resume(null, suspendedResources);</span><br><span class="line">				throw ex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			// Create &quot;empty&quot; transaction: no actual transaction, but potentially synchronization.</span><br><span class="line">			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">				logger.warn(&quot;Custom isolation level specified but no actual transaction initiated; &quot; +</span><br><span class="line">						&quot;isolation level will effectively be ignored: &quot; + definition);</span><br><span class="line">			&#125;</span><br><span class="line">			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">			return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TransactionStatus"><a href="#TransactionStatus" class="headerlink" title="TransactionStatus"></a>TransactionStatus</h4><p>这儿返回的是<strong>TransactionStatus</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public interface TransactionStatus extends SavepointManager, Flushable &#123;</span><br><span class="line"></span><br><span class="line">	boolean isNewTransaction();</span><br><span class="line"></span><br><span class="line">	boolean hasSavepoint();</span><br><span class="line"></span><br><span class="line">	void setRollbackOnly();</span><br><span class="line"></span><br><span class="line">	boolean isRollbackOnly();</span><br><span class="line"></span><br><span class="line">	void flush();</span><br><span class="line"></span><br><span class="line">	boolean isCompleted();</span><br></pre></td></tr></table></figure>

<h4 id="TransactionInfo"><a href="#TransactionInfo" class="headerlink" title="TransactionInfo"></a>TransactionInfo</h4><p>事务信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protected final class TransactionInfo &#123;</span><br><span class="line"></span><br><span class="line">		private final PlatformTransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line">		private final TransactionAttribute transactionAttribute;</span><br><span class="line"></span><br><span class="line">		private final String joinpointIdentification;</span><br><span class="line"></span><br><span class="line">		private TransactionStatus transactionStatus;</span><br><span class="line"></span><br><span class="line">		private TransactionInfo oldTransactionInfo;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br></pre></td></tr></table></figure>
<h3 id="commitTransactionAfterReturning提交事务"><a href="#commitTransactionAfterReturning提交事务" class="headerlink" title="commitTransactionAfterReturning提交事务"></a>commitTransactionAfterReturning提交事务</h3><p>逻辑到了AbstractPlatformTransactionManager#processRollback</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">private void processRollback(DefaultTransactionStatus status, boolean unexpected) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			boolean unexpectedRollback = unexpected;</span><br><span class="line"></span><br><span class="line">			try &#123;</span><br><span class="line">				triggerBeforeCompletion(status);</span><br><span class="line">				//有savepoint，</span><br><span class="line">				if (status.hasSavepoint()) &#123;</span><br><span class="line">					if (status.isDebug()) &#123;</span><br><span class="line">						logger.debug(&quot;Rolling back transaction to savepoint&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">					status.rollbackToHeldSavepoint();</span><br><span class="line">				&#125;</span><br><span class="line">				else if (status.isNewTransaction()) &#123;</span><br><span class="line">					if (status.isDebug()) &#123;</span><br><span class="line">						logger.debug(&quot;Initiating transaction rollback&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">					//回滚事务</span><br><span class="line">					doRollback(status);</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					// Participating in larger transaction</span><br><span class="line">					//在一个事务中，就先设置回滚标识,等父事务一起回滚</span><br><span class="line">					if (status.hasTransaction()) &#123;</span><br><span class="line">						if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) &#123;</span><br><span class="line">							if (status.isDebug()) &#123;</span><br><span class="line">								logger.debug(&quot;Participating transaction failed - marking existing transaction as rollback-only&quot;);</span><br><span class="line">							&#125;</span><br><span class="line">							doSetRollbackOnly(status);</span><br><span class="line">						&#125;</span><br><span class="line">						else &#123;</span><br><span class="line">							if (status.isDebug()) &#123;</span><br><span class="line">								logger.debug(&quot;Participating transaction failed - letting transaction originator decide on rollback&quot;);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					else &#123;</span><br><span class="line">						logger.debug(&quot;Should roll back transaction but cannot - no transaction available&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">					// Unexpected rollback only matters here if we&#x27;re asked to fail early</span><br><span class="line">					if (!isFailEarlyOnGlobalRollbackOnly()) &#123;</span><br><span class="line">						unexpectedRollback = false;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			catch (RuntimeException | Error ex) &#123;</span><br><span class="line">				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</span><br><span class="line">				throw ex;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);</span><br><span class="line"></span><br><span class="line">			// Raise UnexpectedRollbackException if we had a global rollback-only marker</span><br><span class="line">			if (unexpectedRollback) &#123;</span><br><span class="line">				throw new UnexpectedRollbackException(</span><br><span class="line">						&quot;Transaction rolled back because it has been marked as rollback-only&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		finally &#123;</span><br><span class="line">			cleanupAfterCompletion(status);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h3 id="completeTransactionAfterThrowing回滚事务"><a href="#completeTransactionAfterThrowing回滚事务" class="headerlink" title="completeTransactionAfterThrowing回滚事务"></a>completeTransactionAfterThrowing回滚事务</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">protected void completeTransactionAfterThrowing(TransactionInfo txInfo, Throwable ex) &#123;</span><br><span class="line">		//有事务才能回滚</span><br><span class="line">		if (txInfo != null &amp;&amp; txInfo.hasTransaction()) &#123;</span><br><span class="line">			if (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(&quot;Completing transaction for [&quot; + txInfo.getJoinpointIdentification() +</span><br><span class="line">						&quot;] after exception: &quot; + ex);</span><br><span class="line">			&#125;</span><br><span class="line">			//回滚在 (ex instanceof RuntimeException || ex instanceof Error)</span><br><span class="line">			if (txInfo.transactionAttribute.rollbackOn(ex)) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());</span><br><span class="line">				&#125;</span><br><span class="line">				catch (TransactionSystemException ex2) &#123;</span><br><span class="line">					logger.error(&quot;Application exception overridden by rollback exception&quot;, ex);</span><br><span class="line">					ex2.initApplicationException(ex);</span><br><span class="line">					throw ex2;</span><br><span class="line">				&#125;</span><br><span class="line">				catch (RuntimeException ex2) &#123;</span><br><span class="line">					logger.error(&quot;Application exception overridden by rollback exception&quot;, ex);</span><br><span class="line">					throw ex2;</span><br><span class="line">				&#125;</span><br><span class="line">				catch (Error err) &#123;</span><br><span class="line">					logger.error(&quot;Application exception overridden by rollback error&quot;, ex);</span><br><span class="line">					throw err;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				// We don&#x27;t roll back on this exception.</span><br><span class="line">				// Will still roll back if TransactionStatus.isRollbackOnly() is true.</span><br><span class="line">				try &#123;</span><br><span class="line">					txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">				&#125;</span><br><span class="line">				catch (TransactionSystemException ex2) &#123;</span><br><span class="line">					logger.error(&quot;Application exception overridden by commit exception&quot;, ex);</span><br><span class="line">					ex2.initApplicationException(ex);</span><br><span class="line">					throw ex2;</span><br><span class="line">				&#125;</span><br><span class="line">				catch (RuntimeException ex2) &#123;</span><br><span class="line">					logger.error(&quot;Application exception overridden by commit exception&quot;, ex);</span><br><span class="line">					throw ex2;</span><br><span class="line">				&#125;</span><br><span class="line">				catch (Error err) &#123;</span><br><span class="line">					logger.error(&quot;Application exception overridden by commit error&quot;, ex);</span><br><span class="line">					throw err;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一个完整的事务介绍结束了。框架就是封装一切，透明一切，简化一切。本质的流程不会变</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://blog.sina.com.cn/s/blog_7ed8b1e90101mgas.html">http://blog.sina.com.cn/s/blog_7ed8b1e90101mgas.html</a></p>
<p><a href="https://my.oschina.net/wanyuxiang000/blog/277568">https://my.oschina.net/wanyuxiang000/blog/277568</a></p>
<p><a href="http://www.mamicode.com/info-detail-1248286.html">http://www.mamicode.com/info-detail-1248286.html</a></p>
<p><a href="http://jinnianshilongnian.iteye.com/blog/1496953">http://jinnianshilongnian.iteye.com/blog/1496953</a></p>
<p><a href="http://www.cnblogs.com/yldIndex/p/spring_Transactional.html">http://www.cnblogs.com/yldIndex/p/spring_Transactional.html</a></p>
<p><a href="http://jinnianshilongnian.iteye.com/blog/1441271">http://jinnianshilongnian.iteye.com/blog/1441271</a></p>
<p><a href="http://www.cnblogs.com/chihirotan/p/6739748.html">http://www.cnblogs.com/chihirotan/p/6739748.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://www.zhuxingsheng.com/blog/counter-algorithm.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="朱兴生">
      <meta itemprop="description" content="彪悍的人生需要书写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码农戏码">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/counter-algorithm.html" class="post-title-link" itemprop="url">计数器算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-05-29 17:12:00" itemprop="dateCreated datePublished" datetime="2017-05-29T17:12:00+08:00">2017-05-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-07 21:29:17" itemprop="dateModified" datetime="2021-11-07T21:29:17+08:00">2021-11-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="http://www.zhuxingsheng.com/blog/micro-service-fuse-mechanism.html">《微服务-熔断机制》</a>中提到了计数器，这篇详细学习一下计数器算法</p>
<p>之前的有次面试，碰到了计数器的的题目</p>
<p>Q：线上服务，设计一个拦截器，一个IP如果短时间内请求次数过多，就屏蔽</p>
<p>A：使用map，key为ip，值为次数与时间</p>
<p>Q：请求相当大，会直接冲垮内存,怎么办？</p>
<p>A：使用redis，像redis cluster，绝对可以满足</p>
<p>Q: 写下伪代码</p>
<p>A：bbbbbbb</p>
<p>其实计数器在互联网开发中很常见，当时刚转互联网比较无知，面试得很烂。</p>
<h3 id="计数器法"><a href="#计数器法" class="headerlink" title="计数器法"></a>计数器法</h3><p>计数器法是限流算法里最简单也是最容易实现的一种算法。比如我们规定，对于A接口来说，我们1分钟的访问次数不能超过100个。那么我们可以这么做：在一开 始的时候，我们可以设置一个计数器counter，每当一个请求过来的时候，counter就加1，如果counter的值大于100并且该请求与第一个 请求的间隔时间还在1分钟之内，那么说明请求数过多；如果该请求与第一个请求的间隔时间大于1分钟，且counter的值还在限流范围内，那么就重置 counter，具体算法的示意图如下：</p>
<p><img src="http://images.zhuxingsheng.com/201805301332_414.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Counter &#123;</span><br><span class="line">    public long timeStamp = getNowTime();</span><br><span class="line">    public int reqCount = 0;</span><br><span class="line">    public final int limit = 100; // 时间窗口内最大请求数</span><br><span class="line">    public final long interval = 1000; // 时间窗口ms</span><br><span class="line">    public boolean grant() &#123;</span><br><span class="line">        long now = getNowTime();</span><br><span class="line">        if (now &lt; timeStamp + interval) &#123;</span><br><span class="line">            // 在时间窗口内</span><br><span class="line">            reqCount++;</span><br><span class="line">            // 判断当前时间窗口内是否超过最大请求控制数</span><br><span class="line">            return reqCount &lt;= limit;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            timeStamp = now;</span><br><span class="line">            // 超时后重置</span><br><span class="line">            reqCount = 1;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是示意代码，先忽视其中的并发问题，最大的问题是临界问题</p>
<p><img src="http://images.zhuxingsheng.com/201805301631_462.png"></p>
<p>从上图中我们可以看到，假设有一个恶意用户，他在0:59时，瞬间发送了100个请求，并且1:00又瞬间发送了100个请求，那么其实这个用户在 1秒里面，瞬间发送了200个请求。我们刚才规定的是1分钟最多100个请求，也就是每秒钟最多1.7个请求，用户通过在时间窗口的重置节点处突发请求， 可以瞬间超过我们的速率限制。用户有可能通过算法的这个漏洞，瞬间压垮我们的应用。</p>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>滑动窗口，又称rolling window</p>
<p><img src="http://images.zhuxingsheng.com/201805301626_844.png"></p>
<p>在上图中，整个红色的矩形框表示一个时间窗口，在我们的例子中，一个时间窗口就是一分钟。然后我们将时间窗口进行划分，比如图中，我们就将滑动窗口 划成了6格，所以每格代表的是10秒钟。每过10秒钟，我们的时间窗口就会往右滑动一格。每一个格子都有自己独立的计数器counter，比如当一个请求 在0:35秒的时候到达，那么0:30~0:39对应的counter就会加1。</p>
<p>那么滑动窗口怎么解决刚才的临界问题的呢？我们可以看上图，0:59到达的100个请求会落在灰色的格子中，而1:00到达的请求会落在橘黄色的格 子中。当时间到达1:00时，我们的窗口会往右移动一格，那么此时时间窗口内的总请求数量一共是200个，超过了限定的100个，所以此时能够检测出来触 发了限流。</p>
<p>我再来回顾一下刚才的计数器算法，我们可以发现，计数器算法其实就是滑动窗口算法。只是它没有对时间窗口做进一步地划分，所以只有1格。</p>
<p>由此可见，当滑动窗口的格子划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确。</p>
<h4 id="实现一"><a href="#实现一" class="headerlink" title="实现一"></a>实现一</h4><p>根据上面滑动窗口的定义，实现很简单了</p>
<ol>
<li>需要一个map,当然是并发安全的，key为时间</li>
<li>统计窗口内的请求总数</li>
</ol>
<p>这儿有个以这种方式实现的<br><a href="https://github.com/zhuxingsheng/yammer-metrics/blob/master/metrics-core/src/main/java/com/codahale/metrics/SlidingTimeWindowReservoir.java">https://github.com/zhuxingsheng/yammer-metrics/blob/master/metrics-core/src/main/java/com/codahale/metrics/SlidingTimeWindowReservoir.java</a></p>
<p>摘点核心的片段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//一个并发安全map,skip list有序</span><br><span class="line">this.measurements = new ConcurrentSkipListMap&lt;Long, Long&gt;();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取map的key,以时间纳秒值为key</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private long getTick() &#123;</span><br><span class="line">    for (; ; ) &#123;</span><br><span class="line">        final long oldTick = lastTick.get();</span><br><span class="line">        //每纳秒处理的请求很多，减少compareAndSet的失败次数，这儿*COLLISION_BUFFER</span><br><span class="line">        final long tick = clock.getTick() * COLLISION_BUFFER;</span><br><span class="line">        // ensure the tick is strictly incrementing even if there are duplicate ticks</span><br><span class="line">        final long newTick = tick &gt; oldTick ? tick : oldTick + 1;</span><br><span class="line">        if (lastTick.compareAndSet(oldTick, newTick)) &#123;</span><br><span class="line">            return newTick;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private void trim() &#123;</span><br><span class="line">        //清除window之前的计数</span><br><span class="line">        measurements.headMap(getTick() - window).clear();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>实现简单，但有个问题，map的key是在不停的增加，删除，给GC带来了压力</p>
<h4 id="实现二"><a href="#实现二" class="headerlink" title="实现二"></a>实现二</h4><p>考虑key的复用，使用环形结构</p>
<p><img src="http://images.zhuxingsheng.com/201806051739_63.png" alt="环形结构"></p>
<p>通过取模来达到这个效果</p>
<p>初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private int window; //计算窗口</span><br><span class="line">//整个循环数组窗口</span><br><span class="line">private int ringWindow=window+30; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">requestCounter = new AtomicInteger[ringWindow];</span><br><span class="line">failedCounter = new AtomicInteger[ringWindow];</span><br><span class="line">for (int i = 0; i &lt; ringWindow; i++) &#123;</span><br><span class="line">	requestCounter[i] = new AtomicInteger(0);</span><br><span class="line">	failedCounter[i] = new AtomicInteger(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initCounterTimeInSecond =</span><br><span class="line">TimeUnit.NANOSECONDS.toSeconds(System.nanoTime());</span><br></pre></td></tr></table></figure>

<p>计算窗口内的次数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private long countTotal(AtomicInteger[] caculateCounter)&#123;</span><br><span class="line">		int currentIndex = getIndex();</span><br><span class="line">		</span><br><span class="line">		long sum = 0;</span><br><span class="line">		</span><br><span class="line">		for (int i = 0; i &lt; window; i++) &#123;</span><br><span class="line">			//这儿并不是直接计算window中的所有counter，</span><br><span class="line">			//而是从currentIndex向前倒取window个</span><br><span class="line">			int index = ((currentIndex + ringWindow) -i) </span><br><span class="line">			% this.ringWindow;</span><br><span class="line">			sum += caculateCounter[index].get();</span><br><span class="line">		&#125;</span><br><span class="line">		return sum;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>为什么需要ringWindow，直接window就可以？这儿有个奇技淫巧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CLEAN_UP_BUFFER=10;</span><br><span class="line"></span><br><span class="line">public void cleanupFutureCounter() &#123;</span><br><span class="line">		int currentIndex = getIndex();</span><br><span class="line">		</span><br><span class="line">		for (int i = 1 ; i &lt;= CLEAN_UP_BUFFER; i++) &#123;</span><br><span class="line">			int index = (currentIndex + i) % this.ringWindow;</span><br><span class="line">			requestCounter[index].set(0);</span><br><span class="line">			failedCounter[index].set(0);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这儿会有个定时任务，每5秒会去清空未来10秒的数据</p>
<p>因为在一环数组全部填充完成后，下一轮开始时，需要清空，哪个地方是起点，无法区分，所以ringwindow预留点位置用来清空</p>
<h4 id="实现三"><a href="#实现三" class="headerlink" title="实现三"></a>实现三</h4><p>还有一些是加锁，当然会是轻量的CAS；每一个轮回完成后，都需要标记开始位置，并清空环。</p>
<h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p>漏桶(Leaky Bucket)算法思路很简单,水(请求)先进入到漏桶里,漏桶以一定的速度出水(接口有响应速率),当水流入速度过大会直接溢出(访问频率超过接口响应速率),然后就拒绝请求,可以看出漏桶算法能强行限制数据的传输速率.示意图如下:</p>
<p><img src="http://images.zhuxingsheng.com/201806071032_732.png"></p>
<p>我们将算法中的水换成实际应用中的请求，我们可以看到漏桶算法天生就限制了请求的速度。当使用了漏桶算法，我们可以保证接口会以一个常速速率来处理请求。所以漏桶算法天生不会出现临界问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class LeakyDemo &#123;</span><br><span class="line">public long timeStamp = getNowTime();</span><br><span class="line">public int capacity; // 桶的容量</span><br><span class="line">public int rate; // 水漏出的速度</span><br><span class="line">public int water; // 当前水量(当前累积请求数)</span><br><span class="line">public boolean grant() &#123;</span><br><span class="line">    long now = getNowTime();</span><br><span class="line">    water = max(0, water - (now - timeStamp) * rate); // 先执行漏水，计算剩余水量</span><br><span class="line">    timeStamp = now;</span><br><span class="line">    if ((water + 1) &lt; capacity) &#123;</span><br><span class="line">    // 尝试加水,并且水还未满</span><br><span class="line">    water += 1;</span><br><span class="line">    return true;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">    // 水满，拒绝加水</span><br><span class="line">    return false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="令牌桶算法（Token-Bucket）"><a href="#令牌桶算法（Token-Bucket）" class="headerlink" title="令牌桶算法（Token Bucket）"></a>令牌桶算法（Token Bucket）</h3><p>令牌桶算法(Token Bucket)和 Leaky Bucket 效果一样但方向相反的算法,更加容易理解.随着时间流逝,系统会按恒定1&#x2F;QPS时间间隔(如果QPS&#x3D;100,则间隔是10ms)往桶里加入Token(想象和漏洞漏水相反,有个水龙头在不断的加水),如果桶已经满了就不再加了.新请求来临时,会各自拿走一个Token,如果没有Token可拿了就阻塞或者拒绝服务</p>
<p><img src="http://images.zhuxingsheng.com/201806071130_466.png" alt="令牌桶算法"></p>
<p>令牌桶的另外一个好处是可以方便的改变速度. 一旦需要提高速率,则按需提高放入桶中的令牌的速率. 一般会定时(比如100毫秒)往桶中增加一定数量的令牌, 有些变种算法则实时的计算应该增加的令牌的数量.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class TokenBucketDemo &#123;</span><br><span class="line">public long timeStamp = getNowTime();</span><br><span class="line">public int capacity; // 桶的容量</span><br><span class="line">public int rate; // 令牌放入速度</span><br><span class="line">public int tokens; // 当前令牌数量</span><br><span class="line">public boolean grant() &#123;</span><br><span class="line">    long now = getNowTime();</span><br><span class="line">    // 先添加令牌</span><br><span class="line">    tokens = min(capacity, tokens + (now - timeStamp) * rate);</span><br><span class="line">    timeStamp = now;</span><br><span class="line">    if (tokens &lt; 1) &#123;</span><br><span class="line">    // 若不到1个令牌,则拒绝</span><br><span class="line">    return false;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">    // 还有令牌，领取令牌</span><br><span class="line">    tokens -= 1;</span><br><span class="line">    return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="临界问题"><a href="#临界问题" class="headerlink" title="临界问题"></a>临界问题</h4><p>我 们再来考虑一下临界问题的场景。在0:59秒的时候，由于桶内积满了100个token，所以这100个请求可以瞬间通过。但是由于token是以较低的 速率填充的，所以在1:00的时候，桶内的token数量不可能达到100个，那么此时不可能再有100个请求通过。所以令牌桶算法可以很好地解决临界问 题。</p>
<p>下图比较了计数器（左）和令牌桶算法（右）在临界点的速率变化。我们可以看到虽然令牌桶算法允许突发速率，但是下一个突发速率必须要等桶内有足够的 token后才能发生：</p>
<p><img src="http://images.zhuxingsheng.com/201806071301_516.png"></p>
<h4 id="Guava-RateLimiter"><a href="#Guava-RateLimiter" class="headerlink" title="Guava RateLimiter"></a>Guava RateLimiter</h4><p>在guava中，有现成的实现</p>
<p>RateLimiter使用的是一种叫令牌桶的流控算法，RateLimiter会按照一定的频率往桶里扔令牌，线程拿到令牌才能执行，比如你希望自己的应用程序QPS不要超过1000，那么RateLimiter设置1000的速率后，就会每秒往桶里扔1000个令牌。</p>
<p>有两种方式，SmoothBursty和SmoothWarmingUp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create(double permitsPerSecond)</span><br><span class="line">根据指定的稳定吞吐率创建RateLimiter</span><br><span class="line">这里的吞吐率是指每秒多少许可数（通常是指QPS，每秒多少查询）</span><br><span class="line"></span><br><span class="line">create(double permitsPerSecond, long warmupPeriod, TimeUnit unit)</span><br><span class="line">根据指定的稳定吞吐率和预热期来创建RateLimiter</span><br><span class="line">这里的吞吐率是指每秒多少许可数（通常是指QPS，每秒多少个请求量），</span><br><span class="line">在这段预热时间内，</span><br><span class="line">RateLimiter每秒分配的许可数会平稳地增长直到预热期结束时达到其最大速率。（只要存在足够请求数来使其饱和）</span><br></pre></td></tr></table></figure>

<p>SmoothBursty通过平均速率和最后一次新增令牌的时间计算出下次新增令牌的时间的，另外需要一个桶暂存一段时间内没有使用的令牌（即可以突发的令牌数）。另外RateLimiter还提供了tryAcquire方法来进行无阻塞或可超时的令牌消费。</p>
<p>因为SmoothBursty允许一定程度的突发，会有人担心如果允许这种突发，假设突然间来了很大的流量，那么系统很可能扛不住这种突发。因此需要SmoothWarmingUp一种平滑速率的限流工具，从而系统冷启动后慢慢的趋于平均固定速率（即刚开始速率小一些，然后慢慢趋于我们设置的固定速率）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void testSmoothWarmingUp()&#123;</span><br><span class="line">        //每秒5个，1500ms后达到正常速率</span><br><span class="line">        RateLimiter rateLimiter = RateLimiter.create(5,1500, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        List&lt;Runnable&gt; tasks = new ArrayList&lt;Runnable&gt;();</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            tasks.add(new Request(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        for(Runnable task:tasks) &#123;</span><br><span class="line">            System.out.println(&quot;等待时间：&quot; + rateLimiter.acquire());</span><br><span class="line">            executorService.execute(task);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">等待时间：0.0</span><br><span class="line">0 handle request 1528693920502</span><br><span class="line">等待时间：0.54311</span><br><span class="line">1 handle request 1528693921052</span><br><span class="line">等待时间：0.433531</span><br><span class="line">2 handle request 1528693921486</span><br><span class="line">等待时间：0.332679</span><br><span class="line">3 handle request 1528693921819</span><br><span class="line">等待时间：0.229785</span><br><span class="line">4 handle request 1528693922049</span><br><span class="line">等待时间：0.199668</span><br><span class="line">5 handle request 1528693922249</span><br><span class="line">等待时间：0.199845</span><br><span class="line">6 handle request 1528693922449</span><br><span class="line">等待时间：0.199757</span><br><span class="line">7 handle request 1528693922649</span><br><span class="line">等待时间：0.19981</span><br><span class="line">8 handle request 1528693922849</span><br><span class="line">等待时间：0.199732</span><br><span class="line">9 handle request 1528693923049</span><br></pre></td></tr></table></figure>

<p>可以看出前面几个等待时间长，速度慢；1500ms后，速率达到正常的每秒5的速度</p>
<p>其实这算是一种漏桶算法的变异，在令牌桶中控制一个移除令牌的速度就是个漏桶了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="计数器-VS-滑动窗口"><a href="#计数器-VS-滑动窗口" class="headerlink" title="计数器 VS 滑动窗口"></a>计数器 VS 滑动窗口</h4><p>计数器算法是最简单的算法，可以看成是滑动窗口的低精度实现。滑动窗口由于需要存储多份的计数器（每一个格子存一份），所以滑动窗口在实现上需要更多的存储空间。也就是说，如果滑动窗口的精度越高，需要的存储空间就越大。</p>
<h4 id="漏桶算法-VS-令牌桶算法"><a href="#漏桶算法-VS-令牌桶算法" class="headerlink" title="漏桶算法 VS 令牌桶算法"></a>漏桶算法 VS 令牌桶算法</h4><p>漏桶算法和令牌桶算法最明显的区别是令牌桶算法允许流量一定程度的突发。因为默认的令牌桶算法，取走token是不需要耗费时间的，也就是说，假设桶内有100个token时，那么可以瞬间允许100个请求通过。</p>
<p>令牌桶算法由于实现简单，且允许某些流量的突发，对用户友好，所以被业界采用地较多。当然我们需要具体情况具体分析，只有最合适的算法，没有最优的算法</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/clds/p/5850070.html">接口限流算法总结</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/14/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/blog/page/16/">16</a><a class="extend next" rel="next" href="/blog/page/16/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">朱兴生</p>
  <div class="site-description" itemprop="description">彪悍的人生需要书写</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
        
          <span class="site-state-item-count">160</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">朱兴生</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
