<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 8.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.zhuxingsheng.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="之前写过关于zookeeper的一篇文章《zookeeper-paxos》，paxos太难理解了，当时理解了，但现在又忘记了，机械学习果然是不行的 虽然曾经有一篇文章讲阿里不使用zk做服务发现，但大多数公司的分布式架构中基本都能看到zk的身影，而且他躲在里面，你可能看不到他，感受不到他的存在 对于架构体系中的这样一位选手，了解，学习，研究是相当有必要的 ZK是什么ZooKeeper 是一个分布式的">
<meta property="og:type" content="article">
<meta property="og:title" content="zookeeper知识结构">
<meta property="og:url" content="http://www.zhuxingsheng.com/blog/zookeeper-knowledge-structure.html">
<meta property="og:site_name" content="码农戏码">
<meta property="og:description" content="之前写过关于zookeeper的一篇文章《zookeeper-paxos》，paxos太难理解了，当时理解了，但现在又忘记了，机械学习果然是不行的 虽然曾经有一篇文章讲阿里不使用zk做服务发现，但大多数公司的分布式架构中基本都能看到zk的身影，而且他躲在里面，你可能看不到他，感受不到他的存在 对于架构体系中的这样一位选手，了解，学习，研究是相当有必要的 ZK是什么ZooKeeper 是一个分布式的">
<meta property="og:locale">
<meta property="og:image" content="http://images.zhuxingsheng.com/201903131427_915.png">
<meta property="og:image" content="http://images.zhuxingsheng.com/201903191400_762.png">
<meta property="og:image" content="http://images.zhuxingsheng.com/201903191401_941.png">
<meta property="og:image" content="http://images.zhuxingsheng.com/201903201659_835.png">
<meta property="og:image" content="http://images.zhuxingsheng.com/201903201700_506.png">
<meta property="og:image" content="http://images.zhuxingsheng.com/201903201349_193.png">
<meta property="og:image" content="http://images.zhuxingsheng.com/201903201744_259.png">
<meta property="og:image" content="http://images.zhuxingsheng.com/201903141616_475.png">
<meta property="og:image" content="http://images.zhuxingsheng.com/201903141619_300.png">
<meta property="og:image" content="http://images.zhuxingsheng.com/201903251441_478.png">
<meta property="og:image" content="http://images.zhuxingsheng.com/201903251440_977.png">
<meta property="og:image" content="http://images.zhuxingsheng.com/201903251446_99.png">
<meta property="og:image" content="http://images.zhuxingsheng.com/201903191356_615.png">
<meta property="og:image" content="http://images.zhuxingsheng.com/201903151853_684.png">
<meta property="og:image" content="http://images.zhuxingsheng.com/201903191352_733.png">
<meta property="article:published_time" content="2019-03-11T11:33:00.000Z">
<meta property="article:modified_time" content="2021-11-07T13:29:17.470Z">
<meta property="article:author" content="朱兴生">
<meta property="article:tag" content="zookeeper">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://images.zhuxingsheng.com/201903131427_915.png">

<link rel="canonical" href="http://www.zhuxingsheng.com/blog/zookeeper-knowledge-structure.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>zookeeper知识结构 | 码农戏码</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">码农戏码</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">新生代农民工的自我修养</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog" rel="section"><i class="home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives" rel="section"><i class="archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags" rel="section"><i class="tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about" rel="section"><i class="user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-在线工具">

    <a href="/tools" rel="section"><i class="gavel fa-fw"></i>在线工具</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://www.zhuxingsheng.com/blog/zookeeper-knowledge-structure.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="朱兴生">
      <meta itemprop="description" content="彪悍的人生需要书写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="码农戏码">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          zookeeper知识结构
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-03-11 19:33:00" itemprop="dateCreated datePublished" datetime="2019-03-11T19:33:00+08:00">2019-03-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-07 21:29:17" itemprop="dateModified" datetime="2021-11-07T21:29:17+08:00">2021-11-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>之前写过关于zookeeper的一篇文章<a href="http://www.zhuxingsheng.com/blog/zookeeper-paxos.html">《zookeeper-paxos》</a>，paxos太难理解了，当时理解了，但现在又忘记了，机械学习果然是不行的</p>
<p>虽然曾经有一篇文章讲阿里不使用zk做服务发现，但大多数公司的分布式架构中基本都能看到zk的身影，而且他躲在里面，你可能看不到他，感受不到他的存在</p>
<p>对于架构体系中的这样一位选手，了解，学习，研究是相当有必要的</p>
<h1 id="ZK是什么"><a href="#ZK是什么" class="headerlink" title="ZK是什么"></a>ZK是什么</h1><p>ZooKeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby 一个开源的实现</p>
<p>ZooKeeper 是集群的管理者，监视着集群中各节点的状态，根据节点提交的反馈进行下 一步合理的操作。最终，将简单易用的接口和功能稳定，性能高效的系统提供给用户</p>
<blockquote>
<p>zooKeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services</p>
</blockquote>
<p>这大概描述了Zookeeper的作用，配置管理，名字服务，提供分布式同步以及集群管理</p>
<h1 id="为什么需要ZK"><a href="#为什么需要ZK" class="headerlink" title="为什么需要ZK"></a>为什么需要ZK</h1><p>知道了zk的定义，其实跟不知道差不多，还是要追根溯源，看看zk今世因缘，存在的意义</p>
<p>zk的历史很多地方都有介绍，这儿就不赘述了</p>
<p>相对历史，更想知道为什么需要zk？</p>
<p>以前经历的系统，都是使用redis做为服务中心了，不管使用single redis,还是redis cluster，能胜任架构需求，全局命名服务、订阅发布监听服务列表、分布式锁足矣</p>
<p>一度怀疑zk的价值，也阻碍了进一步学习的热情，但存在即合理</p>
<p><strong>设计 ZooKeeper 的目的是为了减轻分布式应用程序所承担的协调任务</strong></p>
<p>还是从ZK的定义追溯它的作用</p>
<h3 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h3><p>在我们的应用中除了代码外，还有一些就是各种配置。比如数据库连接等</p>
<p>一般我们都是使用配置文件的方式，在代码中引入这些配置文件。但是当我们只有一种配置，只有一台服务器，并且不经常修改的时候，使用配置文件是一个很好的做法，但是如果我们配置非常多，有很多服务器都需要这个配置，而且还可能是动态的话使用配置文件就不是个好主意了。</p>
<p>这个时候往往需要寻找一种集中管理配置的方法，我们在这个集中的地方修改了配置，所有对这个配置感兴趣的都可以获得变更。比如我们可以把配置放在数据库里，然后所有需要配置的服务都去这个数据库读取配置</p>
<p>但是，因为很多服务的正常运行都非常依赖这个配置，所以需要这个集中提供配置服务的服务具备很高的可靠性。</p>
<p>一般我们可以用一个集群来提供这个配置服务，但是用<strong>集群提升可靠性</strong>，那如何保证配置在集群中的一致性呢？ 这个时候就需要使用一种实现了一致性协议的服务了。Zookeeper就是这种服务，它使用Zab这种一致性协议来提供<strong>一致性</strong></p>
<h3 id="名字服务"><a href="#名字服务" class="headerlink" title="名字服务"></a>名字服务</h3><p>比如为了通过网络访问一个系统，我们得知道对方的IP地址，但是IP地址对人非常不友好，这个时候我们就需要使用域名来访问。</p>
<p>但是计算机是不能是别域名的。</p>
<p>怎么办呢？</p>
<p>如果我们每台机器里都备有一份域名到IP地址的映射，这个倒是能解决一部分问题，但是如果域名对应的IP发生变化了又该怎么办呢？于是我们有了DNS这个东西。</p>
<p>我们只需要访问一个大家熟知的(known)的点，它就会告诉你这个域名对应的IP是什么。</p>
<p>在我们的应用中也会存在很多这类问题，特别是在我们的服务特别多的时候，如果我们在本地保存服务的地址的时候将非常不方便，但是如果我们只需要访问一个大家都熟知的访问点，这里提供统一的入口，那么维护起来将方便得多了</p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>比如在一个分布式环境中，为了提高可靠性，我们的集群的每台服务器上都部署着同样的服务</p>
<p>但是，一件事情如果集群中的每个服务器都进行的话，那相互之间就要协调，编程起来将非常复杂。而如果我们只让一个服务进行操作，那又存在单点。通常还有一种做法就是使用分布式锁，在某个时刻只让一个服务去干活，当这台服务出问题的时候锁释放，立即fail over到另外的服务</p>
<p>这在很多分布式系统中都是这么做，这种设计有一个更好听的名字叫Leader Election(leader选举)。比如HBase的Master就是采用这种机制。但要注意的是分布式锁跟同一个进程的锁还是有区别的，所以使用的时候要比同一个进程里的锁更谨慎的使用</p>
<p>这儿其实说了两个作用</p>
<ol>
<li>传统意义的锁，如<a href="http://zhuxingsheng.com/blog/analysis-of-distributed-locks.html">《剖析分布式锁》</a>，保护对共享资料操作</li>
<li>master选举，像JOB，为了高可用，会有多台服务器部署同一套JOB程序，但在运行时，只有一台服务器真正执行业务，此时，需要选择一台服务器，如果这台机器挂了，别的机器需要顶替上来</li>
</ol>
<h3 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h3><p>在分布式的集群中，经常会由于各种原因，比如硬件故障，软件故障，网络问题，有些节点会进进出出。有新的节点加入进来，也有老的节点退出集群。这个时候，集群中其他机器需要感知到这种变化，然后根据这种变化做出对应的决策</p>
<p>比如我们是一个分布式存储系统，有一个中央控制节点负责存储的分配，当有新的存储进来的时候我们要根据现在集群目前的状态来分配存储节点</p>
<p>这个时候我们就需要<strong>动态感知到集群目前的状态</strong>，这也就是<strong>注册中心</strong></p>
<h1 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h1><p>分布式系统在设计时，都会考虑一下CAP，在现有理论下，CAP是不能同时满足的，所以需要根据业务场景选择合适的设计要求</p>
<p>CAP定义在<a href="http://www.zhuxingsheng.com/blog/zookeeper-paxos.html">《zookeeper-paxos》</a>中有详细说明</p>
<p><img src="http://images.zhuxingsheng.com/201903131427_915.png"></p>
<p>ZooKeeper是个CP（一致性+分区容错性）的，即任何时刻对ZooKeeper的访问请求能得到一致的数据结果，同时系统对网络分割具备容错性；但是它不能保证每次服务请求的可用性。也就是在极端环境下，ZooKeeper可能会丢弃一些请求，消费者程序需要重新请求才能获得结果。</p>
<p>ZooKeeper是分布式协调服务，<strong>它的职责是保证数据在其管辖下的所有服务之间保持同步、一致；所以就不难理解为什么ZooKeeper被设计成CP而不是AP特性的了</strong></p>
<p>而且， 作为ZooKeeper的核心实现算法Zab，就是解决了分布式系统下数据如何在多个服务之间保持同步问题的</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>顺序一致性：从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。</li>
<li>原子性：所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。</li>
<li>单一系统映像：无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。</li>
<li>可靠性：一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。</li>
</ul>
<h1 id="znode"><a href="#znode" class="headerlink" title="znode"></a>znode</h1><p>在谈到分布式的时候，我们通常说的“节点”是指组成集群的每一台机器<br>然而，在 ZooKeeper 中，“节点”分为两类：</p>
<ol>
<li>第一类同样是指构成集群的机器，我们称之为机器节点。</li>
<li>第二类则是指数据模型中的数据单元，我们称之为数据节点一ZNode</li>
</ol>
<p>与Linux文件系统不同的是，Linux文件系统有目录和文件的区别，而Zookeeper的数据节点称为ZNode，ZNode是Zookeeper中数据的最小单元，每个ZNode都可以保存数据，同时还可以挂载子节点，因此构成了一个层次化的命名空间，称为树</p>
<p><img src="http://images.zhuxingsheng.com/201903191400_762.png"></p>
<ul>
<li><p>每一个znode默认能够存储1MB的数据（对于记录状态性质的数据来说，够了）</p>
</li>
<li><p>可以使用zkCli命令，登录到zookeeper上，并通过ls、create、delete、sync等命令操作这些znode节点</p>
</li>
</ul>
<p>znode除了名称、数据以外，还有一套属性：zxid</p>
<p>ZooKeeper状态的每一次改变, 都对应着一个递增的Transaction id, 该id称为zxid. 由于zxid的递增性质, 如果zxid1小于zxid2, 那么zxid1肯定先于zxid2发生</p>
<p>创建任意节点, 或者更新任意节点的数据, 或者删除任意节点, 都会导致Zookeeper状态发生改变, 从而导致zxid的值增加</p>
<p><img src="http://images.zhuxingsheng.com/201903191401_941.png"></p>
<p>此外，znode还有操作权限。如果我们把以上几类属性细化，又可以得到以下属性的细节：</p>
<ul>
<li>czxid：创建节点的事务的zxid</li>
<li>mzxid：对znode最近修改的zxid</li>
<li>ctime：以距离时间原点(epoch)的毫秒数表示的znode创建时间</li>
<li>mtime：以距离时间原点(epoch)的毫秒数表示的znode最近修改时间</li>
<li>version：znode数据的修改次数</li>
<li>cversion：znode子节点修改次数</li>
<li>aversion：znode的ACL修改次数</li>
<li>ephemeralOwner：如果znode是临时节点，则指示节点所有者的会话ID；如果不是临时节点，则为零。</li>
<li>dataLength：znode数据长度。</li>
<li>numChildren：znode子节点个数。</li>
</ul>
<p>znode是由客户端创建的，它和创建它的客户端的内在联系，决定了它的存在性：</p>
<ol>
<li>PERSISTENT-持久化节点：创建这个节点的客户端在与zookeeper服务的连接断开后，这个节点也不会被删除（除非您使用API强制删除）。</li>
<li>PERSISTENT_SEQUENTIAL-持久化顺序编号节点：当客户端请求创建这个节点A后，zookeeper会根据parent-znode的zxid状态，为这个A节点编写一个全目录唯一的编号（这个编号只会一直增长）。当客户端与zookeeper服务的连接断开后，这个节点也不会被删除。</li>
<li>EPHEMERAL-临时目录节点：创建这个节点的客户端在与zookeeper服务的连接断开后，这个节点（还有涉及到的子节点）就会被删除。</li>
<li>EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点：当客户端请求创建这个节点A后，zookeeper会根据parent-znode的zxid状态，为这个A节点编写一个全目录唯一的编号（这个编号只会一直增长）。当创建这个节点的客户端与zookeeper服务的连接断开后，这个节点被删除。</li>
</ol>
<p>另外，无论是EPHEMERAL还是EPHEMERAL_SEQUENTIAL节点类型，在zookeeper的client异常终止后，节点也会被删除。</p>
<h1 id="服务的四种状态"><a href="#服务的四种状态" class="headerlink" title="服务的四种状态"></a>服务的四种状态</h1><p>服务器具有四种状态，分别是LOOKING,FOLLOWING,LEADING,OBSERVING </p>
<ul>
<li>LOOKING<br>寻找leader状态<br>当前服务器处于该状态时，它会认为当前集群中没有leader，因此需要进入leader选举状态</li>
<li>FOLLOWING<br>跟随者状态<br>表示当前服务器的角色是Follower角色 </li>
<li>LEADING<br>领导者状态<br>表示当前服务器是Leader </li>
<li>OBSERVING<br>观察者状态<br>表示当前服务器角色是Observer</li>
</ul>
<p><img src="http://images.zhuxingsheng.com/201903201659_835.png"><br><img src="http://images.zhuxingsheng.com/201903201700_506.png"></p>
<h1 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h1><p>最典型集群模式：Master&#x2F;Slave 模式（主备模式）</p>
<p>在这种模式中，通常 Master 服务器作为主服务器提供写服务，其他的 Slave 服务器从服务器通过异步复制的方式获取 Master 服务器最新的数据提供读服务</p>
<p>zookeeper都是集群形式部署的，而zk服务又分为不同角色来执行不同的任务,ZooKeeper中没有选择传统的 Master&#x2F;Slave 概念</p>
<p>而是引入了Leader、Follower 和 Observer 三种角色</p>
<p><img src="http://images.zhuxingsheng.com/201903201349_193.png"></p>
<p>在区分zk服务器角色之前，需要解释几个概念： </p>
<ul>
<li><strong>事务请求</strong><br>在zk中，那些会改变服务器状态的请求称为事务请求（创建节点、更新数据、删除节点、创建会话等等） </li>
<li><strong>非事务请求</strong><br>从zk读取数据但是不对状态进行任何修改的请求称为非事务请求</li>
</ul>
<h3 id="领导者Leader"><a href="#领导者Leader" class="headerlink" title="领导者Leader"></a>领导者Leader</h3><ol>
<li>事务请求的唯一调度和处理者，保证集群事务处理的顺序性； 	</li>
<li>集群内部各服务器的调度者</li>
<li>只有一个</li>
</ol>
<h3 id="跟随者（Follower）"><a href="#跟随者（Follower）" class="headerlink" title="跟随者（Follower）"></a>跟随者（Follower）</h3><ol>
<li>处理客户端非事务请求，转发事务请求给Leader服务器 	</li>
<li>参与事务请求Proposal的投票</li>
<li>参与Leader选举的投票</li>
</ol>
<h3 id="观察者（Observer"><a href="#观察者（Observer" class="headerlink" title="观察者（Observer):"></a>观察者（Observer):</h3><ol>
<li>Follower 和 Observer 唯一的区别在于 Observer 机器不参与 Leader 的选举过程</li>
<li>也不参与写操作的“过半写成功”策略，因此 Observer </li>
<li>机器可以在不影响写性能的情况下提升集群的读性能</li>
</ol>
<h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p><img src="http://images.zhuxingsheng.com/201903201744_259.png"></p>
<ol>
<li>在Client向Follwer发出一个写的请求</li>
<li>Follwer把请求发送给Leader</li>
<li>Leader接收到以后开始发起投票并通知Follwer进行投票</li>
<li>Follwer把投票结果发送给Leader</li>
<li>Leader将结果汇总后如果需要写入，则开始写入同时把写入操作通知给Leader，然后commit;</li>
<li>Follwer把请求结果返回给Client</li>
</ol>
<h1 id="leader选举"><a href="#leader选举" class="headerlink" title="leader选举"></a>leader选举</h1><p>选举(election)是分布式系统实践中常见的问题，通过打破节点间的对等关系，选得的leader(或叫master、coordinator)有助于实现事务原子性、提升决议效率</p>
<h2 id="为什么需要选举"><a href="#为什么需要选举" class="headerlink" title="为什么需要选举"></a>为什么需要选举</h2><p>集群本身有很多种类，如tomcat集群，集群里面每一台机器是对等的，所以其自身不存在leader之说</p>
<p>另外一类，如fastDfs，其依赖于独特的HASH算法，建立文件名和路径之间的映射关系，写操作都是通过namenode分发到各台datanode之上，算法保证了文件名的独一无二，也不存在leader的说法</p>
<p>还有memcache集群，集群里面的机器之间彼此无心跳，通过一致性hash尽可能将key值的存储分散化，降低单一memcahe服务器down机的影响。</p>
<p>还有一类是主从复制，主节点负责写，从节点负责读，提高读的性能。从节点定期通过心跳与主节点沟通，一旦主节点挂掉了，从节点马上接手主节点的任务</p>
<p>对于分布式应用，难以避免出现网络的抖动。比如，<br>主节点暂时失去响应，如瞬时负载过高，网络拥塞或者其他原因导致主节点暂时失去响应，超过响应超时时间，这个时候从节点启动，承担起leader的职责，但是原先的主节点又恢复了服务。这个时候，如果没有选举机制（不能仅仅自己宣告自己是leader，还要广而告之，让其他服务器或者客户端知道自己是leader），有可能会存在两个leader节点，导致集群发生混乱</p>
<p><strong>上图示例一下此类场景</strong></p>
<p><img src="http://images.zhuxingsheng.com/201903141616_475.png"></p>
<p>主节点出现问题，那就是单点故障</p>
<p><img src="http://images.zhuxingsheng.com/201903141619_300.png" alt="单点故障"></p>
<p>传统方式是采用一个备用节点，这个备用节点定期给当前主节点发送ping包，主节点收到ping包以后向备用节点发送回复Ack，当备用节点收到回复的时候就会认为当前主节点还活着，让他继续提供服务</p>
<p><img src="http://images.zhuxingsheng.com/201903251441_478.png"></p>
<p>当主节点挂了，这时候备用节点收不到回复了，然后他就认为主节点挂了接替他成为主节点如下图</p>
<p><img src="http://images.zhuxingsheng.com/201903251440_977.png"></p>
<p>但是这种方式就是有一个隐患，就是网络问题，来看一网络问题会造成什么后果，如下图</p>
<p><img src="http://images.zhuxingsheng.com/201903251446_99.png"></p>
<p>也就是说我们的主节点的并没有挂，只是在回复的时候网络发生故障，这样我们的备用节点同样收不到回复，就会认为主节点挂了，然后备用节点将他的Master实例启动起来，</p>
<p><strong>这样我们的分布式系统当中就有了两个主节点也就是—双Master</strong>，</p>
<p>出现Master以后我们的从节点就会将它所做的事一部分汇报给了主节点，一部分汇报给了从节点，这样服务就全乱了</p>
<h2 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h2><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>在哪些场景下需要进行leader选举</p>
<ol>
<li>服务器初始化启动</li>
<li>服务器运行期间无法和Leader保持连接</li>
</ol>
<h4 id="初始化时"><a href="#初始化时" class="headerlink" title="初始化时"></a>初始化时</h4><p>若进行Leader选举，则至少需要两台机器，这里选取3台机器组成的服务器集群为例。在集群初始化阶段，当有一台服务器Server1启动时，其单独无法进行和完成Leader选举，当第二台服务器Server2启动时，此时两台机器可以相互通信，每台机器都试图找到Leader，于是进入Leader选举过程。选举过程如下</p>
<ul>
<li>1.每个Server发出一个投票。由于是初始情况，Server1和Server2都会将自己作为Leader服务器来进行投票，每次投票会包含所推举的服务器的myid和ZXID，使用(myid, ZXID)来表示，此时Server1的投票为(1, 0)，Server2的投票为(2, 0)，然后各自将这个投票发给集群中其他机器。</li>
<li>2.接受来自各个服务器的投票。集群的每个服务器收到投票后，首先判断该投票的有效性，如检查是否是本轮投票、是否来自LOOKING状态的服务器</li>
<li>3.处理投票。针对每一个投票，服务器都需要将别人的投票和自己的投票进行PK，PK规则如下<ul>
<li>3.1.优先检查ZXID。ZXID比较大的服务器优先作为Leader</li>
<li>3.2.如果ZXID相同，那么就比较myid。myid较大的服务器作为Leader服务器</li>
</ul>
</li>
</ul>
<p>对于Server1而言，它的投票是(1, 0)，接收Server2的投票为(2, 0)，首先会比较两者的ZXID，均为0，再比较myid，此时Server2的myid最大，于是更新自己的投票为(2, 0)，然后重新投票，对于Server2而言，其无须更新自己的投票，只是再次向集群中所有机器发出上一次投票信息即可。</p>
<ul>
<li>4.统计投票。每次投票后，服务器都会统计投票信息，判断是否已经有过半机器接受到相同的投票信息，对于Server1、Server2而言，都统计出集群中已经有两台机器接受了(2, 0)的投票信息，此时便认为已经选出了Leader。</li>
<li>5.改变服务器状态。一旦确定了Leader，每个服务器就会更新自己的状态，如果是Follower，那么就变更为FOLLOWING，如果是Leader，就变更为LEADING。</li>
</ul>
<h4 id="Leader挂掉"><a href="#Leader挂掉" class="headerlink" title="Leader挂掉"></a>Leader挂掉</h4><p>在Zookeeper运行期间，Leader与非Leader服务器各司其职，即便当有非Leader服务器宕机或新加入，此时也不会影响Leader，但是一旦Leader服务器挂了，那么整个集群将暂停对外服务，进入新一轮Leader选举，其过程和启动时期的Leader选举过程基本一致。假设正在运行的有Server1、Server2、Server3三台服务器，当前Leader是Server2，若某一时刻Leader挂了，此时便开始Leader选举。选举过程如下</p>
<ul>
<li>1.变更状态。Leader挂后，余下的非Observer服务器都会讲自己的服务器状态变更为LOOKING，然后开始进入Leader选举过程</li>
<li>2.每个Server会发出一个投票。在运行期间，每个服务器上的ZXID可能不同，此时假定Server1的ZXID为123，Server3的ZXID为122；在第一轮投票中，Server1和Server3都会投自己，产生投票(1, 123)，(3, 122)，然后各自将投票发送给集群中所有机器。</li>
<li>3.接收来自各个服务器的投票。与启动时过程相同。</li>
<li>4.处理投票。与启动时过程相同，此时，Server1将会成为Leader。</li>
<li>5.统计投票。与启动时过程相同。</li>
<li>6.改变服务器的状态。与启动时过程相同</li>
</ul>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p><img src="http://images.zhuxingsheng.com/201903191356_615.png"></p>
<h4 id="理想状态"><a href="#理想状态" class="headerlink" title="理想状态"></a>理想状态</h4><p><img src="http://images.zhuxingsheng.com/201903151853_684.png"></p>
<ol>
<li>在第一轮中，按照“我最牛逼，我怕谁”的原则，每个节点都推荐它自己为集群的leader节点</li>
<li>按照我们假设的理想条件，节点S1首先收到了S2发送来的推荐者“2”，节点S1发现“2”要比它之前推荐的“1”（也就是它自己）牛。根据谁牛推荐谁的原则，“S1”清空自己的票箱，重新选举“2”（注意，此时“S1”的新票箱中已经有两票选举“2”了，一票是它自己，另外一票是”S2”，并且所有节点都是Looking状态）</li>
<li>同样的事情发生在“S2”身上：”S2”收到了”S3”发过来的推荐信息，发现“3”这个被推举者比之前自己推举的“2”要牛，于是也清空自己的票箱，发起一轮新的投票，此时“S2”选举“3”。依次类推”S3”、”S4”</li>
<li>这里要注意S5这个节点，在第一轮接受到了来源于“S1”——“S4”的推举者（一定注意，每一次接受信息，都会广播一次“我坚持推举的人”），发现“还是推荐的5最牛”，于是“我继续推举S5吧”</li>
<li>以上这个过程在整个理想的网络环境上一直持续。到了第四轮，“S1”收到了“S2”发送来的推举者“5”，发现“5”要比当前“S1”推荐的“4”要牛。所以“S1”清空了自己的票箱，重新推举“5”（发送给其他所有节点）</li>
<li>关键的第五轮来了，我们再重复一下，经过之前的选举，现在“S2”——“S5”都已经推举“5”为Leader了，而且都处于第四轮。这时他们收到了”S1”发来的新的“第五轮”投票，于是都和之前一样，做相同的一件事：清空自己的票箱，重新向其他所有节点广播自己的第五轮投票“5”</li>
<li>于是，节点X，收到了大于N &#x2F; 2 +１的选举“5”的投票，且都是第五轮投票。这样每个节点就都知道了自己的角色。，选举结束。所有将成为Follower状态的节点，向将要成为Leader的节点发起最后一次“工作是否正常”的询问。得到肯定的ack后，整个集群的工作状态就确认了</li>
</ol>
<h4 id="非理想状态"><a href="#非理想状态" class="headerlink" title="非理想状态"></a>非理想状态</h4><p>过程中出现了宕机、网络延迟、网络物理层断开等情况</p>
<p><img src="http://images.zhuxingsheng.com/201903191352_733.png"></p>
<p>在第三轮的选举过程后，“S1”,“S2”两个节点就断开了，他们的投票信息根本没有发送出去</p>
<ul>
<li>“S3”收到了“S4”,“S5”发来的投票信息，这时“S3”的票箱处于第3轮，并且发现了占大多数的投票结果：大家选举“S5”为Leader节点</li>
<li>同样的事情也发生在“S4”身上。这样“S3”,“S4”两个节点率先知道了投票结果，在最后一次询问Leader节点是否能正常工作，并得到了肯定的ACK之后，“S3”,“S4”两个节点变成了Follower状态</li>
<li>之后，无论“S3”,“S4”两个节点收到了任何节点的投票信息，都直接向源节点反馈投票结果，不会再进行投票了。</li>
<li>在投票完成后，“S1”,“S2”重新连入后，虽然他们发起了投票，但是不会再收到投票反馈了。直接根据“S3”或者“S4”发来的结果状态，变成Follower状态</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>此篇zookeeper的基础内容基本都包含了</p>
<p>了解这些基本已经入门</p>
<p>下一篇学习其中最核心的zab协议，理解原子性广播概念，以及zab的实现过程</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/hxpjava1/article/details/81003125">面试问题，请说明zookeeper的选举机制</a></p>
<p><a href="https://blog.csdn.net/yinwenjie/article/details/4761330">zookeeper选举机制</a></p>
<p><a href="http://www.cnblogs.com/leesf456/p/6107600.html">Zookeeper的Leader选举</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/zookeeper/" rel="tag"># zookeeper</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/restart-three-chaos.html" rel="prev" title="再起航三混沌">
      <i class="fa fa-chevron-left"></i> 再起航三混沌
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/zookeeper-knowledge-structure-2-zab-protocol.html" rel="next" title="zookeeper知识结构2-zab协议">
      zookeeper知识结构2-zab协议 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#ZK%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.</span> <span class="nav-text">ZK是什么</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81ZK"><span class="nav-number">2.</span> <span class="nav-text">为什么需要ZK</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86"><span class="nav-number">2.1.</span> <span class="nav-text">配置管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8D%E5%AD%97%E6%9C%8D%E5%8A%A1"><span class="nav-number">2.2.</span> <span class="nav-text">名字服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">2.3.</span> <span class="nav-text">分布式锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86"><span class="nav-number">2.4.</span> <span class="nav-text">集群管理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CAP"><span class="nav-number">3.</span> <span class="nav-text">CAP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-number">3.1.</span> <span class="nav-text">特点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#znode"><span class="nav-number">4.</span> <span class="nav-text">znode</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="nav-number">5.</span> <span class="nav-text">服务的四种状态</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%92%E8%89%B2"><span class="nav-number">6.</span> <span class="nav-text">角色</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%86%E5%AF%BC%E8%80%85Leader"><span class="nav-number">6.1.</span> <span class="nav-text">领导者Leader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%9F%E9%9A%8F%E8%80%85%EF%BC%88Follower%EF%BC%89"><span class="nav-number">6.2.</span> <span class="nav-text">跟随者（Follower）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%EF%BC%88Observer"><span class="nav-number">6.3.</span> <span class="nav-text">观察者（Observer):</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="nav-number">6.4.</span> <span class="nav-text">数据流</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#leader%E9%80%89%E4%B8%BE"><span class="nav-number">7.</span> <span class="nav-text">leader选举</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%80%89%E4%B8%BE"><span class="nav-number">7.1.</span> <span class="nav-text">为什么需要选举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E4%B8%BE"><span class="nav-number">7.2.</span> <span class="nav-text">选举</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF"><span class="nav-number">7.2.1.</span> <span class="nav-text">场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6"><span class="nav-number">7.2.2.</span> <span class="nav-text">初始化时</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leader%E6%8C%82%E6%8E%89"><span class="nav-number">7.2.3.</span> <span class="nav-text">Leader挂掉</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E7%A8%8B"><span class="nav-number">7.2.4.</span> <span class="nav-text">过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%90%86%E6%83%B3%E7%8A%B6%E6%80%81"><span class="nav-number">7.2.4.1.</span> <span class="nav-text">理想状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E7%90%86%E6%83%B3%E7%8A%B6%E6%80%81"><span class="nav-number">7.2.4.2.</span> <span class="nav-text">非理想状态</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">8.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">9.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">朱兴生</p>
  <div class="site-description" itemprop="description">彪悍的人生需要书写</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
        
          <span class="site-state-item-count">160</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">朱兴生</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
