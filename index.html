<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
<script type="text/javascript">
    var host = "zhuxingsheng.github.io";
    if ((host == window.location.host) && (window.location.protocol != "https:"))
        window.location = window.location.toString().replace(/^http:/, "https:");
</script>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






  <meta name="baidu-site-verification" content="MXFRoVpC6c" />







  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="彪悍的人生需要书写">
<meta name="keywords" content="motain源码,spring源码,码农,游戏开发,源码分析,java互联网">
<meta property="og:type" content="website">
<meta property="og:title" content="码农戏码">
<meta property="og:url" content="https://zhuxingsheng.com/index.html">
<meta property="og:site_name" content="码农戏码">
<meta property="og:description" content="彪悍的人生需要书写">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="码农戏码">
<meta name="twitter:description" content="彪悍的人生需要书写">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 'undefined',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zhuxingsheng.com/"/>




  <title> 码农戏码 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?48897be5dd7a377cc247d8870a476fb8";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">码农戏码</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zhuxingsheng.com/blog/algorithm-summary.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="朱兴生">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/6222636?v=3&s=460">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="码农戏码">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="码农戏码" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/algorithm-summary.html" itemprop="url">
                  算法概要
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-30T20:34:54+08:00">
                2018-10-30
              </time>
            

            

            
          </span>

          

          
            
          
	
	  
	  <span class="post-letters-count">
	    &nbsp; | &nbsp;
	    <span>1.1k 字</span>
	    &nbsp; | &nbsp;
	    <span>4 min</span>
	  </span>
	  

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>算法虐我千万遍，我待算法如初恋；IT人永远逃脱不了的算法</p>
</blockquote>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>算法是特定问题求解步骤的描述，在计算机中表现为指令的有限序列</p>
<p><strong>算法是独立存在的一种解决问题的方法和思想</strong></p>
<p>对于算法而言，实现的语言并不重要，重要的是思想</p>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><ol>
<li>输入: 算法具有0个或多个输入</li>
<li>输出: 算法至少有1个或多个输出</li>
<li>有穷性: 算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成</li>
<li>确定性：算法中的每一步都有确定的含义，不会出现二义性</li>
<li>可行性：算法的每一步都是可行的，也就是说每一步都能够执行有限的次数完成</li>
</ol>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p><strong>定义</strong>：如果一个问题的规模是n，解这一问题的某一算法所需要的时间为T(n)，它是n的某一函数T(n)称为这一算法的“时间复杂性”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T(n) = O(f(n))</span><br></pre></td></tr></table></figure>
<p>当输入量n逐渐加大时，时间复杂性的极限情形称为算法的“渐近时间复杂性”。</p>
<h1 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h1><p>大O表示法被用来描述一个算法的性能或复杂度。大O表示法可以用来描述一个算法的最差情况，或者一个算法执行的耗时或占用空间（例如内存或磁盘占用）</p>
<p>假设一个算法的时间复杂度是 O(n)，n在这里代表的意思就是数据的个数。</p>
<p>举个例子，如果你的代码用一个循环遍历 100 个元素，那么这个算法就是 O(n)，n 为 100，所以这里的算法在执行时就要做 100 次工作</p>
<p>大O表示法就是将算法的所有步骤转换为代数项，然后排除不会对问题的整体复杂度产生较大影响的较低阶常数和系数,<strong>只关心复杂度最重要的部分</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">规律       Big-O</span><br><span class="line"></span><br><span class="line">2             O(1)   --&gt; 就是一个常数</span><br><span class="line"></span><br><span class="line">2n + 10       O(n)   --&gt; n 对整体结果会产生最大影响</span><br><span class="line"></span><br><span class="line">5n^2         O(n^2) --&gt; n^2 具有最大影响</span><br></pre></td></tr></table></figure></p>
<p><strong>O(log n)</strong>，即对数复杂度（logarithmic complexity）。对数可以是ln(底数为e)，log10，log2 或者以其它为底数，这无关紧要，它仍然是O(log n)，正如O(2n^2) 和 O(100n^2) 都记为 O(n^2)。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h3><p>O(1)表示该算法的执行时间（或执行时占用空间）总是为一个常量，不论输入的数据集是大是小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool IsFirstElementNull(IList&lt;string&gt; elements)</span><br><span class="line">&#123;</span><br><span class="line">    return elements[0] == null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="O-N"><a href="#O-N" class="headerlink" title="O(N)"></a>O(N)</h3><p>O(N)表示一个算法的性能会随着输入数据的大小变化而线性变化。下面的例子同时也表明了大O表示法其实是用来描述一个算法的最差情况的：在for循环中，一旦程序找到了输入数据中与第二个传入的string匹配时，程序就会提前退出，然而大O表示法却总是假定程序会运行到最差情况（在这个例子中，意味着大O会表示程序全部循环完成时的性能）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bool ContainsValue(IList&lt;string&gt; elements, string value)</span><br><span class="line">&#123;</span><br><span class="line">    foreach (var element in elements)</span><br><span class="line">    &#123;</span><br><span class="line">        if (element == value) return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="O-n²"><a href="#O-n²" class="headerlink" title="O(n²)"></a>O(n²)</h3><p>for循环嵌套的复杂度就是二次方的，因为你在一个线性操作里执行另外一个线性操作（或者说： n*n =n² ）</p>
<p>如果嵌套层级不断深入的话，算法的性能将会变为O(N^3)，O(N^4)，以此类推<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (var outer = 0; outer &lt; elements.Count; outer++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (var inner = 0; inner &lt; elements.Count; inner++)</span><br><span class="line">        &#123;</span><br><span class="line">            // Don&apos;t compare with self</span><br><span class="line">            if (outer == inner) continue;</span><br><span class="line"></span><br><span class="line">            if (elements[outer] == elements[inner]) return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="O-2-N"><a href="#O-2-N" class="headerlink" title="O(2^N)"></a>O(2^N)</h3><p>O(2^N)表示一个算法的性能将会随着输入数据的每次增加而增大两倍。O(2^N)的增长曲线是一条爆炸式增长曲线——开始时较为平滑，但数据增长后曲线增长非常陡峭。一个典型的O(2^N)方法就是裴波那契数列的递归计算实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int Fibonacci(int number)</span><br><span class="line">&#123;</span><br><span class="line">    if (number &lt;= 1) return number;</span><br><span class="line"></span><br><span class="line">    return Fibonacci(number - 2) + Fibonacci(number - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="logn"><a href="#logn" class="headerlink" title="(logn)"></a>(logn)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i=1;       </span><br><span class="line">while (i&lt;=n)</span><br><span class="line">    i=i*2;</span><br></pre></td></tr></table></figure>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)</span><br></pre></td></tr></table></figure>
<p><img src="http://hexo.qnimages.zhuxingsheng.com/201810291628_723.png" alt="Big-O Complexity"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      
      <! -- 添加微信图标 -->
    
    
    
    

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zhuxingsheng.com/blog/custom-class-loader.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="朱兴生">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/6222636?v=3&s=460">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="码农戏码">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="码农戏码" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/custom-class-loader.html" itemprop="url">
                  自定义类加载器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-10T21:29:36+08:00">
                2018-10-10
              </time>
            

            

            
          </span>

          

          
            
          
	
	  
	  <span class="post-letters-count">
	    &nbsp; | &nbsp;
	    <span>3.1k 字</span>
	    &nbsp; | &nbsp;
	    <span>13 min</span>
	  </span>
	  

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1、为什么需要自定义类加载器"><a href="#1、为什么需要自定义类加载器" class="headerlink" title="1、为什么需要自定义类加载器"></a>1、为什么需要自定义类加载器</h1><ol>
<li>在<a href="https://mp.weixin.qq.com/s/yOktvsG8Cj7XBA6PjgX3Xg" target="_blank" rel="noopener">《类加载器》</a>中讲的，默认类加载器只能加载固定路径下的class，如果有特定路径下的class，需要自定义</li>
<li>安全性：系统自身需要一些jar，class，如果业务类代码中也有相同的class，破坏系统，类似双亲委托安全性</li>
</ol>
<p>可以看看tomcat自定义类加载器的原因，别的就大同小异了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a)、要保证部署在tomcat上的每个应用依赖的类库相互独立，不受影响。</span><br><span class="line">b)、由于tomcat是采用java语言编写的，它自身也有类库依赖，为了安全考虑，tomcat使用的类库要与部署的应用的类库相互独立。</span><br><span class="line">c)、有些类库tomcat与部署的应用可以共享，比如说servlet-api，使用maven编写web程序时，servlet-api的范围是provided，</span><br><span class="line">表示打包时不打包这个依赖，因为我们都知道服务器已经有这个依赖了。</span><br><span class="line">d)、部署的应用之间的类库可以共享。这听起来好像与第一点相互矛盾，但其实这很合理，类被类加载器加载到虚拟机后，</span><br><span class="line">会生成代表该类的class对象存放在永久代区域，这时候如果有大量的应用使用spring来管理，如果spring类库不能共享，</span><br><span class="line">那每个应用的spring类库都会被加载一次，将会是很大的资源浪费。</span><br></pre></td></tr></table></figure></p>
<h1 id="2、自定义加载器"><a href="#2、自定义加载器" class="headerlink" title="2、自定义加载器"></a>2、自定义加载器</h1><p>这儿主要说下我司的自定义类加载器；更复杂点的可以看看tomcat的类加载机制</p>
<p>为什么需要自定义类加载器？这可以参考章节1的答案</p>
<p>主要在于应用与基础平台的隔离，相对应用:可以有更大技术选型自由度,不用考虑基础平台的jar包版本、相对平台：更可靠安全，不被应用class影响</p>
<h2 id="类加载器结构"><a href="#类加载器结构" class="headerlink" title="类加载器结构"></a>类加载器结构</h2><p>虽然JAVA使用了类加载的委派机制，但并没严格要求开发者必须遵守该机制，我们可以打破这种”双亲委派”机制</p>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><table>
<thead>
<tr>
<th>目录</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>/servicesdir</td>
<td>业务实现jar包</td>
</tr>
<tr>
<td>/thirddir</td>
<td>业务依赖jar包</td>
</tr>
<tr>
<td>/platformdir</td>
<td>平台依赖jar包</td>
</tr>
</tbody>
</table>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul>
<li>1.PlatformClassLoader平台加载器<ul>
<li>1.1.加载/platformdir下的jar包</li>
<li>1.2.在加载时，采用了默认的“双亲委派”</li>
</ul>
</li>
<li>2.AppClassLoader应用加载器<ul>
<li>2.1.加载/servicesdir,/thirddir下的jar</li>
<li>2.2.该类加载器一定程度上打破了默认的“双亲委派”<ul>
<li>2.2.0.loadClass方法中，如果本加载器没有load到对应的类，则会检查该类是否处于平台类加载器白名单中：</li>
<li>2.2.1.如果处于白名单中，则委派PlatformClassLoader加载</li>
<li>2.2.2.否则，通过super.loadClass(String,boolean)走默认的双亲委派</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>此处白名单类：平台核心类，不能被同名业务类干扰</p>
<h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><p><a href="https://mp.weixin.qq.com/s/yOktvsG8Cj7XBA6PjgX3Xg" target="_blank" rel="noopener">《类加载器》</a>中说过，程序启动后，并不会加载所有类，在运行中实现到时，才会去加载。这儿就有性能损耗。</p>
<p>按类加载规则，一个类只加载一次</p>
<p>可以测试一下，加载需要的损耗<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 类加载时间性能测试</span><br><span class="line"> *</span><br><span class="line"> * 看一下类加载需要消耗的时间</span><br><span class="line"> * Created by Jack on 2018/10/8.</span><br><span class="line"> */</span><br><span class="line">public class ClassLoaderTest1 &#123;</span><br><span class="line">    public static void main(String[] args) throws SQLException &#123;</span><br><span class="line">        long s = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        LoaderClass loaderClass = new LoaderClass();</span><br><span class="line">        long e = System.nanoTime();</span><br><span class="line">        //第一次时间</span><br><span class="line">        System.out.println(e - s);</span><br><span class="line">        e = System.nanoTime();</span><br><span class="line">        //第二次实例，但已经加载过，不再需要加载</span><br><span class="line">        LoaderClass loaderClass1 = new LoaderClass();</span><br><span class="line">        long e1 = System.nanoTime();</span><br><span class="line">        //第二次时间</span><br><span class="line">        System.out.println(e1 - e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//输出</span><br><span class="line">2409737</span><br><span class="line">396</span><br></pre></td></tr></table></figure></p>
<p>可以从输出看到性能损耗是不小的，这部分损耗可以通过预加载来消除</p>
<p>随着程序运行时间越久，被触发的业务越多，那加载到的业务类越多。</p>
<h3 id="预加载类的逻辑"><a href="#预加载类的逻辑" class="headerlink" title="预加载类的逻辑"></a>预加载类的逻辑</h3><p>ClassWarmUp</p>
<ul>
<li>1.在classloader中loadClass时，把className加入到LinkedBlockingDeque中</li>
<li>2.为了性能，异步把deque中的class写入到文件中，需要起一个后台线程<ul>
<li>2.1 后台线程，从deque中取出class，写入到文件中</li>
</ul>
</li>
<li>3.下次从文件中预先加载class</li>
</ul>
<h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>对于/servicesdir 与 /thirddir 都好处理，但对于platformdir是怎么打包的呢？毕竟在开发时，只是引入一个平台基础jar就行</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>有了自定义类加载器，在应用主函数中，就不能直接new了，不然就会使用AppClassLoader</p>
<p>所以需要使用反射机制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; loadClass = platformClassLoader.loadClass(&quot;com.jack.Start&quot;);</span><br><span class="line">Method startMethod = loadClass.getMethod(&quot;startUp&quot;);</span><br><span class="line">startMethod.invoke(loadClass);</span><br></pre></td></tr></table></figure>
<p>这样，通过Start加载的类也会通过platformClassLoader去加载</p>
<p>创建springcontext也一样,这儿还需使用到Thread.currentThread().getContextClassLoader()【下面有详解】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader currentThreadLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">Thread.currentThread().setContextClassLoader(appClassLoader);</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; contextClass = appClassLoader</span><br><span class="line">				.loadClass(&quot;org.springframework.context.support.FileSystemXmlApplicationContext&quot;);</span><br><span class="line">Class&lt;?&gt;[] parameterTypes = new Class[] &#123; String[].class &#125;;</span><br><span class="line">Constructor&lt;?&gt; constructor = contextClass.getConstructor(parameterTypes);</span><br><span class="line">return constructor.newInstance(new Object[] &#123; xmlPaths.toArray(new String[0]) &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// switch back the thread context classloader</span><br><span class="line">Thread.currentThread().setContextClassLoader(currentThreadLoader);</span><br></pre></td></tr></table></figure></p>
<h1 id="3、反常"><a href="#3、反常" class="headerlink" title="3、反常"></a>3、反常</h1><p>“双亲委派”模型有优点，也有力不从心的地方</p>
<blockquote>
<p>Java 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等。</p>
</blockquote>
<blockquote>
<p>这些 SPI 的接口由 Java 核心库来提供，而这些 SPI 的实现代码则是作为 Java 应用所依赖的 jar 包被包含进类路径（CLASSPATH）里。SPI接口中的代码经常需要加载具体的实现类。那么问题来了，SPI的接口是Java核心库的一部分，是由启动类加载器(Bootstrap Classloader)来加载的；SPI的实现类是由系统类加载器(System ClassLoader)来加载的。引导类加载器是无法找到 SPI 的实现类的，因为依照双亲委派模型，BootstrapClassloader无法委派AppClassLoader来加载类。<br>而线程上下文类加载器破坏了“双亲委派模型”，可以在执行线程中抛弃双亲委派加载链模式，使程序可以逆向使用类加载器。</p>
</blockquote>
<h2 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h2><ol>
<li>当高层提供了统一的接口让低层去实现，同时又要在高层加载（或者实例化）低层的类时，就必须要通过线程上下文类加载器来帮助高层的ClassLoader找到并加载该类</li>
<li>当使用本类托管类加载，然而加载本类的ClassLoader未知时，为了隔离不同的调用者，可以取调用者各自的线程上下文类加载器代为托管</li>
</ol>
<h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><p>从jdk1.2开始引入的，类Thread中的getContextClassLoader()与setContextClassLoader(ClassLoader c1)，分别用来获取和设置类加载器</p>
<p>一般使用模式：获取-使用-还原</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); </span><br><span class="line">try&#123;    </span><br><span class="line">    Thread.currentThread().setContextClassLoader(targetTccl);    </span><br><span class="line">    excute(); </span><br><span class="line">&#125; finally &#123; </span><br><span class="line">    Thread.currentThread().setContextClassLoader(classLoader); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="jdbc"><a href="#jdbc" class="headerlink" title="jdbc"></a>jdbc</h2><p>以jdbc看下场景1的情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/testdb&quot;;    </span><br><span class="line">// 通过java库获取数据库连接</span><br><span class="line">Connection conn = java.sql.DriverManager.getConnection(url, &quot;name&quot;, &quot;password&quot;);</span><br></pre></td></tr></table></figure>
<ul>
<li>1.Class.forName(“com.mysql.jdbc.Driver”); 在com.mysql.jdbc.Driver中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123;</span><br><span class="line">	static &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			java.sql.DriverManager.registerDriver(new Driver());</span><br><span class="line">		&#125; catch (SQLException E) &#123;</span><br><span class="line">			throw new RuntimeException(&quot;Can&apos;t register driver!&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	public Driver() throws SQLException &#123;</span><br><span class="line">		// Required for Class.forName().newInstance()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>通过Class.forName()，主要就是执行初始化static代码块，也就是向DriverManager注册Driver</p>
<p>此时：应用类、Driver是由AppClassLoader加载，但由于双亲委派java.sql.DriverManager是由BootstrapClassLoader加载</p>
<ul>
<li>2.java.sql.DriverManager.getConnection 获取连接<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">private static Connection getConnection(</span><br><span class="line">	String url, java.util.Properties info, ClassLoader callerCL) throws SQLException &#123;</span><br><span class="line">	java.util.Vector drivers = null;</span><br><span class="line">        </span><br><span class="line">	synchronized(DriverManager.class) &#123;	 </span><br><span class="line">	  if(callerCL == null) &#123;</span><br><span class="line">	      callerCL = Thread.currentThread().getContextClassLoader();</span><br><span class="line">	   &#125;    </span><br><span class="line">	&#125; </span><br><span class="line">	 </span><br><span class="line">	if(url == null) &#123;</span><br><span class="line">	    throw new SQLException(&quot;The url cannot be null&quot;, &quot;08001&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	println(&quot;DriverManager.getConnection(\&quot;&quot; + url + &quot;\&quot;)&quot;);</span><br><span class="line">    </span><br><span class="line">	if (!initialized) &#123;</span><br><span class="line">	    initialize();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	synchronized (DriverManager.class)&#123; </span><br><span class="line">	    drivers = readDrivers;  </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">	SQLException reason = null;</span><br><span class="line">	for (int i = 0; i &lt; drivers.size(); i++) &#123;</span><br><span class="line">	    DriverInfo di = (DriverInfo)drivers.elementAt(i);</span><br><span class="line">  </span><br><span class="line">	    if ( getCallerClass(callerCL, di.driverClassName ) != di.driverClass ) &#123;</span><br><span class="line">		println(&quot;    skipping: &quot; + di);</span><br><span class="line">		continue;</span><br><span class="line">	    &#125;</span><br><span class="line">	    try &#123;</span><br><span class="line">		println(&quot;    trying &quot; + di);</span><br><span class="line">		Connection result = di.driver.connect(url, info);</span><br><span class="line">		if (result != null) &#123;</span><br><span class="line">		    // Success!</span><br><span class="line">		    println(&quot;getConnection returning &quot; + di);</span><br><span class="line">		    return (result);</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125; catch (SQLException ex) &#123;</span><br><span class="line">		if (reason == null) &#123;</span><br><span class="line">		    reason = ex;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	if (reason != null)    &#123;</span><br><span class="line">	    println(&quot;getConnection failed: &quot; + reason);</span><br><span class="line">	    throw reason;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	println(&quot;getConnection: no suitable driver found for &quot;+ url);</span><br><span class="line">	throw new SQLException(&quot;No suitable driver found for &quot;+ url, &quot;08001&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private static Class getCallerClass(ClassLoader callerClassLoader, </span><br><span class="line">					String driverClassName) &#123;</span><br><span class="line">	Class callerC = null;</span><br><span class="line"> </span><br><span class="line">	try &#123;</span><br><span class="line">	    callerC = Class.forName(driverClassName, true, callerClassLoader);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Exception ex) &#123;</span><br><span class="line">	    callerC = null;           // being very careful </span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	return callerC;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这其中有两行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">callerCL = Thread.currentThread().getContextClassLoader();</span><br><span class="line"></span><br><span class="line">callerC = Class.forName(driverClassName, true, callerClassLoader);</span><br></pre></td></tr></table></figure></p>
<p>这儿是取线程上下文中的classloader，也就是AppClassLoader；如果不取此classloader，那么Class.forName(driverClassName)就是使用DriverManager的BootstrapClassLoader加载，那必然是加载不到，这也就是父层类加载器加载不了低层类。</p>
<p>还有个问题，为什么在应用程序中已经加载过Driver，到了getConnection()又要再加载，还得通过Thread.currentThread().getContextClassLoader()？</p>
<p>其实在getConnection()中，只是对比class是否是同一个，像tomcat那样，各个应用都有自己的mysql-driver的jar包，就只能通过classloader来区分，因为class是不是相同需要classname+classloader组合鉴别</p>
<h2 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h2><p>对于场景2的问题</p>
<blockquote>
<p>如果有 10 个 Web 应用程序都用到了spring的话，可以把Spring的jar包放到 common 或 shared 目录下让这些程序共享。Spring 的作用是管理每个web应用程序的bean，getBean时自然要能访问到应用程序的类，而用户的程序显然是放在 /WebApp/WEB-INF 目录中的（由 WebAppClassLoader 加载），那么在 CommonClassLoader 或 SharedClassLoader 中的 Spring 容器如何去加载并不在其加载范围的用户程序（/WebApp/WEB-INF/）中的Class呢？</p>
</blockquote>
<blockquote>
<p>答案呼之欲出：spring根本不会去管自己被放在哪里，它统统使用线程上下文加载器来加载类，而线程上下文加载器默认设置为了WebAppClassLoader，也就是说哪个WebApp应用调用了spring，spring就去取该应用自己的WebAppClassLoader来加载bean</p>
</blockquote>
<p>org.springframework.web.context.ContextLoader类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public WebApplicationContext initWebApplicationContext(ServletContext servletContext) &#123;</span><br><span class="line">		if (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != null) &#123;</span><br><span class="line">			throw new IllegalStateException(</span><br><span class="line">					&quot;Cannot initialize context because there is already a root application context present - &quot; +</span><br><span class="line">					&quot;check whether you have multiple ContextLoader* definitions in your web.xml!&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Log logger = LogFactory.getLog(ContextLoader.class);</span><br><span class="line">		servletContext.log(&quot;Initializing Spring root WebApplicationContext&quot;);</span><br><span class="line">		if (logger.isInfoEnabled()) &#123;</span><br><span class="line">			logger.info(&quot;Root WebApplicationContext: initialization started&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		long startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			// Determine parent for root web application context, if any.</span><br><span class="line">			ApplicationContext parent = loadParentContext(servletContext);</span><br><span class="line"></span><br><span class="line">			// Store context in local instance variable, to guarantee that</span><br><span class="line">			// it is available on ServletContext shutdown.</span><br><span class="line">			this.context = createWebApplicationContext(servletContext, parent);</span><br><span class="line">			servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);</span><br><span class="line"></span><br><span class="line">			ClassLoader ccl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">			if (ccl == ContextLoader.class.getClassLoader()) &#123;</span><br><span class="line">				currentContext = this.context;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (ccl != null) &#123;</span><br><span class="line">				currentContextPerThread.put(ccl, this.context);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Published root WebApplicationContext as ServletContext attribute with name [&quot; +</span><br><span class="line">						WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + &quot;]&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			if (logger.isInfoEnabled()) &#123;</span><br><span class="line">				long elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class="line">				logger.info(&quot;Root WebApplicationContext: initialization completed in &quot; + elapsedTime + &quot; ms&quot;);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			return this.context;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (RuntimeException ex) &#123;</span><br><span class="line">			logger.error(&quot;Context initialization failed&quot;, ex);</span><br><span class="line">			servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Error err) &#123;</span><br><span class="line">			logger.error(&quot;Context initialization failed&quot;, err);</span><br><span class="line">			servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err);</span><br><span class="line">			throw err;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>关键代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 获取线程上下文类加载器，默认为WebAppClassLoader</span><br><span class="line">ClassLoader ccl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">// 如果spring的jar包放在每个webapp自己的目录中</span><br><span class="line">// 此时线程上下文类加载器会与本类的类加载器（加载spring的）相同，都是WebAppClassLoader</span><br><span class="line">if (ccl == ContextLoader.class.getClassLoader()) &#123;</span><br><span class="line">    currentContext = this.context;</span><br><span class="line">&#125;</span><br><span class="line">else if (ccl != null) &#123;</span><br><span class="line">    // 如果不同，也就是上面说的那个问题的情况，那么用一个map把刚才创建的WebApplicationContext及对应的WebAppClassLoader存下来</span><br><span class="line">    // 一个webapp对应一个记录，后续调用时直接根据WebAppClassLoader来取出</span><br><span class="line">    currentContextPerThread.put(ccl, this.context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样做的目的在于当通过ConetxtLoader的静态方法获取context的时候，能保证获取的是当前web application的context.实际上就是对于tomcat下面的任何一个线程，我们都能很方便的找出这个线程对应的webapplicationContext.于是在一些不能方便获取servletContext的场合，我们可以通过当前线程获取webapplicationContext.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static WebApplicationContext getCurrentWebApplicationContext() &#123;</span><br><span class="line">		ClassLoader ccl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">		if (ccl != null) &#123;</span><br><span class="line">			WebApplicationContext ccpt = currentContextPerThread.get(ccl);</span><br><span class="line">			if (ccpt != null) &#123;</span><br><span class="line">				return ccpt;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return currentContext;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简而言之就是ContextClassLoader默认存放了AppClassLoader的引用，由于它是在运行时被放在了线程中，所以不管当前程序处于何处（BootstrapClassLoader或是ExtClassLoader等），在任何需要的时候都可以用Thread.currentThread().getContextClassLoader()取出应用程序类加载器来完成需要的操作</p>
<h1 id="4、参考资料"><a href="#4、参考资料" class="headerlink" title="4、参考资料"></a>4、参考资料</h1><p><a href="https://blog.csdn.net/liweisnake/article/details/8795976" target="_blank" rel="noopener">以jdbc为例搞清contextClassLoader</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      
      <! -- 添加微信图标 -->
    
    
    
    

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zhuxingsheng.com/blog/classloader.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="朱兴生">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/6222636?v=3&s=460">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="码农戏码">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="码农戏码" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/classloader.html" itemprop="url">
                  类加载器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-10T20:57:00+08:00">
                2018-10-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          
	
	  
	  <span class="post-letters-count">
	    &nbsp; | &nbsp;
	    <span>6k 字</span>
	    &nbsp; | &nbsp;
	    <span>22 min</span>
	  </span>
	  

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="java执行过程"><a href="#java执行过程" class="headerlink" title="java执行过程"></a>java执行过程</h1><p>先回顾一下要执行java程序，需要经过哪些步骤</p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/jit/compile.png" alt="执行java程序"></p>
<ol>
<li>编写java代码</li>
<li>通过javac把源代码编译成class</li>
<li>把class载入JVM</li>
</ol>
<p>1、2两步是需要开发人员参与的，而第3步是JVM的行为，对开发人员透明</p>
<h2 id="JVM类加载"><a href="#JVM类加载" class="headerlink" title="JVM类加载"></a>JVM类加载</h2><p>详细看下第三点，class载入JVM过程</p>
<p>从内存空间视角,会分配到各个空间：</p>
<p><img src="http://hexo.qnimages.zhuxingsheng.com/201809261932_365.png" alt="内存结构"></p>
<p>每个内存空间详情可参考：《GC及JVM参数》</p>
<p>从类生命周期角度，分阶段：</p>
<p><img src="http://hexo.qnimages.zhuxingsheng.com/201809261921_783.png" alt="类生命周期"></p>
<p>其中类加载的过程包括了<strong>加载</strong>、<strong>验证</strong>、<strong>准备</strong>、<strong>解析</strong>、<strong>初始化</strong>五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p>
<h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1.加载"></a>1.加载</h3><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口</p>
<p>在加载阶段，虚拟机需要完成以下3件事情：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ol>
<p><strong>加载.class文件的方式</strong></p>
<ul>
<li>从本地系统中直接加载</li>
<li>通过网络下载.class文件</li>
<li>从zip，jar等归档文件中加载.class文件</li>
<li>从专有数据库中提取.class文件</li>
<li>将Java源文件动态编译为.class文件</li>
</ul>
<p><em>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载</em></p>
<p>加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，<br>而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据</p>
<h4 id="加载时机"><a href="#加载时机" class="headerlink" title="加载时机"></a>加载时机</h4><ul>
<li><p>当应用程序启动的时候，所有的类不会被一次性加载，因为如果一次性加载，内存资源有限，可能会影响应用程序的正常运行。例如，A a=new A()，<br>一个类真正被加载的时机是在创建对象的时候，才会去执行以上过程，加载类。当我们测试的时候，最先加载拥有main方法的主线程所在类</p>
</li>
<li><p>Java虚拟机有预加载功能。类加载器并不需要等到某个类被”首次主动使用”时再加载它,JVM规范规定JVM可以预测加载某一个类，如果这个类出错，但是应用程序没有调用这个类， JVM也不会报错；如果调用这个类的话，JVM才会报错，（LinkAgeError错误)</p>
</li>
</ul>
<h4 id="加载方式"><a href="#加载方式" class="headerlink" title="加载方式"></a>加载方式</h4><h5 id="隐式加载"><a href="#隐式加载" class="headerlink" title="隐式加载"></a>隐式加载</h5><ol>
<li>创建类对象</li>
<li>使用类的静态域</li>
<li>创建子类对象</li>
<li>使用子类的静态域</li>
<li>在JVM启动时，BootStrapLoader会加载一些JVM自身运行所需的class</li>
<li>在JVM启动时，ExtClassLoader会加载指定目录下一些特殊的class</li>
<li>在JVM启动时，AppClassLoader会加载classpath路径下的class，以及main函数所在的类的class文件</li>
</ol>
<h5 id="显式加载"><a href="#显式加载" class="headerlink" title="显式加载"></a>显式加载</h5><ol>
<li>ClassLoader.loadClass(className)，不会进行初始化</li>
<li>Class.forName(String name, boolean initialize,ClassLoader loader);  借助当前调用者的class的ClassLoader完成class的加载,加载class的同时根据initialize是否初始化</li>
</ol>
<h3 id="2-连接"><a href="#2-连接" class="headerlink" title="2.连接"></a>2.连接</h3><h4 id="2-1-验证：确保被加载的类的正确性"><a href="#2-1-验证：确保被加载的类的正确性" class="headerlink" title="2.1.验证：确保被加载的类的正确性"></a>2.1.验证：确保被加载的类的正确性</h4><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：</p>
<p><strong>文件格式验证</strong>：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</p>
<p><strong>元数据验证</strong>：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。</p>
<p><strong>字节码验证</strong>：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p>
<p><strong>符号引用验证</strong>：确保解析动作能正确执行。</p>
<p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用<strong>-Xverify:none</strong>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间</p>
<h4 id="2-2-准备：为类的静态变量分配内存，并将其初始化为默认值"><a href="#2-2-准备：为类的静态变量分配内存，并将其初始化为默认值" class="headerlink" title="2.2. 准备：为类的静态变量分配内存，并将其初始化为默认值"></a>2.2. 准备：为类的静态变量分配内存，并将其初始化为默认值</h4><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p>
<ul>
<li>2.2.1、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</li>
<li>2.2.2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。<br>假设一个类变量的定义为：public static int value = 3；<br> 那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行</li>
<li><p>2.2.3、如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。</p>
<p> 假设上面的类变量value被定义为： public static final int value = 3；</p>
<p> 编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3</p>
</li>
</ul>
<h4 id="2-3-解析：虚拟机将常量池中的符号引用替换为直接引用（内存地址）的过程"><a href="#2-3-解析：虚拟机将常量池中的符号引用替换为直接引用（内存地址）的过程" class="headerlink" title="2.3. 解析：虚拟机将常量池中的符号引用替换为直接引用（内存地址）的过程"></a>2.3. 解析：虚拟机将常量池中的符号引用替换为直接引用（内存地址）的过程</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</p>
<h5 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h5><ol>
<li>字面量：比较接近Java语言层面，如String字符串,声明final的常量等</li>
<li>符号引用：属于编译原理方面的概念:1、包括类和接口的全限定名 2、字段的名称和描述符3.方法的名称和描述符</li>
</ol>
<h6 id="常量项结构"><a href="#常量项结构" class="headerlink" title="常量项结构"></a>常量项结构</h6><p><img src="http://hexo.qnimages.zhuxingsheng.com/201809281128_30.png" alt="常量项结构"></p>
<p>这些内容，需要再去分析class文件详细结构，后续再学习了</p>
<h3 id="3-初始化，为类的静态变量赋予正确的初始值"><a href="#3-初始化，为类的静态变量赋予正确的初始值" class="headerlink" title="3.初始化，为类的静态变量赋予正确的初始值"></a>3.初始化，为类的静态变量赋予正确的初始值</h3><p>类加载的最后一个阶段，除了加载阶段我们可以通过自定义类加载器参与之外，其余完全又JVM主导。到了初始化阶段，才真正开始执行程序，也就是由java转换成的class</p>
<p>JVM负责对类进行初始化，主要对类变量进行初始化。</p>
<p>在Java中对类变量进行初始值设定有两种方式：</p>
<ol>
<li><p>声明类变量是指定初始值</p>
</li>
<li><p>使用静态代码块为类变量指定初始值</p>
</li>
</ol>
<h4 id="JVM初始化规则"><a href="#JVM初始化规则" class="headerlink" title="JVM初始化规则"></a>JVM初始化规则</h4><p>类初始化时机：只有当对类的主动使用的时候才会导致类的初始化</p>
<p>Java程序对类的使用方式可以分为两种： </p>
<ol>
<li>主动使用：会执行加载、连接、初始化静态域</li>
<li>被动使用：只执行加载、连接，不执行类的初始化静态域</li>
</ol>
<h5 id="类的主动使用包括以下六种："><a href="#类的主动使用包括以下六种：" class="headerlink" title="类的主动使用包括以下六种："></a>类的主动使用包括以下六种：</h5><ul>
<li>创建类的实例，如（1）new （2）反射newInstance （3）序列化生成obj;遇到new、getstatic、putstatic、invokestatic这四条字节码指令</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值 （注意static 与static final的区别）</li>
<li>调用类的静态方法</li>
<li>反射（如Class.forName(“Test”)）</li>
<li>初始化某个类的子类，则其父类也会被初始化；接口初始化不会导致父接口的初始化(这其实也是static final的原因)；对于静态字段，<ul>
<li>只有直接定义这个字段的类才会被初始化，因此，通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化</li>
</ul>
</li>
<li>Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类</li>
</ul>
<h5 id="被动使用，不在主动使用的六种以内都是被动的"><a href="#被动使用，不在主动使用的六种以内都是被动的" class="headerlink" title="被动使用，不在主动使用的六种以内都是被动的"></a>被动使用，不在主动使用的六种以内都是被动的</h5><ul>
<li>1.如通过子类引用父类的静态字段，为子类的被动使用，不会导致子类初始化</li>
<li>2.通过数组定义类引用类，为类的被动使用，不会触发此类的初始化<ul>
<li>2.1 原因：其实数组已经不是E类型了，E的数组jvm在运行期，会动态生成一个新的类型，新类型为：<pre><code>如果是一维数组，则为：[L+元素的类全名；二维数组，则为[[L+元素的类全名
如果是基础类型（int/float等），则为[I（int类型）、[F（float类型）等
</code></pre></li>
</ul>
</li>
<li>3.常量在编译阶段会存入调用方法所在的类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 主动 被动使用问题测试</span><br><span class="line"> * Created by Jack on 2018/9/28.</span><br><span class="line"> */</span><br><span class="line">public class ClassInitTest3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String x = F.s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class F &#123;</span><br><span class="line">    //因为UUID.randomUUID().toString()这个方法，是运行期确认的，所以，这不是被动使用</span><br><span class="line">    static final String s = UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        //这儿会被输出</span><br><span class="line">        System.out.println(&quot;Initialize class F&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="clinit-与-init"><a href="#clinit-与-init" class="headerlink" title="clinit 与 init"></a>clinit 与 init</h4><p>在编译生成class文件时，编译器会产生两个方法加于class文件中，一个是类的初始化方法clinit, 另一个是实例的初始化方法init</p>
<h5 id="clinit："><a href="#clinit：" class="headerlink" title="clinit："></a>clinit：</h5><p>clinit指的是类构造器，这个构造器是jvm自动合并生成的，在jvm<strong>第一次加载</strong>class文件时调用，包括静态变量初始化语句和静态块的执行</p>
<p>它合并static变量的赋值操作</p>
<ol>
<li>注意是赋值操作，<strong>(仅声明，或者final static)</strong>不会触发<clinit>，毕竟前面准备阶段已经默认赋过值为0了</clinit></li>
<li>static{}语句块生成，且虚拟机保证<clinit>执行前，父类的<clinit>已经执行完毕，所以说父类如果定义static块的话，一定比子类先执行</clinit></clinit></li>
<li>如果一个类或接口中没有static变量的赋值操作和static{}语句块，那么<clinit>不会被JVM生成</clinit></li>
<li>static变量的赋值操作和static{}语句块合并的顺序是由语句在源文件中出现的顺序所决定的。</li>
</ol>
<h5 id="init"><a href="#init" class="headerlink" title="init:"></a>init:</h5><p>在实例创建出来的时候调用，也就是构造函数，包括:</p>
<ol>
<li>new操作符</li>
<li>普通代码块</li>
<li>调用Class或java.lang.reflect.Constructor对象的newInstance()方法；</li>
<li>调用任何现有对象的clone()方法；</li>
<li>通过java.io.ObjectInputStream类的getObject()方法反序列化。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * &lt;clinit&gt; 与 &lt;init&gt; 区别</span><br><span class="line"> */</span><br><span class="line">public class ClassInitTest2 &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;cinit&quot;);</span><br><span class="line"></span><br><span class="line">        i = 3;//可以赋值</span><br><span class="line">        //System.out.println(i);//但不能使用，语法错误</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int i = 1;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;init&quot;);//实例化构造器，</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String [] args)	&#123;</span><br><span class="line">        new ClassInitTest2();</span><br><span class="line">        new ClassInitTest2();</span><br><span class="line">        String str = &quot;str&quot;;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">cinit</span><br><span class="line">init</span><br><span class="line">init</span><br><span class="line">str</span><br></pre></td></tr></table></figure>
<p>static 与 static final 对初始化的区别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * static 与 static final 对初始化的区别</span><br><span class="line"> */</span><br><span class="line">public class ClassInitFinalTest &#123;</span><br><span class="line">    public static  int age = 20;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        //如果age定义为static final，这儿就不会执行</span><br><span class="line">        System.out.println(&quot;静态初始化！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        System.out.println(ClassInitFinalTest.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="不会执行类初始化的几种情况"><a href="#不会执行类初始化的几种情况" class="headerlink" title="不会执行类初始化的几种情况"></a>不会执行类初始化的几种情况</h4><ul>
<li>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。</li>
<li>定义对象数组，不会触发该类的初始化</li>
<li>类A引用类B的static final常量不会导致类B初始化 (看上面的ClassInitFinalTest)</li>
<li>通过类名获取Class对象，不会触发类的初始化。如</li>
<li>System.out.println(Person.class);</li>
<li>通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。</li>
<li>通过ClassLoader默认的loadClass方法，也不会触发初始化动作</li>
</ul>
<h3 id="结束生命周期"><a href="#结束生命周期" class="headerlink" title="结束生命周期"></a>结束生命周期</h3><p>在如下几种情况下，Java虚拟机将结束生命周期</p>
<ul>
<li>执行了System.exit()方法</li>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止</li>
</ul>
<h2 id="类加载测试"><a href="#类加载测试" class="headerlink" title="类加载测试"></a>类加载测试</h2><p>看到一段代码，很有意思<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 测试类加载及初始化顺序问题</span><br><span class="line"> * Created by jack01.zhu on 2018/9/28.</span><br><span class="line"> */</span><br><span class="line">public class ClassInit &#123;</span><br><span class="line">        private static ClassInit singleton = new ClassInit();</span><br><span class="line">        public static int counter1;</span><br><span class="line">        public static int counter2 = 0;</span><br><span class="line">        private ClassInit() &#123;</span><br><span class="line">            counter1++;</span><br><span class="line">            counter2++;</span><br><span class="line">        &#125;</span><br><span class="line">        public static ClassInit getSingleton() &#123;</span><br><span class="line">            return singleton;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 通过输出结果，推测类加载过程</span><br><span class="line"> * Created by jack01.zhu on 2018/9/28.</span><br><span class="line"> */</span><br><span class="line">public class ClassInitTestMain &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String []args) &#123;</span><br><span class="line">        ClassInit classInitTest = ClassInit.getSingleton();</span><br><span class="line">        System.out.println(&quot;counter1=&quot;+classInitTest.counter1);</span><br><span class="line">        System.out.println(&quot;counter2=&quot;+classInitTest.counter2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码输出的结果是什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">counter1=1</span><br><span class="line">counter2=0</span><br></pre></td></tr></table></figure></p>
<ol>
<li>入口肯定是ClassInitTestMain.main()，从这儿开始加载，初始化</li>
<li><p>ClassInit.getSingleton()，首次使用化，所以从加载部分开始执行，执行到<strong>准备阶段</strong>所有static变量都被设置为初始值。此时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static int counter1 = 0;</span><br><span class="line">public static int counter2 = 0;</span><br><span class="line">private static ClassInit singleton = null;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ClassInit执行到初始化阶段，生成类构造器<clinit>，类构造器会合并 static变量的赋值操作和 static语句块。合并后执行</clinit></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static int counter1 ; // 由于 counter1没被赋值，所以不会被合并进去</span><br><span class="line"></span><br><span class="line">public void clinit() &#123;// 伪代码：&lt;clinit&gt;方法体内容</span><br><span class="line">  ClassInit singleton = new ClassInit();//（1）</span><br><span class="line">  int counter2 = 0;// （2）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化阶段 执行clinit内代码，执行到（1）处，此时counter1和counter2都变为1。</p>
</li>
<li>初始化阶段 执行clinit内代码，执行到（2）处，counter2又被设置为0。</li>
<li>初始化结束 ，回到Main方法的ClassInit.getSingleton();继续执行main方法，最后输出结束。</li>
</ol>
<hr>
<p>以上，就是一个类的生命周期，这篇重点就是加载部分，如上面所说，加载阶段相对别的阶段，对开发人员而言有更强的可控性;下面学习一下类加载器相关知识</p>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p><img src="http://hexo.qnimages.zhuxingsheng.com/201809281552_12.png" alt="类加载器"></p>
<blockquote>
<ol>
<li><p>BootstrapClassLoader:加载路径: System.getProperty(“java.class.path”) 或直接通过 -Xbootclasspath 指定</p>
<p>特性: 用C语言写的</p>
<p>手动获取加载路径: sun.misc.Launcher.getBootstrapClassPath().getURLs()</p>
</li>
<li><p>ExtClassLoader:加载路径: System.getProperty(“java.ext.dirs”) 或直接通过 -Djava.ext.dirs 指定</p>
<p>特性: 继承 URLClassLoader</p>
<p>手动获取加载路径:((URLClassLoader)App.class.getClassLoader().getParent()).getURLs()</p>
</li>
<li><p>AppClassLoader:加载路径: System.getProperty(“sun.boot.class.path”) 或直接通过 -cp, -classpath 指定</p>
<p>特性: 继承 URLClassLoader</p>
<p>手动获取加载路径: ((URLClassLoader)App.class.getClassLoader()).getURLs()<br>通过 ClassLoader.getSystemClassLoader() 就可以获取 AppClassLoader, 自己写的程序中写的 ClassLoader(继承 URLClassLoader), 若不指定 parent, 默认的parent就是 AppClassLoader</p>
</li>
</ol>
</blockquote>
<h2 id="同一个class"><a href="#同一个class" class="headerlink" title="同一个class"></a>同一个class</h2><p>在JVM中，如何确定一个类型实例:</p>
<p>同一个Class = 相同的 ClassName + PackageName + ClassLoader</p>
<p>在JVM中，类型被定义在一个叫SystemDictionary 的数据结构中，该数据结构接受类加载器和全类名作为参数，返回类型实例。</p>
<p>SystemDictionary 如图所示：</p>
<p><img src="http://p7c3y4vhx.bkt.clouddn.com/201809251755_835.png" alt="SystemDictionary"></p>
<h2 id="加载机制"><a href="#加载机制" class="headerlink" title="加载机制"></a>加载机制</h2><ol>
<li><strong>全盘负责</strong>，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li>
<li><strong>双亲委托</strong>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li>
<li><strong>缓存机制</strong>，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</li>
</ol>
<h3 id="双亲委托模型"><a href="#双亲委托模型" class="headerlink" title="双亲委托模型"></a>双亲委托模型</h3><p>双亲委托的工作过程：如果一个类加载器收到了一个类加载请求，它首先不会自己去加载这个类，而是把这个请求委托给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成加载请求(它管理的范围之中没有这个类)时，子加载器才会尝试着自己去加载</p>
<p><img src="http://hexo.qnimages.zhuxingsheng.com/201809260947_799.png" alt=""></p>
<ol>
<li><p>当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</p>
</li>
<li><p>当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</p>
</li>
<li><p>如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；</p>
</li>
<li><p>若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac –verbose查看运行类是加载了jar文件</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException&#123;</span><br><span class="line"></span><br><span class="line">	// 首先检查，jvm中是否已经加载了对应名称的类，findLoadedClass(String )方法实际上是findLoadedClass0方法的wrapped方法，做了检查类名的工</span><br><span class="line">       //作，而findLoadedClass0则是一个native方法，通过底层来查看jvm中的对象。</span><br><span class="line">	Class c = findLoadedClass(name);</span><br><span class="line">	if (c == null) &#123;//类还未加载</span><br><span class="line">	    try &#123;</span><br><span class="line">		if (parent != null) &#123;</span><br><span class="line">            //在类还未加载的情况下，我们首先应该将加载工作交由父classloader来处理。</span><br><span class="line">		    c = parent.loadClass(name, false);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">                    //返回一个由bootstrap class loader加载的类，如果不存在就返回null</span><br><span class="line">		    c = findBootstrapClassOrNull(name);</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                // ClassNotFoundException thrown if class not found</span><br><span class="line"></span><br><span class="line">                // from the non-null parent class loader</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (c == null) &#123;</span><br><span class="line">	        // If still not found, then invoke findClass in order</span><br><span class="line">	        // to find the class.</span><br><span class="line">	        c = findClass(name);//这里是我们的入手点，也就是指定我们自己的类加载实现</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (resolve) &#123;</span><br><span class="line">	    resolveClass(c);//用来做类链接操作</span><br><span class="line">	&#125;</span><br><span class="line">	return c;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从上面的方法也看出我们在实现自己的加载器的时候，不要覆盖locaClass方法，而是<strong>重写findClass()</strong>，这样能保证双亲委派模型，同时也实现了自己的方法</p>
<h3 id="为什么要使用双亲委托这种模型呢？"><a href="#为什么要使用双亲委托这种模型呢？" class="headerlink" title="为什么要使用双亲委托这种模型呢？"></a>为什么要使用双亲委托这种模型呢？</h3><ol>
<li>节约系统资源： 因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子ClassLoader再加载一次</li>
<li>保证Java核心库的类型安全: 我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时就被引导类加载器（Bootstrcp ClassLoader）加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的String，除非你改变JDK中ClassLoader搜索类的默认算法。</li>
</ol>
<h2 id="自定义加载器"><a href="#自定义加载器" class="headerlink" title="自定义加载器"></a>自定义加载器</h2><p>既然JVM已经提供了默认的类加载器，为什么还要定义自已的类加载器呢？</p>
<p>因为Java中提供的默认ClassLoader，只加载指定目录下的jar和class，如果我们想加载其它位置的类或jar时，比如：我要加载网络上的一个class文件，通过动态加载到内存之后，要调用这个类中的方法实现业务逻辑。在这样的情况下，默认的ClassLoader就不能满足我们的需求了，所以需要定义自己的ClassLoader</p>
<h3 id="定义自已的类加载器分为两步："><a href="#定义自已的类加载器分为两步：" class="headerlink" title="定义自已的类加载器分为两步："></a>定义自已的类加载器分为两步：</h3><ol>
<li>继承java.lang.ClassLoader</li>
<li>重写父类的findClass方法</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>很简单的两个类，方法中打印出各自的类加载器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class LoaderClass &#123;</span><br><span class="line"></span><br><span class="line">    public void loader()&#123;</span><br><span class="line">        System.out.println(&quot;LoaderClass:&quot;+this.getClass().getClassLoader());</span><br><span class="line">        LoaderClass1 class1 = new LoaderClass1();</span><br><span class="line">        class1.loader();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class LoaderClass1 &#123;</span><br><span class="line"></span><br><span class="line">    public void loader() &#123;</span><br><span class="line">        System.out.println(this.getClass().getName() + &quot; loader:&quot;+this.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>自定义加载器</p>
<ol>
<li>重写findClass方法，从class文件加载</li>
<li>通过defineClass从bytes构建class</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class MyClassLoader extends ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        String root = &quot;d:/&quot;;</span><br><span class="line"></span><br><span class="line">        byte[] bytes = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            //路径改到根目录下</span><br><span class="line">            String file = root + name.substring(name.lastIndexOf(&quot;.&quot;)+1) + &quot;.class&quot;;</span><br><span class="line">            InputStream ins = new FileInputStream(file);</span><br><span class="line">            ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">            int bufferSize = 1024;</span><br><span class="line">            byte[] buffer = new byte[bufferSize];</span><br><span class="line">            int length = 0;</span><br><span class="line">            while ((length = ins.read(buffer)) != -1) &#123;</span><br><span class="line">                baos.write(buffer, 0, length);</span><br><span class="line">            &#125;</span><br><span class="line">            bytes = baos.toByteArray();</span><br><span class="line"></span><br><span class="line">            ins.close();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return defineClass(name, bytes, 0, bytes.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class ClassLoaderTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[]args) throws Exception &#123;</span><br><span class="line">        ClassLoaderTest test = new ClassLoaderTest();</span><br><span class="line"></span><br><span class="line">        System.out.println(test.getClass().getClassLoader());//输出sun.misc.Launcher$AppClassLoader</span><br><span class="line"></span><br><span class="line">        System.out.println(test.getClass().getClassLoader().getParent());//输出sun.misc.Launcher$ExtClassLoader</span><br><span class="line"></span><br><span class="line">        System.out.println(test.getClass().getClassLoader().getParent().getParent());//输出null</span><br><span class="line"></span><br><span class="line">        //=====测试重复加载，类路径中LoaderClass.class存在=================</span><br><span class="line">        //======虽然指定了classloader，但依然输出的是LoaderClass:sun.misc.Launcher$AppClassLoader</span><br><span class="line">        //==删除类路径下的LoaderClass.class,才会输出LoaderClass:com.jack.classloader.MyClassLoader</span><br><span class="line">        //并且loaderclass中创建的对象类加载器也是MyClassLoader</span><br><span class="line">        MyClassLoader classLoader = new MyClassLoader();</span><br><span class="line">        Class&lt;?&gt; loadClass = Class.forName(&quot;com.jack.classloader.LoaderClass&quot;, true, classLoader);</span><br><span class="line">        Method startMethod = loadClass.getMethod(&quot;loader&quot;);</span><br><span class="line">        startMethod.invoke(loadClass.newInstance());</span><br><span class="line"></span><br><span class="line">        //===当类加载器不一样时，两个class不相等</span><br><span class="line">        MyClassLoader classLoader1 = new MyClassLoader();</span><br><span class="line">        Class&lt;?&gt; loadClass1 = Class.forName(&quot;com.jack.classloader.LoaderClass&quot;, true, classLoader1);</span><br><span class="line">        System.out.println(loadClass.equals(loadClass1));//输出false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/jiyiqinlovexx/article/details/51090751" target="_blank" rel="noopener">class加载时机及两种显示加载的区别</a></p>
<p><a href="https://www.cnblogs.com/hunterCecil/p/6379197.html" target="_blank" rel="noopener">JVM类加载机制—类加载的过程</a></p>
<p><a href="https://blog.csdn.net/w425006762/article/details/50452469" target="_blank" rel="noopener">&lt;init&gt;和&lt;clinit&gt;</a></p>
<p><a href="https://www.jianshu.com/p/0b1dba1a1e95" target="_blank" rel="noopener">类加载原理分析&amp;动态加载Jar/Dex</a></p>
<p><a href="https://blog.csdn.net/mweibiao/article/details/79516708" target="_blank" rel="noopener">java类的主动使用/被动使用</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      
      <! -- 添加微信图标 -->
    
    
    
    

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zhuxingsheng.com/blog/recognition-of-rpc-thrift.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="朱兴生">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/6222636?v=3&s=460">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="码农戏码">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="码农戏码" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/recognition-of-rpc-thrift.html" itemprop="url">
                  再识RPC-thrift
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-22T09:46:00+08:00">
                2018-09-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/source/" itemprop="url" rel="index">
                    <span itemprop="name">源码解读</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          
	
	  
	  <span class="post-letters-count">
	    &nbsp; | &nbsp;
	    <span>2k 字</span>
	    &nbsp; | &nbsp;
	    <span>10 min</span>
	  </span>
	  

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="https://www.cs.rutgers.edu/~pxk/417/notes/images/rpc-flow.png" alt="image"></p>
<p>什么是Stub？</p>
<p>Stub是一段代码，用来转换RPC过程中传递的参数。处理内容包括不同OS之间的大小端问题。另外，Client端一般叫Stub，Server端一般叫Skeleton。</p>
<p>生产方式：</p>
<ol>
<li>手动生成，比较麻烦；</li>
<li>自动生成，使用IDL（InterfaceDescriptionLanguate），定义C/S的接口</li>
</ol>
<h2 id="RPC的套路："><a href="#RPC的套路：" class="headerlink" title="RPC的套路："></a>RPC的套路：</h2><p>自古深情留不住 唯有套路留人心</p>
<p>RPC最本质的就是通过socket把方法信息传输到远程服务器并执行相应method</p>
<p>在java界的rpc框架的实现手法：</p>
<ul>
<li>服务端：socket + 反射</li>
<li>客户端：动态代理 + socket</li>
</ul>
<p>之前也解析过motain框架，<a href="https://mp.weixin.qq.com/s/kESoK3NmRp9Cwkg5GlI9DQ" target="_blank" rel="noopener">《motain客服端分析》</a>、《motain服务端分析》</p>
<h1 id="thrift"><a href="#thrift" class="headerlink" title="thrift"></a>thrift</h1><p>由于我司框架是通过thrift改造，发现这个框架没有按java套路出牌，可能这是跨语言类RPC的套路，有必要了解一下</p>
<blockquote>
<p>thrift最初由facebook开发用做系统内各语言之间的RPC通信 。2007年由facebook贡献到apache基金 ，08年5月进入apache孵化器,支持多种语言之间的RPC方式的通信：php语言client可以构造一个对象，调用相应的服务方法来调用java语言的服务 ，跨越语言的C/S RPC调用
　　</p>
</blockquote>
<p><img src="http://p7c3y4vhx.bkt.clouddn.com/201809192020_382.png" alt="thrift"></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="IDL文件"><a href="#IDL文件" class="headerlink" title="IDL文件"></a>IDL文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//HelloService.thrfit</span><br><span class="line">namespace java com.jack.thrift</span><br><span class="line">service HelloService&#123;</span><br><span class="line">    string helloString(1:string what)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运行  thrift -gen HelloService.thrfit</span><br></pre></td></tr></table></figure>
<p>会生成一个HelloService类</p>
<h3 id="实现服务端与客服端"><a href="#实现服务端与客服端" class="headerlink" title="实现服务端与客服端"></a>实现服务端与客服端</h3><p>让服务端打印出客户端传入的参数</p>
<h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ThriftServer &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 启动thrift服务器</span><br><span class="line">     * @param args</span><br><span class="line">     */</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;服务端开启....&quot;);</span><br><span class="line">            TProcessor tprocessor = new HelloService.Processor&lt;HelloService.Iface&gt;(new HelloServiceImpl());</span><br><span class="line">            // 简单的单线程服务模型</span><br><span class="line">            TServerSocket serverTransport = new TServerSocket(9898);</span><br><span class="line">            TServer.Args tArgs = new TServer.Args(serverTransport);</span><br><span class="line">            tArgs.processor(tprocessor);</span><br><span class="line">            tArgs.protocolFactory(new TBinaryProtocol.Factory());</span><br><span class="line">            TServer server = new TSimpleServer(tArgs);</span><br><span class="line">            server.serve();</span><br><span class="line">        &#125;catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class ThriftClient &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;客户端启动....&quot;);</span><br><span class="line">        TTransport transport = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            transport = new TSocket(&quot;localhost&quot;, 9898, 30000);</span><br><span class="line">            // 协议要和服务端一致</span><br><span class="line">            TProtocol protocol = new TBinaryProtocol(transport);</span><br><span class="line">            HelloService.Client client = new HelloService.Client(protocol);</span><br><span class="line">            transport.open();</span><br><span class="line">            String result = client.helloString(&quot;哈哈&quot;);</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; catch (TTransportException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (TException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (null != transport) &#123;</span><br><span class="line">                transport.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>可以看出server,client代码相对很简单，主要看看生成的HelloService类，这个类就是stub代码</p>
<p>来看一下，这个类是如何封装，把method和args传输到远程的</p>
<h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HelloService.Client client = new HelloService.Client(protocol);</span><br><span class="line">String result = client.helloString(&quot;哈哈&quot;);</span><br></pre></td></tr></table></figure>
<p>关键点在HelloService.Client.helloString()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public String helloString(String what) throws org.apache.thrift.TException</span><br><span class="line">    &#123;</span><br><span class="line">      send_helloString(what);</span><br><span class="line">      return recv_helloString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void send_helloString(String what) throws org.apache.thrift.TException</span><br><span class="line">    &#123;</span><br><span class="line">      helloString_args args = new helloString_args();</span><br><span class="line">      args.setWhat(what);</span><br><span class="line">      sendBase(&quot;helloString&quot;, args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>把args抽象成了一个类</li>
<li>属性赋值</li>
<li>发送</li>
</ol>
<p>主要看下sendBase()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void sendBase(String methodName, TBase&lt;?,?&gt; args, byte type) throws TException &#123;</span><br><span class="line">   oprot_.writeMessageBegin(new TMessage(methodName, type, ++seqid_));</span><br><span class="line">   args.write(oprot_);</span><br><span class="line">   oprot_.writeMessageEnd();</span><br><span class="line">   oprot_.getTransport().flush();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>1.oprot_.writeMessageBegin  根据Protocol写数据，比如这儿使用的TBinaryProtocol，以二进制写数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void writeMessageBegin(TMessage message) throws TException &#123;</span><br><span class="line">    if (strictWrite_) &#123;</span><br><span class="line">      int version = VERSION_1 | message.type;</span><br><span class="line">      writeI32(version);</span><br><span class="line">      writeString(message.name);</span><br><span class="line">      writeI32(message.seqid);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      writeString(message.name);</span><br><span class="line">      writeByte(message.type);</span><br><span class="line">      writeI32(message.seqid);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>再深入看看怎么写二进制数据的</p>
<p>int类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void writeI32(int i32) throws TException &#123;</span><br><span class="line">    inoutTemp[0] = (byte)(0xff &amp; (i32 &gt;&gt; 24));</span><br><span class="line">    inoutTemp[1] = (byte)(0xff &amp; (i32 &gt;&gt; 16));</span><br><span class="line">    inoutTemp[2] = (byte)(0xff &amp; (i32 &gt;&gt; 8));</span><br><span class="line">    inoutTemp[3] = (byte)(0xff &amp; (i32));</span><br><span class="line">    trans_.write(inoutTemp, 0, 4);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>string类型，先写长度，再写bytes<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void writeString(String str) throws TException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      byte[] dat = str.getBytes(&quot;UTF-8&quot;);</span><br><span class="line">      writeI32(dat.length);</span><br><span class="line">      trans_.write(dat, 0, dat.length);</span><br><span class="line">    &#125; catch (UnsupportedEncodingException uex) &#123;</span><br><span class="line">      throw new TException(&quot;JVM DOES NOT SUPPORT UTF-8&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>这儿写最终还是使用Transport.write,比如这儿使用的TSocket<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void write(byte[] buf, int off, int len) throws TTransportException &#123;</span><br><span class="line">    if (outputStream_ == null) &#123;</span><br><span class="line">      throw new TTransportException(TTransportException.NOT_OPEN, &quot;Cannot write to null outputStream&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">      outputStream_.write(buf, off, len);</span><br><span class="line">    &#125; catch (IOException iox) &#123;</span><br><span class="line">      throw new TTransportException(TTransportException.UNKNOWN, iox);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>就是写到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outputStream_ = new BufferedOutputStream(socket_.getOutputStream(), 1024);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>2.args.write(oprot_);<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void write(org.apache.thrift.protocol.TProtocol oprot, helloString_args struct) throws org.apache.thrift.TException &#123;</span><br><span class="line">        struct.validate();</span><br><span class="line"></span><br><span class="line">        oprot.writeStructBegin(STRUCT_DESC);</span><br><span class="line">        if (struct.what != null) &#123;</span><br><span class="line">          oprot.writeFieldBegin(WHAT_FIELD_DESC);</span><br><span class="line">          oprot.writeString(struct.what);</span><br><span class="line">          oprot.writeFieldEnd();</span><br><span class="line">        &#125;</span><br><span class="line">        oprot.writeFieldStop();</span><br><span class="line">        oprot.writeStructEnd();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这就是写field,也就是向输出流里写参数内容</p>
<ul>
<li><p>3.oprot_.writeMessageEnd();<br>这表示消息写完成了，各个协议处理不同，比如二进制就是空实现，但如json就需要写个”}”，以完成json格式</p>
</li>
<li><p>4.oprot_.getTransport().flush();  直接flush</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Flushes the underlying output stream if not null.</span><br><span class="line">   */</span><br><span class="line">  public void flush() throws TTransportException &#123;</span><br><span class="line">    if (outputStream_ == null) &#123;</span><br><span class="line">      throw new TTransportException(TTransportException.NOT_OPEN, &quot;Cannot flush null outputStream&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">      outputStream_.flush();</span><br><span class="line">    &#125; catch (IOException iox) &#123;</span><br><span class="line">      throw new TTransportException(TTransportException.UNKNOWN, iox);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="client总结"><a href="#client总结" class="headerlink" title="client总结"></a>client总结</h4><p>整个发送消息就结束了，虽然没有按套路使用动态代理，而是通过生成的stub代码，把methodName,args给封装好了</p>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>服务端也没有通过反射的方式</p>
<p>主要逻辑在生成的HelloService$Processor类中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public static class Processor&lt;I extends Iface&gt; extends org.apache.thrift.TBaseProcessor&lt;I&gt; implements org.apache.thrift.TProcessor &#123;</span><br><span class="line">    private static final org.slf4j.Logger _LOGGER = org.slf4j.LoggerFactory.getLogger(Processor.class.getName());</span><br><span class="line">    public Processor(I iface) &#123;</span><br><span class="line">      super(iface, getProcessMap(new java.util.HashMap&lt;String, org.apache.thrift.ProcessFunction&lt;I, ? extends org.apache.thrift.TBase&gt;&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Processor(I iface, java.util.Map&lt;String, org.apache.thrift.ProcessFunction&lt;I, ? extends org.apache.thrift.TBase&gt;&gt; processMap) &#123;</span><br><span class="line">      super(iface, getProcessMap(processMap));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static &lt;I extends Iface&gt; java.util.Map&lt;String,  org.apache.thrift.ProcessFunction&lt;I, ? extends org.apache.thrift.TBase&gt;&gt; getProcessMap(java.util.Map&lt;String, org.apache.thrift.ProcessFunction&lt;I, ? extends  org.apache.thrift.TBase&gt;&gt; processMap) &#123;</span><br><span class="line">      processMap.put(&quot;helloString&quot;, new helloString());</span><br><span class="line">      return processMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class helloString&lt;I extends Iface&gt; extends org.apache.thrift.ProcessFunction&lt;I, helloString_args&gt; &#123;</span><br><span class="line">      public helloString() &#123;</span><br><span class="line">        super(&quot;helloString&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public helloString_args getEmptyArgsInstance() &#123;</span><br><span class="line">        return new helloString_args();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      protected boolean isOneway() &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      protected boolean handleRuntimeExceptions() &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public helloString_result getResult(I iface, helloString_args args) throws org.apache.thrift.TException &#123;</span><br><span class="line">        helloString_result result = new helloString_result();</span><br><span class="line">        result.success = iface.helloString(args.what);</span><br><span class="line">        return result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>1.先看构造函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected Processor(I iface, java.util.Map&lt;String, org.apache.thrift.ProcessFunction&lt;I, ? extends org.apache.thrift.TBase&gt;&gt; processMap) &#123;</span><br><span class="line">      super(iface, getProcessMap(processMap));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static &lt;I extends Iface&gt; java.util.Map&lt;String,  org.apache.thrift.ProcessFunction&lt;I, ? extends org.apache.thrift.TBase&gt;&gt; getProcessMap(java.util.Map&lt;String, org.apache.thrift.ProcessFunction&lt;I, ? extends  org.apache.thrift.TBase&gt;&gt; processMap) &#123;</span><br><span class="line">      processMap.put(&quot;helloString&quot;, new helloString());</span><br><span class="line">      return processMap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这段把methodName与对应的处理类映射，那后面的事就简单了，当接受到消息，取得methodName,通过map获取对就的处理类回调就可以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static class helloString&lt;I extends Iface&gt; extends org.apache.thrift.ProcessFunction&lt;I, helloString_args&gt; &#123;</span><br><span class="line">      public helloString() &#123;</span><br><span class="line">        super(&quot;helloString&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public helloString_args getEmptyArgsInstance() &#123;</span><br><span class="line">        return new helloString_args();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      protected boolean isOneway() &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      protected boolean handleRuntimeExceptions() &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public helloString_result getResult(I iface, helloString_args args) throws org.apache.thrift.TException &#123;</span><br><span class="line">        helloString_result result = new helloString_result();</span><br><span class="line">        result.success = iface.helloString(args.what);</span><br><span class="line">        return result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>处理类，继承ProcessFunction类，实现getResult(),这个方法就是调用了对应service.helloString()</p>
<p>可以再深入看一下,在socket监听消息时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">client = serverTransport_.accept();</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">          processor = processorFactory_.getProcessor(client);</span><br><span class="line">          inputTransport = inputTransportFactory_.getTransport(client);</span><br><span class="line">          outputTransport = outputTransportFactory_.getTransport(client);</span><br><span class="line">          inputProtocol = inputProtocolFactory_.getProtocol(inputTransport);</span><br><span class="line">          outputProtocol = outputProtocolFactory_.getProtocol(outputTransport);</span><br><span class="line">          if (eventHandler_ != null) &#123;</span><br><span class="line">            connectionContext = eventHandler_.createContext(inputProtocol, outputProtocol);</span><br><span class="line">          &#125;</span><br><span class="line">          while (true) &#123;</span><br><span class="line">            if (eventHandler_ != null) &#123;</span><br><span class="line">              eventHandler_.processContext(connectionContext, inputTransport, outputTransport);</span><br><span class="line">            &#125;</span><br><span class="line">            if(!processor.process(inputProtocol, outputProtocol)) &#123;</span><br><span class="line">              break;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure></p>
<p>关键行：processor.process(inputProtocol, outputProtocol)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public boolean process(TProtocol in, TProtocol out) throws TException &#123;</span><br><span class="line">    TMessage msg = in.readMessageBegin();</span><br><span class="line">    ProcessFunction fn = processMap.get(msg.name);</span><br><span class="line">    if (fn == null) &#123;</span><br><span class="line">      TProtocolUtil.skip(in, TType.STRUCT);</span><br><span class="line">      in.readMessageEnd();</span><br><span class="line">      TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, &quot;Invalid method name: &apos;&quot;+msg.name+&quot;&apos;&quot;);</span><br><span class="line">      out.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));</span><br><span class="line">      x.write(out);</span><br><span class="line">      out.writeMessageEnd();</span><br><span class="line">      out.getTransport().flush();</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    fn.process(msg.seqid, in, out, iface);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这就很明显了，通过methodName从map中取得ProccessFunction，再执行process方法，调用相应service的方法</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然thrift没有按以往java套路出牌，但最根本的把method发送到远程执行是一致的。可能对于多语言来讲，便于所以语言一致性，的确需要通过生成的stub代码手法来实现RPC</p>
<p>当然thrift并不简单，还有很多的内容需要深挖学习，但至少这个简单示例可以了解跨语言型的RPC，相关IDL,Stub的知识，有清晰认知，而不局限于概念</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      
      <! -- 添加微信图标 -->
    
    
    
    

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zhuxingsheng.com/blog/game-gray-release.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="朱兴生">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/6222636?v=3&s=460">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="码农戏码">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="码农戏码" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/game-gray-release.html" itemprop="url">
                  游戏灰度发布
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-26T23:17:16+08:00">
                2018-01-26
              </time>
            

            

            
          </span>

          

          
            
          
	
	  
	  <span class="post-letters-count">
	    &nbsp; | &nbsp;
	    <span>1.3k 字</span>
	    &nbsp; | &nbsp;
	    <span>4 min</span>
	  </span>
	  

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>快速可以说是互联网的最大特点了，唯快不破，快速响应，快速发布，快速部署，快速上线</p>
<p>但上线，毕竟还是有风险的，怎么能又快速响应，又能降低风险范围呢</p>
<p>前人，现人，后人们都在寻找着银弹</p>
<p>部署方式就进化了有很多次，蓝绿部署、滚动部署、灰度发布、金丝雀发布。。。</p>
<p>这些都是为了应对互联网的快速响应需求</p>
<p>游戏的发布现在还是比较粗暴的，对开发，运维也比较简单。</p>
<p>制定一个版本计划，开发，与运营沟通，确定版本内容，到了时间，所有游戏区全部关闭入口，停止服务器，发布，部署，重启，开放入口，一气呵成，快哉！</p>
<p>等等，理想很丰满，现实很骨感</p>
<p>在版本发布最后一天，开发人员在凌晨1、 2点时，还在开发，修复bug，好不容易打包，回家睡觉</p>
<p>第二天运维在8点开始停机发布新版本；</p>
<p>duang,怎么游戏服起不来了，开发请起床，查问题</p>
<p>迷迷糊糊的开发在梦境中惊醒，终于搞定，打包，发版本，启动服务(有时可能要一上午查问题，通知运营方，延长维护时间)</p>
<p>duang,玩家反馈，新功能有问题…</p>
<p>此时，回滚？还是。。。；好汉不回头，哪来的回滚</p>
<p>紧急停机，再寻找问题，修复，上线…</p>
<p>…</p>
<p>整个游戏的链条上，似乎大家都已经习惯，开发习惯，玩家也习惯</p>
<p>习惯麻痹了一切，没有提出更好的策略，大家都这么玩啊，无所谓啦~</p>
<h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><p><strong>细思极恐，我们应该，也需要做得更好</strong></p>
<h2 id="灰度发布／金丝雀发布"><a href="#灰度发布／金丝雀发布" class="headerlink" title="灰度发布／金丝雀发布"></a>灰度发布／金丝雀发布</h2><p>灰度发布是在原有版本可用的情况下，同时部署一个新版本应用作为“金丝雀”（金丝雀对瓦斯极敏感，矿井工人携带金丝雀，以便及时发发现危险），测试新版本的性能和表现，以保障整体系统稳定的情况下，尽早发现、调整问题。</p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/network/gray-deploy.png" alt="灰度发布"></p>
<p>灰度发布／金丝雀发布由以下几个步骤组成：</p>
<ol>
<li>准备好部署各个阶段的工件，包括：构建工件，测试脚本，配置文件和部署清单文件。</li>
<li>从负载均衡列表中移除掉“金丝雀”服务器。</li>
<li>升级“金丝雀”应用（排掉原有流量并进行部署）。</li>
<li>对应用进行自动化测试。</li>
<li>将“金丝雀”服务器重新添加到负载均衡列表中（连通性和健康检查）。</li>
<li>如果“金丝雀”在线使用测试成功，升级剩余的其他服务器。（否则就回滚）</li>
</ol>
<h2 id="游戏架构"><a href="#游戏架构" class="headerlink" title="游戏架构"></a>游戏架构</h2><p><img src="http://oirwmbp4e.bkt.clouddn.com/game/game-server.png" alt="image"></p>
<p>这个架构图比现实丰满不少，真实情况组件可能是单点的，数据层也就是单个mysql，一切都是那么脆弱。</p>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="http://oirwmbp4e.bkt.clouddn.com/game/game-data-stream.png" alt="流程图"></p>
<p>玩家首先登陆游戏运营平台，鉴权完毕，选择区服，通过网关服务器获取到真实game-server信息，通过TCP，玩家与game-server建立起长连接。</p>
<p>通过这个流程，就知道玩家与game-server直接牵手，强依赖的，如果gameserver重启，tcp连接是一定会断的，虽然前端可能尝试重新连接，但对玩家是有感的，不可能对玩家透明。</p>
<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>怎么才能对玩家无感，切换版本呢？</p>
<p><img src="http://oirwmbp4e.bkt.clouddn.com/game/game-server-gray.png" alt="image"></p>
<p>在之前的架构图中，稍作修改，在玩家与Gameserver之间增加一层ha-proxy，这样就有了灰度发布的基础</p>
<p>玩家不再直接与game-server直连，而是与ha-proxy</p>
<h4 id="透明性"><a href="#透明性" class="headerlink" title="透明性"></a>透明性</h4><p>对玩家来说，发版本就是透明的，发版本时，不再需要停机，入口也不需要关闭，7*24玩耍</p>
<h4 id="流量灵活切换"><a href="#流量灵活切换" class="headerlink" title="流量灵活切换"></a>流量灵活切换</h4><p>灰度百分比，可以灵活控制，这里面又涉及到路由规则，复杂了，可以先百分百切换</p>
<h4 id="快速迭代"><a href="#快速迭代" class="headerlink" title="快速迭代"></a>快速迭代</h4><p>玩家无感，出现bug，可以快速修复，快速上线</p>
<h4 id="快速回滚"><a href="#快速回滚" class="headerlink" title="快速回滚"></a>快速回滚</h4><p>一旦新版本有问题，可以马上切回老版本，版本之间无逢切换</p>
<h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><p>加了ha-proxy，多了更多的灵活性</p>
<p>ha-proxy的难点，高可用，高可靠，高性能</p>
<h4 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h4><p>最重要的一点，不能单点；</p>
<p>如果ha-proxy挂了，怎么办？就算game-server正常运行，也不能再提供服务，自己坑了自己</p>
<p>所以ha-proxy不能单点，哪是集群，还是主从？</p>
<p>每台物理机上都部署，还是集中几台部署？</p>
<h4 id="高可靠"><a href="#高可靠" class="headerlink" title="高可靠"></a>高可靠</h4><p>在新旧版本同时在线时，流量是否平滑过渡？ 玩家操作是否保持完整性？</p>
<p>一个玩家操作横跨新旧版本时，数据一致性如何保障？</p>
<h4 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h4><p>游戏服都是尽量压榨单台服务的能力，现在多了一层通讯，IO会不会影响性能？</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>对于以上方案，不论是哪一种实现方式，仁者见仁，条条大路通罗马。</p>
<p>也可能你觉得这种想法本身就是个多余。</p>
<p>能卖1块钱的豆腐，为什么要卖5毛？</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      
      <! -- 添加微信图标 -->
    
    
    
    

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars0.githubusercontent.com/u/6222636?v=3&s=460"
               alt="朱兴生" />
          <p class="site-author-name" itemprop="name">朱兴生</p>
          <p class="site-description motion-element" itemprop="description">彪悍的人生需要书写</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">5</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/zhuxingsheng" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">朱兴生</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">共13.5k字</span>
</div>


        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	




  
  

  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  


</body>
</html>
